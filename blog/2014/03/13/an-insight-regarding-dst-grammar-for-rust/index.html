
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>An insight regarding DST grammar for Rust - The {pnk}f(eli)x Blog</title>
  <meta name="author" content="Felix S. Klock II">

  
  <meta name="description" content="Executive summary: type = unsized ⊎ sized, so we should use
type as our generalization marker, not unsized. Background: Dynamically Sized Types (DST &hellip;">
  

  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://blog.pnkfx.org/blog/2014/03/13/an-insight-regarding-dst-grammar-for-rust/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="The {pnk}f(eli)x Blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<!-- mermaid support as documented at http://insightfultroll.com/blog/2021/03/30/using-mermaid-with-jekyll/ -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>mermaid.initialize({startOnLoad:true});</script>

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">The {pnk}f(eli)x Blog</a></h1>
  
    <h2>The informal ramblings of an ex-pat PL enthusiast</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:blog.pnkfx.org" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">An Insight Regarding DST Grammar for Rust</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-03-13T07:04:00-04:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>Executive summary: <code>type</code> = <code>unsized</code> ⊎ <code>sized</code>, so we should use
<code>type</code> as our generalization marker, not <code>unsized</code>.</p>

<!-- more -->


<ul>
<li><a href="#background_dst">Background: Dynamically Sized Types (DST)</a></li>
<li><a href="#the_insight">The Insight: <code>type</code> is a better generalization marker</a></li>
<li><a href="#the_examples">Examples ported from DST, Take 5</a></li>
</ul>


<a name="L.a.id..background_dst..Background:.Dynamically.Sized.Types..DST...a."></a>
<h2><a id="background_dst">Background: Dynamically Sized Types (DST)</a></h2>

<p>The Rust team has been discussing incorporating &ldquo;dynamically-sized
types&rdquo; into the static semantics for Rust.  Essentially the idea is to
allow code to describe and name static types whose size is only known
at Runtime.  E.g. the integer vector <code>[int, ..5]</code> is known at compile
time to have five elements, and is considered (statically) sized,
while the vector <code>[int]</code> has unknown size at compile time, and so that
type is called unsized.</p>

<p><a href="http://smallcultfollowing.com/babysteps/blog/2013/04/30/dynamically-sized-types/">There</a>
is <a href="http://smallcultfollowing.com/babysteps/blog/2013/06/06/reducing-dst-annotation/">a</a>
series <a href="http://smallcultfollowing.com/babysteps/blog/2013/11/26/thoughts-on-dst-1/">of</a>
blog <a href="http://smallcultfollowing.com/babysteps/blog/2013/11/27/thoughts-on-dst-2">posts</a>
about <a href="http://smallcultfollowing.com/babysteps/blog/2013/11/27/thoughts-on-dst-3/">dynamically</a>
sized <a href="http://smallcultfollowing.com/babysteps/blog/2013/12/02/thoughts-on-dst-4/">types</a>
on <a href="http://smallcultfollowing.com/babysteps/blog/2014/01/05/dst-take-5/">niko&rsquo;s</a>
blog.
So I will not dive into the details too much here</p>

<p>The main points are that the compiler wants to know whether a type is
meant to always have a static size, or if it can potentially be
unsized.  In a language without type polymorphism, this might be easy
to determine directly from the parsed type expression (such as in the
vector examples I gave at the outset).  But once you add polymorphism,
things get a litle harder for the compiler.</p>

<p>Anyway, the plan drafted in Niko&rsquo;s
<a href="http://smallcultfollowing.com/babysteps/blog/2014/01/05/dst-take-5/">&ldquo;DST, Take 5&rdquo;</a>
is to add an <code>unsized</code> keyword, and then use it as a marker to make
certain spots more general than they are by default.  The reasoning
here is that in the common case, you want a type parameter to
represent a sized type.  (Since there are certain operations you
cannot do with a value of an unsized type, such copying the value into
some other location, the compiler needs to know its size statically so
that it can allocate an appopriate amount of space for it.)</p>

<p>So under that scheme, to write type parameter of most general type,
e.g. for a <code>struct</code> definition that ends with an unsized field,
you need to write:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">struct</span> <span class="n">Named</span><span class="o">&lt;</span><span class="kr">unsized</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">name</span><span class="o">:</span> <span class="o">~</span><span class="kt">str</span><span class="p">,</span>
</span><span class='line'>    <span class="n">payload</span><span class="o">:</span> <span class="n">T</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Accepts solely *sized* Named&lt;T&gt;.</span>
</span><span class='line'><span class="k">fn</span> <span class="n">foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Named</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Accepts both sized and *unsized* Named&lt;T&gt;</span>
</span><span class='line'><span class="k">fn</span> <span class="n">bar</span><span class="o">&lt;</span><span class="kr">unsized</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Named</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>That is, you need to use what I will call a &ldquo;generalization&rdquo; marker at
the spot where you bind a type variable, to indicate that the domain of
that type variable is more general than the common-case default of
a sized type.</p>

<p>For defining a trait that can be implemented on any possible type,
including unsized ones, you would need to use the <code>unsized</code> keyword
somewhere there as well.  &ldquo;DST, Take 5&rdquo; proposed
<code>trait Foo&lt;unsized Self&gt; : NormalBounds { ... }</code>
(or <code>trait Foo : unsized + NormalBounds { ... }</code>, but this is broken for
various reasons).
I had been suggesting <code>unsized trait Foo : NormalBounds { ... }</code>,
which Niko rightly objected to (since it is not the trait that is
unsized, but rather potentially its Self type).
Over the Rust work week last week I suggested
<code>trait Foo for unsized : NormalBounds</code> { &hellip; }, which I think is the first
suggestion that Niko and myself could both stomach.  (The reasoning
behind the latter suggestion is that we write <code>impl Trait for
SelfType</code>, so it makes sense to put the generalization marker into the
same position, i.e. filling the placeholder in: <code>Trait for _</code>.)</p>

<a name="L.a.id..the_insight..The.Insight:..code.type..code..is.a.better.generalization.marker..a."></a>
<h2><a id="the_insight">The Insight: <code>type</code> is a better generalization marker</a></h2>

<p>One of the concerns that Niko has pointed out to me is that it is easy
to (mis)read <code>unsized T</code> as saying &ldquo;<code>T</code> must be unsized&rdquo;.  But that is not
what it is saying; it is saying &ldquo;<code>T</code> <em>can</em> be unsized&rdquo;; you can still pass in
a sized type for <code>T</code>.</p>

<p>I was reflecting on that this morning, and I realized something:
The whole point of DST is to partition the type universe into (Sized ⊎ Unsized).
So if you want this construct to be more self-documenting, the
generalization marker should be using some name to describe that union
(Sized ⊎ Unsized), rather than the name <code>unsized</code>.</p>

<p>But we already have a very appropriate name for that union: <code>type</code>!</p>

<p>So that started me thinking: Why don&rsquo;t we use <code>type</code> as our generalization marker?
So the definition of <code>bar</code> in the example above would be written</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">bar</span><span class="o">&lt;</span><span class="k">type</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Named</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>In fact, this can have a very simple explanation: If we keep the <code>Sized</code> trait bound,
then you can just say that</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">...){</span> <span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>desugars to</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">foo</span><span class="o">&lt;</span><span class="k">type</span> <span class="n">T</span><span class="o">:</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>and in general, any type variable formal binding <code>&lt;T:Bounds&gt;</code> desugars
to <code>&lt;type T:Sized+Bounds&gt;</code></p>

<p>I admit, when I first wrote this, I said &ldquo;hmm, this looks a bit like
C++, is that a problem?&rdquo;  But I&rsquo;m coming to like it.  The biggest
problem I can foresee is that a developer might be confused about when
they are suppposed to write <code>foo&lt;type T&gt;</code> versus <code>foo&lt;T&gt;</code>.  But chances
are that someone who does not understand the distinction will <em>not</em>
suffer if they just guess the answer; if they over-generalize, either:</p>

<ul>
<li><p>the code will compile successfully anyway, in which case there is
no harm, except perhaps w.r.t. forward-compatibility of their
library when they may have wished they had imposed the <code>Sized</code>
bound, or</p></li>
<li><p>the compiler will flag a problem in their code, in which case
hopefully our error messages will suggest to add a <code>:Sized</code> bound
or to just not use <code>type</code> in the binding for <code>T</code>.</p></li>
</ul>


<p>If they under-generalize, then they (or their library&rsquo;s clients) will
discover the problem when they apply <code>foo</code>.</p>

<p>For the trait case, it is a little less obvious what to do.
I think we could likewise write:
<code>trait Foo for type : NormalBounds</code>
for the maximally general case.
<code>trait Foo : NormalBounds</code> would then desugar to
<code>trait Foo for type : Sized + NormalBounds</code></p>

<p>So the point is that you would only use the <code>type</code> keyword when you
wanted to explicitly say &ldquo;I am generalizing over <em>all</em> types, not just
sized ones&rdquo;, and thus are opting into the additional constraints that
that scenario presents.</p>

<p>This approach wouldn&rsquo;t be so palatable under earlier envisioned
designs for DST where e.g. you were restricted to write explicitly
<code>unsized struct S { ... }</code> for structs that could end up being
unsized.  But at this point I think we have collectively decided that
such a restriction is unnecessary and undesired, so there is no worry
that someone might end up having to write <code>type struct S { ... }</code>,
which definitely looks nonsensical.</p>

<p>There is another potential advantage to this approach that I have not
explored much yet: we could also add an <code>Unsized</code> trait bound, and
allow people to write <code>&lt;type X:Unsized&gt;</code> for when they want to
restrict <code>X</code> to unsized types alone.  I am not sure whether this is
actual value in this, but it does not seem absurd to put in a special
case in the coherence checker to allow one to write
<code>impl&lt;X:Sized&gt; SomeTrait for X { ... }</code>
and
<code>impl&lt;X:Unsized&gt; SomeTrait for X { ... }</code>
in order to get full coverage of <code>SomeTrait</code> for all types.</p>

<p>Finally, another obvious (though obviously post Rust 1.0) direction
that this approach suggests is that if we decide to add
parameterization over constants, we can likewise use the <code>const</code>
keyword in the spot where I have written the generalization marker
<code>type</code>, e.g.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">foo</span><span class="o">&lt;</span><span class="kr">const</span> <span class="n">N</span><span class="o">:</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nums</span><span class="o">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="kt">f64</span><span class="p">,</span> <span class="p">..</span><span class="n">N</span><span class="p">])</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>(In this case <code>const</code> would not be a generalization marker but instead
a <em>kind</em> marker, since it is changing the domain of the parameter from
being that of a type to being some value within a type.)</p>

<a name="L.a.id..the_examples..Examples.ported.from.DST..Take.5..a."></a>
<h2><a id="the_examples">Examples ported from DST, Take 5</a></h2>

<p>Here are the ported definitions of <code>Rc</code> and <code>RcData</code>.
(Update: had to turn off syntax highlighting to work-around a rendering bug on <code>*</code>.)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>struct Rc&lt;type T&gt; {
</span><span class='line'>    ptr: \*RcData&lt;T&gt;,
</span><span class='line'>    // (a dummy field, just for illustrative purposes)
</span><span class='line'>    dummy: uint,
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct RcData&lt;type T&gt; {
</span><span class='line'>    ref_count: uint,
</span><span class='line'>
</span><span class='line'>    #[max_alignment]
</span><span class='line'>    data: T
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>impl&lt;type T&gt; Drop for Rc&lt;T&gt; {
</span><span class='line'>    fn drop&lt;&#39;a&gt;(&amp;&#39;a mut self) {
</span><span class='line'>        unsafe {
</span><span class='line'>            intrinsics::drop(&amp;mut (*self.ptr).data);
</span><span class='line'>            libc::free(self.ptr);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>Here is the <code>ImmDeref</code> example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">trait</span> <span class="n">ImmDeref</span><span class="o">&lt;</span><span class="k">type</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fn</span> <span class="n">deref</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">&#39;a</span> <span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">&amp;</span><span class="n">&#39;a</span> <span class="n">T</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">impl</span><span class="o">&lt;</span><span class="k">type</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">ImmDeref</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fn</span> <span class="n">deref</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">&#39;a</span> <span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">&amp;</span><span class="n">&#39;a</span> <span class="n">T</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">unsafe</span> <span class="p">{</span>
</span><span class='line'>            <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">ptr</span><span class="p">).</span><span class="n">data</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>(I think I need a wider variety of examples, but this is good enough for now.)</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Felix S. Klock II</span></span>

      








  


<time datetime="2014-03-13T07:04:00-04:00" pubdate data-updated="true"></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/proglang/'>proglang</a>, <a class='category' href='/blog/categories/rust/'>rust</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://blog.pnkfx.org/blog/2014/03/13/an-insight-regarding-dst-grammar-for-rust/" data-via="pnkfelix" data-counturl="http://blog.pnkfx.org/blog/2014/03/13/an-insight-regarding-dst-grammar-for-rust/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/03/13/meta-updating-octopress-post-mavericks-upgrade/" title="Previous Post: Updating Octopress post-Mavericks upgrade.">&laquo; Updating Octopress post-Mavericks upgrade.</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/10/12/viz-a-viz-js/" title="Next Post: Vis-a-vis, part 1: Visualizing Graphs via viz.js">Vis-a-vis, part 1: Visualizing Graphs via viz.js &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2022/05/12/linking-rust-crates/">Linking Rust Crates, Part 1</a>
      </li>
    
      <li class="post">
        <a href="/blog/2022/05/10/visuals-redux-getting-mermaid-going/">Visuals redux: Getting mermaid going</a>
      </li>
    
      <li class="post">
        <a href="/blog/2022/02/09/what-is-rusts-hole-purpose/">What is Rust's Hole Purpose?</a>
      </li>
    
      <li class="post">
        <a href="/blog/2022/01/10/why-i-use-a-debugger/">Why I use a debugger</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/05/03/road-to-turbowish-part-3-design/">Road to TurboWish part 3: Design</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/pnkfelix">@pnkfelix</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'pnkfelix',
            count: 4,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>



  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2022 - Felix S. Klock II -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'pnkfx-blog';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://blog.pnkfx.org/blog/2014/03/13/an-insight-regarding-dst-grammar-for-rust/';
        var disqus_url = 'http://blog.pnkfx.org/blog/2014/03/13/an-insight-regarding-dst-grammar-for-rust/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
