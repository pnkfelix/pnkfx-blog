
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Breaking News: Non-Lexical Lifetimes arrives for everyone - The {pnk}f(eli)x Blog</title>
  <meta name="author" content="Felix S. Klock II">

  
  <meta name="description" content="&#8853;
Update 1 July 2019: fixed bugs in EscapingWriter and
as_reader examples. Hey there everyone! It has been literally years since I last posted &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://blog.pnkfx.org/blog/2019/06/26/breaking-news-non-lexical-lifetimes-arrives-for-everyone/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="The {pnk}f(eli)x Blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">The {pnk}f(eli)x Blog</a></h1>
  
    <h2>The informal ramblings of an ex-pat PL enthusiast</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:blog.pnkfx.org" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Breaking News: Non-Lexical Lifetimes Arrives for Everyone</h1>
    
    
      <p class="meta">
        








  


<time datetime="2019-06-26T12:54:29+02:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


<div class="entry-content"><p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
<em>Update 1 July 2019</em>: fixed bugs in <a href="#Closure.fixes"><code>EscapingWriter</code></a> and
<a href="#Fixed.leaking.into.Drop"><code>as_reader</code></a> examples.
</span></p>

<p>Hey there everyone!</p>

<p>It has been literally years since I last posted to this blog.
I have been doing a bunch of Rust compiler work.
One big feature has been deployed: Non-Lexical Lifetimes (hereafter denoted &ldquo;NLL&rdquo;).</p>

<p>The motivation for this blog post: The next version of Rust, 1.36, is
going to have NLL turned on for the 2015 edition. Going forward,
all editions of Rust will now use NLL.
That is a big change.
It is mostly a change that empowers developers;
but it also is a change that will cause some existing code to break.</p>

<p>This post is going to talk a little bit about what NLL is and why you
as a Rust developer should be excited about it as a feature
(because it enables programmers to express themselves more directly).</p>

<p>However, even though the main feature of NLL is to <em>increase</em>
the set of programs that Rust accepts,
the vast majority of this post will focus on cases where the
switch to NLL has caused the compiler to start
rejecting<label for='soundness-as-a-feature' class='margin-toggle'> &#8853;</label><input type='checkbox' id='soundness-as-a-feature' class='margin-toggle'/><span class='marginnote'>Rejecting unsound code is also a Rust feature that I value highly; but it often fails to excite developers, especially when it causes their legacy code to stop compiling. </span>
code that it used to accept erroneously.</p>

<!-- more -->


<hr />

<p>A note on quality of content (or lack thereof):
After I wrote this post, feedback on <a href="https://www.reddit.com/r/rust/comments/c6hs2t/breaking_news_nonlexical_lifetimes_arrives_for/">reddit</a> and
the <a href="https://users.rust-lang.org/t/blog-post-breaking-news-non-lexical-lifetimes-arrives-for-everyone/29714">users forum</a> pointed out bugs in some of the examples
 below.</p>

<p>The bugs themselves leaked through because of three mistakes
I made in my own development process for this post.</p>

<ol>
<li>Failure to write comparative tests for all of my proposed &ldquo;fixes&rdquo;,</li>
<li>Failure to think about exception safety when writing <code>unsafe</code> code, and</li>
<li>Worst of all: Waited too long to start writing (and then rushed to finish).</li>
</ol>


<p>I will note each significant update (in the margin at the start of the post) as I post them.</p>

<script>
// See https://github.com/imathis/octopress/issues/424
$(document).ready(function(){
    $('body').addClass('collapse-sidebar');
});
</script>


<a name="Table.of.Contents"></a>
<h2>Table of Contents</h2>

<ul>
<li><a href="#Background:.What.is.NLL">Background: What is NLL</a></li>
<li><a href="#How.was.NLL.implemented">How was NLL implemented</a></li>
<li><a href="#NLL.uses.a.new.MIR.borrow-checker">NLL uses a new MIR borrow-checker</a></li>
<li><a href="#NLL.resolves.soundness.bugs">NLL resolves soundess bugs</a></li>
<li><a href="#NLL.deployment.and.the.migration.mode">NLL deployment and the migration mode</a></li>
<li><a href="#But.what.about.the.2015.edition.">But what about the 2015 edition?</a></li>
<li><a href="#What.are.the.soundness.issues.fixed.by.NLL.">What are the soundness issues fixed by NLL?</a>

<ul>
<li><a href="#Closure.fixes">Closure fixes</a></li>
<li><a href="#Match.fixes">Match fixes</a></li>
<li><a href="#Corrections.to.the.model.of.control-flow">Corrections to the model of control-flow</a></li>
<li><a href="#Fixed.leaking.into.Drop">Fixed leaking into Drop</a></li>
<li><a href="#The..liveness.check.">The &ldquo;liveness check&rdquo;</a></li>
<li><a href="#Outlawed.partial.assignment.to.moved.values..for.now.">Outlawed partial assignment to moved values (for now)</a></li>
</ul>
</li>
<li><a href="#Conclusion..Related.Posts..and.Thanks">Conclusion, Related Posts, and Thanks</a></li>
</ul>


<a name="Background:.What.is.NLL"></a>
<h2>Background: What is NLL</h2>

<p>NLL is a change to Rust&rsquo;s static model of <em>lifetimes</em>. Lifetimes are
approximations of the dynamic extent of values in a program. In
earlier versions of Rust, lifetimes had a close correspondence with
lexical scope.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>                               <span class="c1">// SCOPE TREE</span>
</span><span class='line'>                                          <span class="c1">//</span>
</span><span class='line'>    <span class="kd">let</span> <span class="k">mut</span> <span class="n">names</span> <span class="o">=</span>                       <span class="c1">// +- `names` scope start</span>
</span><span class='line'>        <span class="p">[</span><span class="s">&quot;abe&quot;</span><span class="p">,</span> <span class="s">&quot;beth&quot;</span><span class="p">,</span> <span class="s">&quot;cory&quot;</span><span class="p">,</span> <span class="s">&quot;diane&quot;</span><span class="p">];</span> <span class="c1">// |</span>
</span><span class='line'>                                          <span class="c1">// |</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">alias</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>            <span class="c1">// | +- `alias` scope start</span>
</span><span class='line'>                                          <span class="c1">// | |</span>
</span><span class='line'>    <span class="o">*</span><span class="n">alias</span> <span class="o">=</span> <span class="s">&quot;alex&quot;</span><span class="p">;</span> <span class="c1">// &lt;------------------------ write to `*alias`</span>
</span><span class='line'>                                          <span class="c1">// | |</span>
</span><span class='line'>    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span> <span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// &lt;--------------- read of `names[0]`</span>
</span><span class='line'>                                          <span class="c1">// | |</span>
</span><span class='line'>                                          <span class="c1">// | +- `alias` scope end</span>
</span><span class='line'>                                          <span class="c1">// +- `name` scope end</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The above code would be rejected under the old lexical model: the
mutable-borrow <code>&amp;mut names[0]</code> from line 6 would last until the end of
the scope of <code>alias</code>. Since <code>alias</code> is declared at the top-most block
that forms the body of <code>fn main</code>, its scope lasts until the end of
that body, and so when you would try to compile this code, you would get an error like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>error[E0502]: cannot borrow `names[..]` as immutable because it is also borrowed as mutable
</span><span class='line'>  --&gt; src/main.rs:10:20
</span><span class='line'>   |
</span><span class='line'>6  |     let alias = &amp;mut names[0];
</span><span class='line'>   |                      -------- mutable borrow occurs here
</span><span class='line'>...
</span><span class='line'>10 |     println!(&quot;{}&quot;, names[0]);
</span><span class='line'>   |                    ^^^^^^^^ immutable borrow occurs here
</span><span class='line'>...
</span><span class='line'>14 | }
</span><span class='line'>   | - mutable borrow ends here
</span></code></pre></td></tr></table></div></figure>


<p>But this compilation error does not correspond to an actual
unsoundness in the code: the read of <code>names[0]</code> always comes after the
last write through the aliasing reference. This error is an artifact
of the old model of lifetimes that was tightly wedded to lexical
scopes.</p>

<p>With NLL, the Rust compiler internally represents the fact that the
mutable-borrow <code>&amp;mut names[0]</code> does not need to last all the way to
the end of the lexical scope of <code>alias</code>; the mutable-borrow only needs
to last until the final access through <code>alias</code> on line 6. This shorter
mutable-borrow no longer overlaps with the read-access of <code>names[0]</code>
on line 10, and thus the program is accepted by the compiler with NLL enabled.</p>

<p>You can see this in action by trying out the program in the Rust
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=caa469acdfb3c093a9659bb6b4685a09">playpen</a>; this link defaults to the 2018 edition of Rust,
which has had NLL enabled ever since its official <a href="https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#non-lexical-lifetimes">release</a>.</p>

<p>You can read more about the motivation for NLL, with several other examples, on
<a href="https://rust-lang.github.io/rfcs/2094-nll.html">Rust RFC 2094: NLL</a>.</p>

<a name="How.was.NLL.implemented"></a>
<h2>How was NLL implemented</h2>

<p>In Rust, the &ldquo;borrow checker&rdquo; is a static analysis dedicated to enforcing rules like:
 &ldquo;you cannot write through a shared reference&rdquo;,
 &ldquo;you cannot write through an aliased mutable reference&rdquo;, or
 &ldquo;references never outlive their data&rdquo;.</p>

<p>One crucial part of NLL&rsquo;s implementation was the switch from the
legacy AST borrow-checker to a new MIR borrow-checker.</p>

<a name="Background:.What.is.MIR"></a>
<h3>Background: What is MIR</h3>

<p>The Rust compiler works by parsing a program into an Abstract Syntax Tree (AST).</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
Before MIR, we tried to lessen these issues via two abstractions, called &ldquo;Category, Mutabilty, Type&rdquo; (CMT) and &ldquo;ExprUseVisitor&rdquo; (EUV). These hid away AST semantic details and reduced an analysis&rsquo;s concerns to a relatively small set of semantic effects.
Translating to MIR and analyzing that directly has been a superior approach, from a developer-efficiency point of view. MIR is used by more systems within the compiler; thus, MIR&rsquo;s encoding and processing are subject to more compiler developers' scrutiny. This tends to expose bugs more readily. Furthermore, since analyses are operating directly on MIR structures that have a concrete semantics, there is a lower barrier for entry for new compiler  developers seeking to help with MIR-based analyses. The CMT and EUV abstractions, in my opinion, were one reason that AST borrow-checker development was considered a black art.
</span>
AST-based analyses can suffer from three issues:</p>

<ol>
<li><p>First, individual nodes in the AST for a Rust program can have a relatively complicated meaning.
 Examples: <code>recv.invoke()</code> may move or borrow <code>recv</code>, based on the method&rsquo;s signature;
 also, a <code>match</code> expression may move or borrow its input based on the form of pattern on the
 match arm that is executed.</p></li>
<li><p>Second, there are many different varieties of AST nodes, and the
 quality of an analysis may depend on handling all of them. Some
 nodes may have similar semantics (e.g. <code>if</code> and <code>if let</code> can be
 desugared to <code>match</code>), but leveraging such similarity is not
 trivial.</p></li>
<li><p>Third, the tree-structure of the AST does not directly mirror the control-flow of the
 program it represents. Any static analysis interested in the control-flow of an
 AST must build a model of that control-flow; analyses using that modeled control-flow
 take the risk that the modeled control-flow
 <em>diverges</em> from the actual control-flow that is actually implemented by the low-level code generator.
 This was a significant source of subtle bugs in the AST borrow-checker.</p></li>
</ol>


<p>These factors make it difficult to implement and maintain compiler analyses that operate on the AST itself.
This in turn put limits on our ambition when designing such analyses.</p>

<p>Our solution to this suite of problems,
which plagued many aspects of the Rust compiler,
was the introduction of MIR.</p>

<p>MIR is the &ldquo;Middle Intermediate Representation&rdquo; of a Rust program.</p>

<p>After doing some initial AST-based static analyses,
the compiler translates from the AST representation into MIR.
After this translation, subsequent static analyses operate on the MIR.</p>

<p>The MIR is designed to be able to express the semantics of the Rust program
via a smaller-set of basic constructs,
while also encoding the information needed to do static analyses such as type-checking.</p>

<p>The MIR representation is a graph structure that directly corresponds to the program control-flow.
All control-flow, such as loops, breaks, or panics from function invocations, are explicitly encoded.
Complicated AST nodes like <code>match</code> are translated into compositions of simpler MIR nodes.</p>

<p>Since each MIR node is simple, and there is a smaller set of them to consider,
many MIR analyses are easier to implement and maintain than their analogous AST analyses,
addressing the first two issues above.</p>

<p>Since MIR directly encodes the program control-flow,
there is less risk of divergence between the control-flow model and the actual runtime behavior,
addressing the third issue above.</p>

<p>You can read more about the motivations for MIR, which go beyond those
listed here, on <a href="https://rust-lang.github.io/rfcs/1211-mir.html">Rust RFC 1211: MIR</a>.</p>

<a name="NLL.uses.a.new.MIR.borrow-checker"></a>
<h2>NLL uses a new MIR borrow-checker</h2>

<p>As noted above, NLL uses a new borrow-checker that processes MIR rather than the AST.</p>

<p>The main motivation for developing NLL was improving the expressiveness of Rust as a language:
we wanted to enable developers to write code that more directly corresponded to their intuition about
when references were valid and whether aliasing might occur.
(It doesn&rsquo;t hurt that the new code was also more concise.)</p>

<p>Fundamentally, NLL requires operating on a control-flow graph
(that&rsquo;s what puts the &ldquo;non-lexical&rdquo; in &ldquo;non-lexical lifetimes&rdquo;).</p>

<a name="NLL.resolves.soundness.bugs"></a>
<h2>NLL resolves soundness bugs</h2>

<p>As noted above, there were a host of bugs in the old AST borrow-checker.
Unsound code was sometimes accepted by the compiler
because the AST borrow-checker was not reasoning correctly about the program&rsquo;s semantics.</p>

<p>Fixing such bugs was <em>not</em> a primary motivation for implementing NLL.
The fact that such bugs would be fixed effectively &ldquo;for free&rdquo; as a side-effect of operating on MIR
was considered a welcome side-benefit.</p>

<p>There was a social effect on development though, and it is probably worth noting:
Since we, the Rust compiler developers, knew that
the MIR borrow-checker was going to be the <em>primary borrow-checker</em> in the (relatively near) future,
there was <em>signficantly less</em> motivation to fix bugs in the (soon-to-be legacy) AST borrow-checker.</p>

<p>There are currently 8 issues in the Rust bug database that have been tagged as
soundness bugs that are <a href="https://github.com/rust-lang/rust/issues?utf8=%E2%9C%93&amp;q=is%3Aissue++label%3ANLL-fixed-by-NLL+label%3A%22I-unsound+%F0%9F%92%A5%22+"><code>NLL-fixed-by-NLL</code></a>.
The response from the compiler developers for these bugs has usually been
one of either &ldquo;it is not feasible to fix this in the AST borrow-checker&rdquo;
or &ldquo;it is not <em>worthwhile</em> to invest time fixing this in the AST borrow-checker.&rdquo;</p>

<p>To be clear: I am in favor of such a response.
Which is unsurprising, since I have been one of the main voices behind such responses.</p>

<p>But it did mean that such code was allowed to persist in the wild.
Let us dive into that now.</p>

<a name="NLL.deployment.and.the.migration.mode"></a>
<h2>NLL deployment and the migration mode</h2>

<p>NLL was a big change to the compiler. We knew it might suffer from latent bugs:
it might unexpectedly regress compile-times, or
it might incorrectly accept unsound code, or
it might incorrectly reject valid code as unsound.</p>

<p>Furthermore, as discussed in the previous section,
we knew there were instances of previously-accepted code that would be <em>correctly</em> rejected by NLL
as unsound
(due to soundness fixes introduced with MIR borrow-check).</p>

<p>So we knew that NLL could have a negative impact on the developer experience,
but we did not know what the scope of such an impact might be.
To reduce the risk here, we limited the initial deployment of the NLL feature solely
to Rust code targeting the <a href="https://doc.rust-lang.org/stable/edition-guide/rust-2018/ownership-and-lifetimes/non-lexical-lifetimes.html">2018 edition of the language</a>.
Rust crates that did not opt into using the 2018 edition
would still be checked by the old AST borrow-check, warts and all.</p>

<p>Furthermore, since we did not want our end users to hit a road-block
where an attempt to migrate a pre-existing crate from the 2015 edition to the 2018 edition
was stymied by borrow-check errors that they had never seen before,
we included a further safeguard: the <em>NLL migration mode</em>.</p>

<p>The idea behind the NLL migration mode is simple.
First run the MIR borrow-checker on the input crate (buffering any
diagnostics it issues as it runs);
if the code is accepted by the MIR borrow-checker, then borrow-checking is done.
If the MIR borrow-checker rejects the input crate, <em>don&rsquo;t</em> reject it yet;
ask the AST borrow-checker whether it would also reject the crate.
If the AST borrow-checker would accept the crate, then this represents a case
where NLL is rejecting code that the AST borrow-checker would have accepted.
The compiler assumes any such case is an instance of a pre-existing bug in the AST borrow-checker;
it then emits the previously-buffered diagnostics, <em>downgrading</em> any emitted errors to future-compatibility warnings.</p>

<p>The heart of this is that the end user still gets feedback about problems in their code,
but they can keep using their crates for the short-term.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
One more slight UX downside:
an end-user has to wait until both the MIR borrow-checker <em>and</em> the AST borrow-checker run
before seeing diagnostic feedback about errors in a given piece of code.
</span>
The main downsides of the NLL migration-mode are</p>

<ul>
<li><p>Soundness bugs in end-user crates might go unaddressed</p></li>
<li><p>The Rust developers cannot remove the legacy AST borrow-checker
code base. (But we cannot remove it until all editions are using NLL anyway.)</p></li>
</ul>


<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
If you are using the Nightly compiler and want to try turning off migration mode yourself,
you can use <code>#![feature(nll)]</code> to do so.
</span>
In the long-term, we do intend to turn off the migration mode.
With migration mode off, any errors issued by NLL will cause the compiler to reject the input crate,
regardless of what the AST borrow-checker used to say about it.
(We have not yet established a time-line for when the migration mode will be turned off.)</p>

<a name="But.what.about.the.2015.edition."></a>
<h2>But what about the 2015 edition?</h2>

<p>Now that the 2018 edition has been out for about six months, we have
gained more confidence in the quality of the code underpinning NLL,
and we are taking the next step: turning on NLL for the 2015 edition.</p>

<p>As I said at the start of this post, the next Rust release, 1.36, is
going to have NLL turned on for all crates, regardless of edition.</p>

<p>As you might have guessed, we are only turning on the NLL migration mode.
If a crate has been unknowingly taking advantage of some soundness bug
in order to be accepted by the AST borrow-check, the initial impact of NLL
on that crate should be limited to future-compatibility warnings.</p>

<a name="What.are.the.soundness.issues.fixed.by.NLL."></a>
<h2>What are the soundness issues fixed by NLL?</h2>

<p>At this point, you may have questions:</p>

<ul>
<li>&ldquo;Is my crate going to be affected by this?&rdquo;,</li>
<li>&ldquo;What do these warnings from NLL look like?&rdquo;, or</li>
<li>&ldquo;What should I do to address these warnings when I see them?&rdquo;</li>
</ul>


<p>As I already mentioned, there are currently 8 issues tagged as
<a href="https://github.com/rust-lang/rust/issues?utf8=%E2%9C%93&amp;q=is%3Aissue++label%3ANLL-fixed-by-NLL+label%3A%22I-unsound+%F0%9F%92%A5%22+">soundness bugs fixed by NLL</a>.</p>

<p>What I want to do in the rest of this post is show concrete examples of
known crates that ran afoul of one of these soundness bugs. My hope in each case is to
show a reduced example of real code that breaks the rules set by the borrow-checker,
explain why breaking that rule is bad,
and then show how one might resolve the problem exposed by the compiler.</p>

<a name="Closure.fixes"></a>
<h3>Closure fixes</h3>

<p>NLL fixes the handling of closures in various ways.</p>

<p>Here is an example reduced from (an outdated version of) the <code>bart</code> crate
(<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0cfa8715b2b266970154b1d228bcb4d4">play</a>):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kn">use</span> <span class="n">std</span><span class="o">::</span><span class="n">fmt</span><span class="o">::</span><span class="p">{</span><span class="bp">self</span><span class="p">,</span> <span class="n">Write</span><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">pub</span> <span class="k">struct</span> <span class="n">EscapingWriter</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">inner</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">&#39;a</span> <span class="k">mut</span> <span class="n">Write</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">impl</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span> <span class="n">Write</span> <span class="k">for</span> <span class="n">EscapingWriter</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fn</span> <span class="n">write_str</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="bp">self</span><span class="p">,</span> <span class="n">buf</span><span class="o">:</span> <span class="o">&amp;</span><span class="kt">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">fmt</span><span class="o">::</span><span class="nb">Result</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Sneaky use of String::split, capturing the separator:</span>
</span><span class='line'>        <span class="kd">let</span> <span class="k">mut</span> <span class="n">separator</span> <span class="o">=</span> <span class="sc">&#39;_&#39;</span><span class="p">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">part</span> <span class="k">in</span> <span class="n">buf</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="p">{</span> <span class="n">separator</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="n">x</span> <span class="o">==</span> <span class="sc">&#39;&quot;&#39;</span> <span class="p">})</span> <span class="p">{</span>
</span><span class='line'>            <span class="bp">self</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">write_str</span><span class="p">(</span><span class="n">part</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</span><span class='line'>            <span class="k">match</span> <span class="n">separator</span> <span class="p">{</span>
</span><span class='line'>                <span class="sc">&#39;&quot;&#39;</span> <span class="o">=&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">write_str</span><span class="p">(</span><span class="s">&quot;&amp;quot;&quot;</span><span class="p">),</span>
</span><span class='line'>                <span class="n">_</span> <span class="o">=&gt;</span> <span class="nb">Ok</span><span class="p">(()),</span>
</span><span class='line'>            <span class="p">}</span><span class="o">?</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="nb">Ok</span><span class="p">(())</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>which now yields this diagnostic:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>warning[E0503]: cannot use `separator` because it was mutably borrowed
</span><span class='line'>  --&gt; src/lib.rs:12:17
</span><span class='line'>   |
</span><span class='line'>9  |         for part in buf.split(|x| { separator = x; x == &#39;&quot;&#39; }) {
</span><span class='line'>   |                     ------------------------------------------
</span><span class='line'>   |                     |         |     |
</span><span class='line'>   |                     |         |     borrow occurs due to use of `separator` in closure
</span><span class='line'>   |                     |         borrow of `separator` occurs here
</span><span class='line'>   |                     borrow later used here
</span><span class='line'>...
</span><span class='line'>12 |                 &#39;&quot;&#39; =&gt; self.inner.write_str(&quot;&amp;quot;&quot;),
</span><span class='line'>   |                 ^^^ use of borrowed `separator`
</span><span class='line'>   |
</span><span class='line'>   = warning: this error has been downgraded to a warning for backwards compatibility with previous releases
</span><span class='line'>   = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future
</span></code></pre></td></tr></table></div></figure>


<p>As the code notes, this was a sneaky use of <code>String::split</code>.
Too sneaky, in fact.
The closure passed to <code>buf.split</code> captures separator by <code>&amp;mut</code>-reference;
it <em>has</em> to for this code to &ldquo;work&rdquo;, since
the whole idea is to sneak in the mutable reference as a side-channel
for transmitting information out of the invocation of the closure.</p>

<p>The problem is that the closure ends up being stored in the <code>Split</code> iterator returned by the <code>split</code> call;
this is represented by the statement that the borrow is used by the invocation itself,
<code>buf.split(...)</code> that is highlighted and labeled &ldquo;borrow later used here&rdquo;.
Since the <code>Split</code> iterator is what is providing the inputs to this <code>for</code>-loop,
the <code>&amp;mut</code>-borrow of <code>separator</code> has to live <em>across</em> the body of the <code>for</code>-loop.</p>

<p>The Rust memory model does not allow you to have a <code>&amp;mut</code>-borrow alive
across other accesses to its data, so this is rejected by the MIR borrow-checker.
The compiler issues an error, which is downgraded above to a warning by the migration mode (due to the old buggy AST borrow-checker accepting the code as written).</p>

<a name="How.can.you.fix.this."></a>
<h4>How can you fix this?</h4>

<p>The fact that <code>separator</code> is a local bound outside of the loop is a wart:
In my opinion, this code really wants
bind the specific separator it found for <em>each</em> iteration of the loop.</p>

<p>In this specific case, it seems like the <code>str</code> API is a bit impoverished;
I see many variants of the <code>split</code> method,
but I see none that let you extract each of the delimiters that matched the given pattern while also extracting the portions of the string that did not match.</p>

<p>My answer, at least for now, is probably to rewrite the loop using <a href="https://doc.rust-lang.org/std/primitive.str.html#method.match_indices"><code>match_indices</code></a> (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=6806bb295e057b0b4f4c0be543735a19">play</a>):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kn">use</span> <span class="n">std</span><span class="o">::</span><span class="n">fmt</span><span class="o">::</span><span class="p">{</span><span class="bp">self</span><span class="p">,</span> <span class="n">Write</span><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">pub</span> <span class="k">struct</span> <span class="n">EscapingWriter</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">inner</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">&#39;a</span> <span class="k">mut</span> <span class="n">Write</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">impl</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span> <span class="n">Write</span> <span class="k">for</span> <span class="n">EscapingWriter</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fn</span> <span class="n">write_str</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="bp">self</span><span class="p">,</span> <span class="n">buf</span><span class="o">:</span> <span class="o">&amp;</span><span class="kt">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">fmt</span><span class="o">::</span><span class="nb">Result</span> <span class="p">{</span>
</span><span class='line'>        <span class="kd">let</span> <span class="k">mut</span> <span class="n">last_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">delim</span><span class="p">)</span> <span class="k">in</span> <span class="n">buf</span><span class="p">.</span><span class="n">match_indices</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="sc">&#39;\&quot;&#39;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="bp">self</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">write_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">last_index</span><span class="p">..</span><span class="n">index</span><span class="p">])</span><span class="o">?</span><span class="p">;</span>
</span><span class='line'>            <span class="k">match</span> <span class="n">delim</span> <span class="p">{</span>
</span><span class='line'>                <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">&quot;</span> <span class="o">=&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">write_str</span><span class="p">(</span><span class="s">&quot;&amp;quot;&quot;</span><span class="p">),</span>
</span><span class='line'>                <span class="n">_</span> <span class="o">=&gt;</span> <span class="nb">Ok</span><span class="p">(()),</span>
</span><span class='line'>            <span class="p">}</span><span class="o">?</span><span class="p">;</span>
</span><span class='line'>            <span class="n">last_index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="bp">self</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">write_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">last_index</span><span class="p">..])</span><span class="o">?</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="nb">Ok</span><span class="p">(())</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
A previously posted version of this code was untested, and
it mishandled the delimiter and <code>index</code> state;
this brings to mind this variation of an old adage:
&ldquo;Beware of bugs in this code; I have only proved it sound, not tried it.&rdquo;
</span>
The <a href="https://doc.rust-lang.org/std/primitive.str.html#method.match_indices"><code>match_indices</code></a> method works by returning
both the matched delimiter and the index where that delimiter
<em>started</em> in the given string.
This version of the code is still saving state outside of the loop:
it remembers the index where the previous delimiter <em>ended</em> (<code>index + 1</code>,
since in this case we are only matching against delimiters of length 1),
and then after each iteration of the loop, we write the portion
of the input that followed that delimiter (<code>buf[last_index..index]</code>).</p>

<p>You can read about other fixes to the handling of closures at the following issues:</p>

<ul>
<li><a href="https://github.com/rust-lang/rust/issues/53432">#53432 &ldquo;Bug: nested closure outlives borrowed value.&rdquo;</a></li>
</ul>


<a name="Match.fixes"></a>
<h3>Match fixes</h3>

<p>Another area that got a lot of scrutiny with the switch to MIR
borrow-check was the handling of <code>match</code> expressions.</p>

<p>Consider the following code (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=fc1a4fbfd1ed9ad0282c292afe64d5ac">play</a>):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">extern</span> <span class="n">crate</span> <span class="n">crossbeam</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">zero</span> <span class="o">=</span> <span class="o">&amp;</span><span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">one</span> <span class="o">=</span> <span class="o">&amp;</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="kd">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="nb">Some</span><span class="p">(</span><span class="n">zero</span><span class="p">);</span>
</span><span class='line'>    <span class="n">crossbeam</span><span class="o">::</span><span class="n">scope</span><span class="p">(</span><span class="o">|</span><span class="n">s</span><span class="o">|</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="kd">let</span> <span class="nb">Some</span><span class="p">(</span><span class="k">ref</span> <span class="k">mut</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">s</span><span class="p">.</span><span class="nb">spawn</span><span class="p">(</span><span class="n">move</span> <span class="o">|</span><span class="n">_</span><span class="o">|</span> <span class="p">{</span> <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="n">one</span><span class="p">;</span> <span class="p">});</span>
</span><span class='line'>            <span class="c1">//                 ~~~~~~~~~</span>
</span><span class='line'>            <span class="c1">//                     |</span>
</span><span class='line'>            <span class="k">match</span> <span class="n">x</span> <span class="p">{</span> <span class="c1">// &lt;---- DATA RACE on discriminant of `x`!</span>
</span><span class='line'>                <span class="nb">Some</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;saw some&quot;</span><span class="p">),</span>
</span><span class='line'>                <span class="nb">None</span> <span class="o">=&gt;</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;saw none&quot;</span><span class="p">),</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}).</span><span class="n">unwrap</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>which now yields this diagnostic:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>warning[E0503]: cannot use `x` because it was mutably borrowed
</span><span class='line'>  --&gt; src/main.rs:13:17
</span><span class='line'>   |
</span><span class='line'>7  |     crossbeam::scope(|s| {
</span><span class='line'>   |                       - has type `&amp;crossbeam::thread::Scope&lt;&#39;1&gt;`
</span><span class='line'>8  |         if let Some(ref mut y) = x {
</span><span class='line'>   |                     --------- borrow of `x.0` occurs here
</span><span class='line'>9  |             s.spawn(move |_| { *y = one; });
</span><span class='line'>   |             ------------------------------- argument requires that `x.0` is borrowed for `&#39;1`
</span><span class='line'>...
</span><span class='line'>13 |                 Some(_) =&gt; println!(&quot;saw some&quot;),
</span><span class='line'>   |                 ^^^^^^^ use of borrowed `x.0`
</span><span class='line'>   |
</span><span class='line'>   = warning: this error has been downgraded to a warning for backwards compatibility with previous releases
</span><span class='line'>   = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future
</span></code></pre></td></tr></table></div></figure>


<p>Your first reaction, upon reading that, might be &ldquo;there is no use of
<code>x.0</code> there. That match is only looking at the discriminant that
differentiates <code>Option::Some</code> from <code>Option::None</code>, not the data held
in the <code>Some</code>.&rdquo;</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
The initial version of the MIR borrow-checker actually made the same erroneous assumption here.
But the soundness checks performed by MIRI exposed the flaw in reasoning here; see <a href="https://github.com/rust-lang/rust/issues/56797">issue #56797</a>.
</span>
And indeed, the AST borrow-checker assumes that the discriminant for
an enum value is always stored at a memory location that is disjoint from the
fields of that enum variant.</p>

<p>But this assumption is not generally true; Rust is free to make use of
data fields to hold an enum discriminant. (The simplest example of
this: a <code>&amp;T</code> is always a non-null pointer value, and therefore we can
represent an <code>Option&lt;&amp;T&gt;::None</code> as null!)</p>

<p>This means that an access to the discriminant of an enum
<em>might</em><label for='freedom of discrimination' class='margin-toggle'> &#8853;</label><input type='checkbox' id='freedom of discrimination' class='margin-toggle'/><span class='marginnote'>I say &ldquo;might&rdquo; here because we want to maximize the freedom for future versions of the compiler in how it chooses to represent enum discriminants. </span>
access memory stored in the fields of the enum&rsquo;s variants.</p>

<p>In this case, the highlighted <code>Some(_)</code> labeled &ldquo;use of borrowed <code>x.0</code>&rdquo; is the
point where the discriminant (and thus the memory at the location of that field)
might be read. But that would be a data-race with the mutable borrow of
<code>x.0</code> that was stored in <code>y</code> and passed off to another thread.
The compiler issues an error (which is downgraded above to a warning by the migration mode).</p>

<p>In practice, what you&rsquo;re likely to see is a similar error on this variant of the above code (<a href="">play</a>):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">extern</span> <span class="n">crate</span> <span class="n">crossbeam</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">zero</span> <span class="o">=</span> <span class="o">&amp;</span><span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">one</span> <span class="o">=</span> <span class="o">&amp;</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="kd">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="nb">Some</span><span class="p">(</span><span class="n">zero</span><span class="p">);</span>
</span><span class='line'>    <span class="n">crossbeam</span><span class="o">::</span><span class="n">scope</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="kd">let</span> <span class="nb">Some</span><span class="p">(</span><span class="k">ref</span> <span class="k">mut</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">match</span> <span class="n">x</span> <span class="p">{</span>
</span><span class='line'>                <span class="nb">Some</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;saw some&quot;</span><span class="p">),</span>
</span><span class='line'>                <span class="nb">None</span> <span class="o">=&gt;</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;saw none&quot;</span><span class="p">),</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="n">one</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}).</span><span class="n">unwrap</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>which now yields this diagnostic:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>warning[E0503]: cannot use `x` because it was mutably borrowed
</span><span class='line'>  --&gt; src/main.rs:10:17
</span><span class='line'>   |
</span><span class='line'>8  |         if let Some(ref mut y) = x {
</span><span class='line'>   |                     --------- borrow of `x.0` occurs here
</span><span class='line'>9  |             match x {
</span><span class='line'>10 |                 Some(_) =&gt; println!(&quot;saw some&quot;),
</span><span class='line'>   |                 ^^^^^^^ use of borrowed `x.0`
</span><span class='line'>...
</span><span class='line'>13 |             *y = one;
</span><span class='line'>   |             -------- borrow later used here
</span><span class='line'>   |
</span><span class='line'>   = warning: this error has been downgraded to a warning for backwards compatibility with previous releases
</span><span class='line'>   = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future
</span></code></pre></td></tr></table></div></figure>


<p>This does not represent a data-race, but it does represent a violation
of the Rust memory model that is designed to prevent data races like
the one above.</p>

<a name="How.can.you.fix.this."></a>
<h4>How can you fix this?</h4>

<p>One option is to change the code to avoid inspecting the discriminant a second time.
Another option is to reorganize the code so that the
final write to <code>*y</code> is guaranteed to precede the second match of <code>x</code>.</p>

<a name="Fixes.to.match.guards"></a>
<h4>Fixes to match guards</h4>

<p>Another instance of a problem with <code>match</code> that has been resolved by NLL is the handling of <em>match guards</em>.</p>

<p>Consider this code, reduced from the <a href="https://github.com/andreastt/htmlgrep">htmlgrep crate</a> (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4246e291c64c2b3550a7f633bdbe85ca">play</a>):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">pub</span> <span class="k">struct</span> <span class="n">Matches</span><span class="p">;</span>
</span><span class='line'><span class="k">pub</span> <span class="k">struct</span> <span class="n">Options</span> <span class="p">{</span> <span class="n">separator</span><span class="o">:</span> <span class="n">char</span><span class="p">,</span> <span class="n">max</span><span class="o">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">usize</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">impl</span> <span class="n">Matches</span> <span class="p">{</span> <span class="k">fn</span> <span class="n">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">usize</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">print_count</span><span class="p">(</span><span class="n">matches</span><span class="o">:</span> <span class="n">Matches</span><span class="p">,</span> <span class="n">opts</span><span class="o">:</span> <span class="n">Options</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">match</span> <span class="n">opts</span><span class="p">.</span><span class="n">max</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">Some</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">matches</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="o">=&gt;</span> <span class="nb">print</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}{}&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">opts</span><span class="p">.</span><span class="n">separator</span><span class="p">),</span>
</span><span class='line'>        <span class="nb">Some</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">|</span> <span class="nb">None</span> <span class="o">=&gt;</span> <span class="nb">print</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}{}&quot;</span><span class="p">,</span> <span class="n">matches</span><span class="p">.</span><span class="n">count</span><span class="p">(),</span> <span class="n">opts</span><span class="p">.</span><span class="n">separator</span><span class="p">),</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The above code is accepted by AST borrow-check, but it has a huge mistake:
the <code>count</code> method takes <code>Matches</code> by value,
which means evaluating the first guard consumes it.
This code should <em>not</em> be allowed to invoke <code>matches.count()</code>
on the second match arm.</p>

<p>With NLL, we now see the following diagnostic:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>warning[E0382]: use of moved value: `matches`
</span><span class='line'>  --&gt; src/lib.rs:11:36
</span><span class='line'>   |
</span><span class='line'>8  | fn print_count(matches: Matches, opts: Options) {
</span><span class='line'>   |                ------- move occurs because `matches` has type `Matches`, which does not implement the `Copy` trait
</span><span class='line'>9  |     match opts.max {
</span><span class='line'>10 |         Some(n) if matches.count() &gt; n =&gt; print!(&quot;{}{}&quot;, n, opts.separator),
</span><span class='line'>   |                    ------- value moved here
</span><span class='line'>11 |         Some(_) | None =&gt; print!(&quot;{}{}&quot;, matches.count(), opts.separator),
</span><span class='line'>   |                                          ^^^^^^^ value used here after move
</span><span class='line'>   |
</span><span class='line'>   = warning: this error has been downgraded to a warning for backwards compatibility with previous releases
</span><span class='line'>   = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future
</span></code></pre></td></tr></table></div></figure>


<a name="How.can.you.fix.this."></a>
<h4>How can you fix this?</h4>

<p>In this case, the code is just wrong. Either the <code>count</code> method should
be taking <code>&amp;self</code> rather tnan <code>self</code>, or it should calcuate
<code>matches.count()</code> once and save its value in a local variable before
entering the <code>match</code>.</p>

<hr />

<p>For further discussion of various bugs in borrow-checking <code>match</code> that are
resolved by NLL, see the following issues on the Rust repository:</p>

<ul>
<li><a href="https://github.com/rust-lang/rust/issues/27282">#27282 &ldquo;Can mutate in match-arm using a closure&rdquo;</a></li>
<li><a href="https://github.com/rust-lang/rust/issues/45045">#45045 &ldquo;binding-less matches on borrowed data are incorrectly allowed&rdquo;</a></li>
<li><a href="https://github.com/rust-lang/rust/issues/56797">#56797 &ldquo;Matching on an enum should read the entire enum&rdquo;</a></li>
</ul>


<a name="Corrections.to.the.model.of.control-flow"></a>
<h3>Corrections to the model of control-flow</h3>

<p>As mentioned above, one of the problems with AST borrow-check
is that it used an internal model of control-flow that could diverge from
the actual control-flow of the generated program.</p>

<!-- An easy example of this can be seen in this code from reduced from the [fractions_and_matrices][] crate on github.
[fractions_and_matrices]: https://github.com/AuroransSolis/fractions_and_matrices
git@github.com:AuroransSolis/fractions_and_matrices.git
-->


<p>An easy example of this can be seen in this code from the <a href="https://github.com/floriama/agents/">floriama/agents</a> crate on github
(<a href="https://github.com/floriama/agents/blob/4cbecde2dbb408266b94c1ac73aa7c2d405936f3/src/network.rs#L215">line permalink</a>):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">node_payload_mut</span><span class="p">(</span><span class="n">i_idx</span><span class="p">).</span><span class="n">physics</span><span class="p">.</span><span class="n">pos</span> <span class="o">+=</span>
</span><span class='line'>    <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">node_payload</span><span class="p">(</span><span class="n">i_idx</span><span class="p">).</span><span class="n">physics</span><span class="p">.</span><span class="n">vel</span><span class="p">.</span><span class="n">scale</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>This used to be accepted, because the AST borrow-check used a
control-flow model that said <code>LHS += RHS</code> is evaluated like so:</p>

<ol>
<li>evaluate the right-hand side (RHS), putting its value into a temporary local.</li>
<li>evaluate the left-hand side (LHS),</li>
<li>call the <code>add_assign</code> method on the evaluated LHS, passing it the RHS.</li>
</ol>


<p>But that does not agree with the actual semantics of Rust.
Rust actually evaluates the LHS <em>before</em> the RHS and then performs the
<code>add_assign</code> invocation.</p>

<p>So you can probably now see the problem with the code above: the AST
borrow-check allows the immutable borrow for the evaluation of the RHS.
Such an immutable borrow does not need to outlive that evaluation.
Thus, if the RHS were evaluated first, then the immutable borrow
would not overlap the <code>&amp;mut</code>-borrow required for the evaluation of LHS.
But the LHS <em>is</em> evaluated first, and its <code>&amp;mut</code>-borrow does need to last
up through and including the invocation of <code>add_assign</code>.</p>

<p>Thus, the line of code above now issues the following diagnostic:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>warning[E0502]: cannot borrow `self.graph` as immutable because it is also borrowed as mutable
</span><span class='line'>   --&gt; src/network.rs:216:17
</span><span class='line'>    |
</span><span class='line'>215 |               self.graph.node_payload_mut(i_idx).physics.pos +=
</span><span class='line'>    |               ----------
</span><span class='line'>    |               |
</span><span class='line'>    |  _____________mutable borrow occurs here
</span><span class='line'>    | |
</span><span class='line'>216 | |                 self.graph.node_payload(i_idx).physics.vel.scale(dt);
</span><span class='line'>    | |_________________^^^^^^^^^^_________________________________________- mutable borrow later used here
</span><span class='line'>    |                   |
</span><span class='line'>    |                   immutable borrow occurs here
</span><span class='line'>    |
</span><span class='line'>    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases
</span><span class='line'>    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future
</span></code></pre></td></tr></table></div></figure>




<!--
Even the simpler expression `LHS = RHS` has the same issue here:
the AST borrow-check models this as evaluating RHS before LHS,
but its actual behavior is that the LHS is evaluated first.

https://crater-reports.s3.amazonaws.com/pr-60914/try%23f45cc3094ee337acd688771b9234318046b0572d/gh/ethowitz.life/log.txt
-->


<a name="How.can.you.fix.this."></a>
<h4>How can you fix this?</h4>

<p>In this case, the common fix is to do the evaluation of the RHS before the LHS, like so:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kd">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">node_payload</span><span class="p">(</span><span class="n">i_idx</span><span class="p">).</span><span class="n">physics</span><span class="p">.</span><span class="n">vel</span><span class="p">.</span><span class="n">scale</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>
</span><span class='line'><span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">node_payload_mut</span><span class="p">(</span><span class="n">i_idx</span><span class="p">).</span><span class="n">physics</span><span class="p">.</span><span class="n">pos</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
This text is a bit blasé about the effort associated with transforming
<code>LHS += RHS</code> into <code>let rhs = RHS; LHS += rhs</code>
In fact, there were bugs we fixed in NLL that would have required a similar pattern
to be deployed widely across many code bases; namely, cases where one did <code>foo.mutate(&amp;*foo.field)</code>
would have been forced to be rewritten as <code>{ let rhs = &amp;*foo.field; foo.mutate(rhs) }</code>
We did realize that for NLL to be adopted in practice, we needed to continue accepting such code.
This is what motivated the introduction of two-phase borrows aka <a href="https://rust-lang.github.io/rfcs/2025-nested-method-calls.html">RFC 2025: &ldquo;nested method calls&rdquo;</a>.
</span>
Of course, you should verify that such a reordering is actually valid in each such case;
The fact that this code rewrite is not semantics-preserving in general is why we did not
just have the compiler do it for you behind the scenes.</p>

<hr />

<p>For further discussion of these issues with modeling control-flow, see</p>

<ul>
<li><p><a href="https://github.com/rust-lang/rust/issues/27868">#27868 &ldquo;Inconsistent evaluation order for assignment operations&rdquo;</a></p></li>
<li><p><a href="https://github.com/rust-lang/rust/issues/38899">#38899 &ldquo;borrowed referent of a <code>&amp;T</code> sometimes incorrectly allowed&rdquo;</a></p></li>
</ul>


<a name="Fixed.leaking.into.Drop"></a>
<h3>Fixed leaking into Drop</h3>

<p>Our next example is reduced from code found in the <a href="https://github.com/estebank/galvanize/blob/a9624a317d8664dced737b203d2712f4127eb90e/src/writer.rs#L121">galvanize</a> crate on github :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">struct</span> <span class="nb">Reader</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">file</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">&#39;a</span> <span class="k">mut</span> <span class="n">F</span> <span class="p">}</span>
</span><span class='line'><span class="k">struct</span> <span class="nb">Writer</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">file</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">&#39;a</span> <span class="k">mut</span> <span class="n">F</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">impl</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="nb">Writer</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">pub</span> <span class="k">fn</span> <span class="n">as_reader</span><span class="p">(</span><span class="k">mut</span> <span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Reader</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="n">F</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="kd">let</span> <span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="bp">self</span><span class="p">;</span>
</span><span class='line'>            <span class="n">s</span><span class="p">.</span><span class="n">finalize</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="nb">Reader</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">file</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>That looks pretty innocent, right?</p>

<p>Well, lets see what NLL has to say about it (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=a0143f0e7bbf1bf0bfeb3eac4c6c8801">play</a>):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>warning[E0713]: borrow may still be in use when destructor runs
</span><span class='line'>  --&gt; src/lib.rs:12:21
</span><span class='line'>   |
</span><span class='line'>6  | impl&lt;&#39;a, F&gt; Writer&lt;&#39;a, F&gt; {
</span><span class='line'>   |      -- lifetime `&#39;a` defined here
</span><span class='line'>...
</span><span class='line'>12 |         Reader::new(self.file)
</span><span class='line'>   |         ------------^^^^^^^^^- returning this value requires that `*self.file` is borrowed for `&#39;a`
</span><span class='line'>13 |     }
</span><span class='line'>   |     - here, drop of `self` needs exclusive access to `*self.file`, because the type `Writer&lt;&#39;_, F&gt;` implements the `Drop` trait
</span><span class='line'>   |
</span><span class='line'>   = warning: this error has been downgraded to a warning for backwards compatibility with previous releases
</span><span class='line'>   = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future
</span></code></pre></td></tr></table></div></figure>


<p>Oh, yeah, I forgot to mention: there&rsquo;s an <code>impl Drop</code> on <code>Writer</code>, and that changes everything.</p>

<p>As the diagnostic explains, the destructor for <code>Writer</code> has exclusive access to its fields while it runs,
including the <code>&amp;mut</code> borrow in <code>self.file</code>.</p>

<p>Therefore we cannot just hand off <code>self.file</code> to the new <code>Reader</code> while also allowing the destructor to run;
that would violate Rust&rsquo;s aliasing rules for <code>&amp;mut</code>.</p>

<a name="How.can.you.fix.this."></a>
<h4>How can you fix this?</h4>

<p>One approach is wrap an <code>Option</code> around the <code>&amp;mut F</code> reference in <code>Writer</code>, and swap in <code>None</code> in the <code>as_reader</code> method.
This is sort of a drag though, since it means all the other <code>Writer</code> methods end up checking for <code>None</code>, just because of this usage here.</p>

<p>You might have noticed that <code>as_reader</code> is already doing the same work that <code>drop</code> does (namely, call <code>finalize</code> on the writer).
So it would be nice if we could move the file out of <code>self</code> and then <code>mem::forget(self)</code> to prevent its destructor from running.
Unfortunately, that does not work: <code>mem::forget</code> still wants a fully-formed value for its input.</p>

<p>The previous idea <em>does</em> yield the basis for a valid second approach, though (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f4446f2e88a6ffc19b65a845fb05c6f4">play</a>):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">pub</span> <span class="k">fn</span> <span class="n">as_reader</span><span class="p">(</span><span class="k">mut</span> <span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Reader</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="n">F</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kd">let</span> <span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="bp">self</span><span class="p">;</span>
</span><span class='line'>        <span class="n">s</span><span class="p">.</span><span class="n">finalize</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">file</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">F</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span>
</span><span class='line'>        <span class="kd">let</span> <span class="n">f</span><span class="o">:</span> <span class="o">*</span><span class="kr">const</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">F</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="bp">self</span><span class="p">.</span><span class="n">file</span><span class="p">;</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">mem</span><span class="o">::</span><span class="n">forget</span><span class="p">(</span><span class="bp">self</span><span class="p">);</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">ptr</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="nb">Reader</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
An earlier version of this post wrapped the <code>&amp;mut F</code> in a <code>ManuallyDrop</code> in the definition of <code>struct Writer</code>, and called (the currently unstable) <a href="https://doc.rust-lang.org/std/mem/struct.ManuallyDrop.html#method.take"><code>take</code></a> method to extract a copy of the reference. But this is not really an intended use of <code>ManuallyDrop</code>. After all, <code>&amp;mut F</code> has no destructor <em>itself</em>, so it was (at best) an awkward way to express the intent: store a local copy of the <code>self.file</code> reference before forgetting <code>self</code>. That intent is more clearly expressed via <code>ptr::read</code>.
</span>
This new version uses <a href="https://doc.rust-lang.org/std/ptr/fn.read.html"><code>ptr::read</code></a> to extract the file before forgetting <code>self</code>.
(This does require using <code>unsafe</code>, though.)</p>

<hr />

<p>For further discussion of how destructors interact with the
borrow-checking, see the following issues on the Rust repository:</p>

<ul>
<li><a href="https://github.com/rust-lang/rust/issues/31567">#31567 &ldquo;<code>Drop</code> and leaking <code>&amp;mut</code> references&rdquo;</a></li>
</ul>


<!--
### Corrections to handling of unions

 * [\#45157 "Borrow checker unsoundness with unions"][issue #45157]

### Corrections to handling of const-promoted expressions

 * [\#46557 "Compiler accepts return mut ref to local var on no longer valid stackframe"][issue #46557]

 * [\#49955 "Garbage value when accessing a reference into a field/element of a const value."][issue #49955]
-->




<!--
### Corrections to region-checking
Here is an example reduced from (an outdated version of) the `compare-version` crate.
--Nope, not sure this is something to advertise; see https://github.com/rust-lang/rust/issues/62185
-->


<a name="The..liveness.check."></a>
<h3>The &ldquo;liveness check&rdquo;</h3>

<p>The liveness check enforces the rule: &ldquo;any region which appears at the point P
must contain the point P.&rdquo;</p>

<p>The AST borrow-check did not actually enforce this
rule in all cases.</p>

<p>Here is an example reduced from an outdated version of the <code>enumflags2</code> crate (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=522815bfdc2bbaba98b6ab6673b93937">play</a>):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">pub</span> <span class="k">trait</span> <span class="n">RawBitFlags</span><span class="o">:</span> <span class="n">Copy</span> <span class="o">+</span> <span class="nb">Clone</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">type</span> <span class="n">Type</span><span class="p">;</span>
</span><span class='line'>    <span class="k">fn</span> <span class="n">flag_list</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="o">&amp;</span><span class="n">&#39;static</span> <span class="p">[</span><span class="n">Self</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">pub</span> <span class="k">struct</span> <span class="n">BitFlags</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span> <span class="n">RawBitFlags</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">val</span><span class="o">:</span> <span class="n">T</span><span class="o">::</span><span class="n">Type</span><span class="p">,</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span> <span class="n">RawBitFlags</span><span class="o">&gt;</span> <span class="n">BitFlags</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fn</span> <span class="n">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">T</span><span class="o">::</span><span class="n">flag_list</span><span class="p">().</span><span class="n">iter</span><span class="p">().</span><span class="n">cloned</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>which now yields this diagnostic:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>warning[E0310]: the parameter type `T` may not live long enough
</span><span class='line'>  --&gt; src/lib.rs:13:22
</span><span class='line'>   |
</span><span class='line'>13 |     fn iter(self) -&gt; impl Iterator&lt;Item = T&gt; {
</span><span class='line'>   |                      ^^^^^^^^^^^^^^^^^^^^^^^
</span><span class='line'>   |
</span><span class='line'>   = help: consider adding an explicit lifetime bound `T: &#39;static`...
</span><span class='line'>   = warning: this error has been downgraded to a warning for backwards compatibility with previous releases
</span><span class='line'>   = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future
</span><span class='line'>
</span><span class='line'>warning[E0310]: the parameter type `T` may not live long enough
</span><span class='line'>  --&gt; src/lib.rs:14:9
</span><span class='line'>   |
</span><span class='line'>14 |         T::flag_list().iter().cloned()
</span><span class='line'>   |         ^^^^^^^^^^^^^^
</span><span class='line'>   |
</span><span class='line'>   = help: consider adding an explicit lifetime bound `T: &#39;static`...
</span><span class='line'>   = warning: this error has been downgraded to a warning for backwards compatibility with previous releases
</span><span class='line'>   = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future
</span></code></pre></td></tr></table></div></figure>


<p>Here, we see that the compiler is newly detecting a case that it had
previously missed, where the existential type returned by <code>iter</code> holds
instances of the type <code>T</code>.
The compiler wants the code to state up front that these values will
not carry any non-static references, because of the liveness rule:
since we do not have any constraint on where in this control-flow
this iterator will be used, any regions in its type must contain all
points in the control-flow.</p>

<p>This liveness rule was a change that Niko had spent some time
considering adding to the AST borrow-check as well, as documented in
<a href="https://github.com/rust-lang/rust/pull/55988">PR 55988: introduce &ldquo;type must be valid for&rdquo; into lexical region solver</a>.
In the end, he found a narrower fix that addressed the most serious cases,
and we ended up falling back on our default plan of letting the remaining bugs in this area
just get fixed with the migration to NLL.</p>

<hr />

<p>You can see further discussion of this on:</p>

<ul>
<li><a href="https://github.com/rust-lang/rust/issues/55756">#55756: Lifetimes bug on beta 1.31: the associated type may not live long enough</a></li>
</ul>


<a name="Outlawed.partial.assignment.to.moved.values..for.now."></a>
<h3>Outlawed partial assignment to moved values (for now)</h3>

<p>One last thing to mention that is <em>not</em> a soundness fix, but does break some AST borrow-check code in the wild.
The NLL system finally fixed a bug that was uncovered over four years ago.</p>

<p>Here&rsquo;s one of the instances I found of this bug, from the <code>epub</code> crate:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="p">...</span>
</span><span class='line'><span class="kd">let</span> <span class="n">arnode</span> <span class="o">=</span> <span class="n">Rc</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">RefCell</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">current</span> <span class="o">=</span> <span class="n">parents</span><span class="p">.</span><span class="n">last</span><span class="p">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="kd">let</span> <span class="nb">Some</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="n">current</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">c</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">().</span><span class="n">childs</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">arnode</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span>
</span><span class='line'>        <span class="n">node</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">Some</span><span class="p">(</span><span class="n">Rc</span><span class="o">::</span><span class="n">downgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>This now yields the following diagnostic:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="n">warning</span><span class="p">[</span><span class="n">E0382</span><span class="p">]</span><span class="o">:</span> <span class="n">assign</span> <span class="n">to</span> <span class="n">part</span> <span class="n">of</span> <span class="n">moved</span> <span class="n">value</span><span class="o">:</span> <span class="err">`</span><span class="n">node</span><span class="err">`</span>
</span><span class='line'>  <span class="o">--&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">xmlutils</span><span class="p">.</span><span class="n">rs</span><span class="o">:</span><span class="mi">68</span><span class="o">:</span><span class="mi">29</span>
</span><span class='line'>   <span class="o">|</span>
</span><span class='line'><span class="mi">53</span> <span class="o">|</span>                     <span class="kd">let</span> <span class="k">mut</span> <span class="n">node</span> <span class="o">=</span> <span class="n">XMLNode</span> <span class="p">{</span>
</span><span class='line'>   <span class="o">|</span>                         <span class="o">--------</span> <span class="n">move</span> <span class="n">occurs</span> <span class="n">because</span> <span class="err">`</span><span class="n">node</span><span class="err">`</span> <span class="n">has</span> <span class="k">type</span> <span class="err">`</span><span class="n">xmlutils</span><span class="o">::</span><span class="n">XMLNode</span><span class="err">`</span><span class="p">,</span> <span class="n">which</span> <span class="n">does</span> <span class="n">not</span> <span class="n">implement</span> <span class="n">the</span> <span class="err">`</span><span class="n">Copy</span><span class="err">`</span> <span class="k">trait</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="mi">62</span> <span class="o">|</span>                     <span class="kd">let</span> <span class="n">arnode</span> <span class="o">=</span> <span class="n">Rc</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">RefCell</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
</span><span class='line'>   <span class="o">|</span>                                                       <span class="o">----</span> <span class="n">value</span> <span class="n">moved</span> <span class="n">here</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="mi">68</span> <span class="o">|</span>                             <span class="n">node</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">Some</span><span class="p">(</span><span class="n">Rc</span><span class="o">::</span><span class="n">downgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">));</span>
</span><span class='line'>   <span class="o">|</span>                             <span class="o">^^^^^^^^^^^</span> <span class="n">value</span> <span class="n">partially</span> <span class="n">assigned</span> <span class="n">here</span> <span class="n">after</span> <span class="n">move</span>
</span><span class='line'>   <span class="o">|</span>
</span><span class='line'>   <span class="o">=</span> <span class="n">warning</span><span class="o">:</span> <span class="n">this</span> <span class="n">error</span> <span class="n">has</span> <span class="n">been</span> <span class="n">downgraded</span> <span class="n">to</span> <span class="n">a</span> <span class="n">warning</span> <span class="k">for</span> <span class="n">backwards</span> <span class="n">compatibility</span> <span class="n">with</span> <span class="n">previous</span> <span class="n">releases</span>
</span><span class='line'>   <span class="o">=</span> <span class="n">warning</span><span class="o">:</span> <span class="n">this</span> <span class="n">represents</span> <span class="n">potential</span> <span class="n">undefined</span> <span class="n">behavior</span> <span class="k">in</span> <span class="n">your</span> <span class="n">code</span> <span class="n">and</span> <span class="n">this</span> <span class="n">warning</span> <span class="n">will</span> <span class="n">become</span> <span class="n">a</span> <span class="n">hard</span> <span class="n">error</span> <span class="k">in</span> <span class="n">the</span> <span class="n">future</span>
</span></code></pre></td></tr></table></div></figure>


<p>I freely admit that this <em>does not</em> represent undefined behavior of any
sort. The language design team&rsquo;s decision to outlaw this code was not based
on catching soundness errors; the motivation was for overall <a href="https://github.com/rust-lang/rust/issues/21232#issuecomment-427152371">consistency in the language</a>.</p>

<p>However, I do suspect that this often will catch a bug in the code when it arises. (For example, in this case: did the author actually intend to mutate the field on <code>arparent</code> intead?)</p>

<p>(The basic problem is that if you initialize a field of an
uninitialized struct, you currently cannot read from that field. So
doing such an initialization serves almost no purpose.)</p>

<a name="How.can.you.fix.this."></a>
<h4>How can you fix this?</h4>

<p>Your main options here are one of the following:</p>

<ol>
<li>stop writing to the fields in question, or</li>
<li>re-initialize the struct value before doing a write, or</li>
<li>restructure the code so that you use locals instead of a single struct.</li>
</ol>


<hr />

<p>For much further discussion of how we ended up outlawing this coding
construct, and some hypothetical plans for treating it more
respectfully in the future, see:</p>

<ul>
<li><p><a href="https://github.com/rust-lang/rust/issues/21232">#21232: borrow-checker allows partial reinit of struct that has been moved away, but no use of it.</a></p></li>
<li><p><a href="https://github.com/rust-lang/rust/issues/54986">#54986: NLL: Reject partial init of uninitialized record (struct or tuple)</a></p></li>
<li><p><a href="https://github.com/rust-lang/rust/issues/54987">#54987: Goal: Accept partial initialization + use of records created via such</a></p></li>
<li><p><a href="https://github.com/rust-lang/rust/issues/60450">#60450: assign to part of possibly uninitialized variable is flagged as UB (but only in 2018 edition)</a></p></li>
</ul>


<a name="Conclusion..Related.Posts..and.Thanks"></a>
<h2>Conclusion, Related Posts, and Thanks</h2>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
I might update this post in the future if I encounter other
significant regressions that are calling out to be documented in this
manner. But for now I am hoping that this list will suffice to entertain you all.
</span>
That&rsquo;s all of the AST borrow-check regressions that I had the stomach to try to categorize
in this post.</p>

<p>If you are interested in learning more about the technology underpinning NLL,
and the process we used to develop it over the course of <a href="https://github.com/rust-lang/rust/issues/6393">six years</a>, I highly
recommend Niko&rsquo;s <a href="http://smallcultfollowing.com/babysteps/categories/#NLL">series</a> of posts on the subject.</p>

<p>And, as you might be able to tell, there is still more work to be done!
For example, the original plans for NLL included a goal known in the NLL RFC as
<a href="https://rust-lang.github.io/rfcs/2094-nll.html#problem-case-3-conditional-control-flow-across-functions">Problem Case #3</a>. We ended up scaling back our ambitions
in order to ensure that we could deploy a viable product with the 2018 edition;
but that just means there is opportunity to add support for this case, and many
more, in future versions of the Rust compiler.</p>

<p>Having said that, doing the exercise of writing this post has made me appreciate
what a long journey we have had with getting NLL out the door. There have been
so many subtle problems to resolve, and so many great volunteers who stepped
up to the plate to assist us.
I want to give shout-outs specifically to the members, both new and old, of the NLL working group (aka WG-NLL):
qmx, davidtwco, lqd, matthewjasper, spastorino, and blitzerr.
We <em>literally</em> could not have done this without your help.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Felix S. Klock II</span></span>

      








  


<time datetime="2019-06-26T12:54:29+02:00" pubdate data-updated="true"></time>
      


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://blog.pnkfx.org/blog/2019/06/26/breaking-news-non-lexical-lifetimes-arrives-for-everyone/" data-via="pnkfelix" data-counturl="http://blog.pnkfx.org/blog/2019/06/26/breaking-news-non-lexical-lifetimes-arrives-for-everyone/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2016/01/01/gc-and-rust-part-2-roots-of-the-problem/" title="Previous Post: GC and Rust Part 2: The Roots of the Problem">&laquo; GC and Rust Part 2: The Roots of the Problem</a>
      
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2019/06/26/breaking-news-non-lexical-lifetimes-arrives-for-everyone/">Breaking News: Non-Lexical Lifetimes arrives for everyone</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/01/gc-and-rust-part-2-roots-of-the-problem/">GC and Rust Part 2: The Roots of the Problem</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/19/signatures-and-surfaces-thoughts-on-privacy-versus-dependency/">Surfaces and Signatures: Component Privacy versus Dependence</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/18/fixing-octopress-table-rendering/">Fixing Octopress Table Rendering</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/27/cherrypicking-tuftes-of-hair/">Cherry-picking from the shoulders of giants</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/pnkfelix">@pnkfelix</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'pnkfelix',
            count: 4,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


<section>
  <h1>On Delicious</h1>
  <div id="delicious"></div>
  <script type="text/javascript" src="http://feeds.delicious.com/v2/json/pnkfelix?count=3&amp;sort=date&amp;callback=renderDeliciousLinks"></script>
  <p><a href="http://delicious.com/pnkfelix">My Delicious Bookmarks &raquo;</a></p>
</section>


<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/pnkfelix?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2019 - Felix S. Klock II -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'pnkfx-blog';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://blog.pnkfx.org/blog/2019/06/26/breaking-news-non-lexical-lifetimes-arrives-for-everyone/';
        var disqus_url = 'http://blog.pnkfx.org/blog/2019/06/26/breaking-news-non-lexical-lifetimes-arrives-for-everyone/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
