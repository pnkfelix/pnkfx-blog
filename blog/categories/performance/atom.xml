<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: performance | The {pnk}f(eli)x Blog]]></title>
  <link href="http://blog.pnkfx.org/blog/categories/performance/atom.xml" rel="self"/>
  <link href="http://blog.pnkfx.org/"/>
  <updated>2021-04-27T17:16:52-04:00</updated>
  <id>http://blog.pnkfx.org/</id>
  <author>
    <name><![CDATA[Felix S. Klock II]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Road to TurboWish; Part 2: Stories]]></title>
    <link href="http://blog.pnkfx.org/blog/2021/04/27/road-to-turbowish-part-2-stories/"/>
    <updated>2021-04-27T11:21:32-04:00</updated>
    <id>http://blog.pnkfx.org/blog/2021/04/27/road-to-turbowish-part-2-stories</id>
    <content type="html"><![CDATA[<p>It&rsquo;s story-time!</p>

<blockquote><p>As I walk, I think about a new way to walk</p></blockquote>

<p>In my <a href="/blog/2021/04/26/road-to-turbowish-part-1-goals/">previous post</a>, I described the observations that led us to select performance tooling as a focus, as well as the goals document I wrote to guide the next steps of the project. Now I want to show you the User Stories I wrote, to show what I think our customers want (and can reasonably expect) out of performance tools.</p>

<!-- more -->


<p>Everything that follows was taken verbatim<label for='&lsquo;tmbg&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;tmbg&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;Okay, </span> from the document I presented to the other members of the AWS Rust team. This document is an attempt to describe what I envisage as awesome developer experiences doing performance investigation. As with <a href="/blog/2021/04/26/road-to-turbowish-part-1-goals/">part 1</a>, I will be adding side-commentary on the right-hand margin.</p>

<blockquote><p>As I think, I&rsquo;m using up the time left to think</p></blockquote>

<p>My next post will present the design document that arose from these and other stories, as well as discussions about the realities of what we can expect to implement.</p>

<hr />

<p>Note: These are meant to be read in order: The first describes some up-front investment that the later stories either 1.) assume other developers already put in, or 2.) in the case of user “Barry”, state explicitly that such investment of effort is deliberately skipped by the developer.</p>

<blockquote><p>And this train keeps rolling off the track</p>

<p>Trying to act like something else</p>

<p>Trying to go where it&rsquo;s been uninvited</p></blockquote>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
I jumped right in and started making up a story about a newcomer to async Rust.
I did not actually look at examples of user stories as they are typically used in Agile development, or even really how it is done at AWS. It has been a long time since I had read essays describing &ldquo;how&rdquo; to do Agile development; looking at that now, I see that typical user stories are <em>one or two sentences</em>. (I&rsquo;m not sure I can properly convey what I want these tools to do in one or two sentences. I mean, it would be a place to start, but I wanted to spell out the experience. Maybe the reality is that the step I&rsquo;m doing is <em>not</em> a user story. But it <em>does</em> seem like it at least falls into the <a href="https://medium.com/the-digital-project-manager/working-backwards-a-new-version-of-amazons-press-release-approach-to-plan-customer-centric-c17991583508">&ldquo;Working Backwards&rdquo; style</a> that is promoted here at AWS. It also matches the <a href="https://rust-lang.github.io/wg-async-foundations/vision/how_to_vision/shiny_future.html">&ldquo;shiny future&rdquo; story writing</a> approach that Rust&rsquo;s Async Foundations working group has been trail-blazing (apart from the fact that I skipped the step of writing a description of the <a href="https://rust-lang.github.io/wg-async-foundations/vision/how_to_vision/status_quo.html">&ldquo;status quo&rdquo;</a> for each of the stories here).
</span></p>

<a name="User.Story.1:.Abigail"></a>
<h2>User Story 1: Abigail</h2>

<p>Abigail is getting started with async Rust development. She&rsquo;s worked her way through the Async Book and transcribed some example code. Now she&rsquo;s trying to write her first medium sized program, a terminal-based chess program, and it doesn&rsquo;t produce any output after she makes her first move and is waiting for the opponent to move.</p>

<p>After asking for advice about what to do on the Tokio Discord chat, she enables the turbowish feature in her Cargo.toml, and recompiles. She receives warnings from the compiler saying that there are calls to <code>task::spawn</code> but no contextual labels anywhere in her crate.</p>

<p>Abigail reads the compiler&rsquo;s suggestions for the kinds of declarations to add, and adds annotations accordingly, labeling her tasks. (Her program is roughly structured according to an actor model, so she has labels like &ldquo;game AI&rdquo;, &ldquo;move validator&rdquo;, and &ldquo;terminal UI&rdquo;).</p>

<p>Abigail reattempts a build, and now notices some of the previous warnings were not addressed in her change and are emited again: These warnings are about missing labels on resources, namely the channels used for communication between the tasks, e.g. &ldquo;user input&rdquo;, &ldquo;player move&rdquo;, &ldquo;opponent move&rdquo;, etc. She adds labels to the channels, and the program now compiles with no diagnostic warning. She runs her Chess program.</p>

<p>The Chess program starts up, and this time it includes, as part of its console output, a socket to connect to, which is serviced by a dedicated Turbowish thread. She runs a separate tokio-console program, connecting it to the advertised socket on the Chess program. Events begin streaming from the TurboWish thread to the <code>tokio-console</code>. The <code>tokio-console</code> output notes that it has a webserver mode available; she opts into that, and the <code>tokio-console</code> spits out a local URL to connect to. Abigail starts up a web browser and connects it to the URL. The rendered page lists the three tasks.</p>

<p>The Chess program again unexpectedly blocks (or, more precisely, livelocks) after she inputs her first move. Abigail looks at the rendered page, and notices a button that says &ldquo;task dependencies.&rdquo; She clicks it, and the page renders a picture showing a directed graph,<label for='&lsquo;directed-graph&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;directed-graph&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;This </span>
linking tasks and resources (or more generally, wakers), which depicts both 1.) what resources a task is waiting on, and 2.) what tasks are responsible for making those resources available for use.</p>

<p>The resulting rendering shows a cycle in the graph that looks like this, where circular nodes are tasks and rectangular nodes are resources shared by the tasks, like channels.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
I am breaking my rule about presenting the verbatim text here. In the document I shared with my colleagues, the underlying file didn&rsquo;t support mermaid or any other markdown-oriented diagramming tools. So there I resorted to something like
<code>(terminal UI)</code> <code>-&gt;</code> <code>[board update]</code> <code>-&gt;</code> <code>(move validator)</code> <code>-&gt;</code> <code>[player move]</code> <code>-&gt;</code> <code>(terminal UI)</code>
in that document, where parentheses and square brackets represent circle vs square node shapes, differentiating tasks from resources.
But I could not bring myself to subject my readers here to that, when its so easy to put in a mermaid diagram.
</span></p>

<!-- The manual height specification is a rough guess, to allow the rest of the doc to predict the space occupied by the graph once it is rendered. -->


<div class="mermaid" style="height: 300px">
graph LR
  AI(("game AI"))
  TUI --> Update --> Validator --> Player --> TUI
  TUI(("terminal UI"))
  Update["board update"]
  Validator(("move validator"))
  Player["player move"]
</div>


<p>Notably, there are no paths in the rendered graph from [board&nbsp;move]<label for='&lsquo;board-move-typo&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;board-move-typo&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;I </span>
to (game&nbsp;AI).</p>

<p>Abigail wonders why the move validator task is waiting for a player move, when she would expect it to be waiting an opponent move from the AI.</p>

<p>She realizes there must be a error in her logic for how either the &ldquo;move&nbsp;validator&rdquo; or the &ldquo;board&nbsp;update&rdquo; are set up, since she would expect the &ldquo;game&nbsp;AI&rdquo; task to be somewhere in the path above.</p>

<p>Moving her mouse over the graph, she notices that the graph edges link to points in her source code. She starts digging in, using the provided links as direction for where to look to figure out what went wrong in her logic.</p>

<blockquote><p>And the rain falls down without my help I&rsquo;m afraid</p></blockquote>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
When I wrote these stories, I felt it would be useful for all of the characters to have names where their first letters corresponded to the letters of the Alphabet: Abigail, Barry, Chris, Daphne. Some feedback I got back almost immediately from Niko Matsakis was &ldquo;Why didn&rsquo;t you re-use the <a href="https://nikomatsakis.github.io/wg-async-foundations/vision/characters.html">characters from the Async Vision cast</a>?&rdquo; I don&rsquo;t have any great answers to that. (The obvious answer was a sheepish &ldquo;I haven&rsquo;t read the Async Vision document yet&hellip;&rdquo;; I have corrected that oversight since then.)
</span></p>

<a name="User.Story.2:.Barry"></a>
<h2>User Story 2: Barry</h2>

<p>Barry is an experienced tokio developer. He has been asked to help out with an AWS cloud service using tokio. The developers of the service are seeing higher latencies than expected for relatively small service requests.</p>

<p>Barry enables tokio&rsquo;s turbowish feature. He opts not to take the compiler&rsquo;s diagnostic suggestions regarding missing contextual labels and downgrades the diagnostic to <code>#![allow]</code> across the crate, knowing that TurboWish will infer labels and attach them automatically based upon crate and module names (and a fixed number of stack frames, when debuginfo is available).</p>

<p>Barry connects <code>tokio-console</code> to the cloud service&rsquo;s socket, and chooses its terminal user-interface instead of the webserver mode.</p>

<p>Barry first asks for a live feed of tasks transition between (<code>running</code>, <code>waiting</code>, <code>ready</code>). The feed produces too much output to the terminal, so Barry sends it to a file instead, and then inspects it in a text editor, trying to see trends by eye. It is a lot of data though, too much for Barry to interpret without more tooling.</p>

<p>Barry has dealt with parsing this output before, though.</p>

<p>Barry has a home-grown script to extract a CSV file with numeric data from the output. Barry imports the CSV file into a spreadsheet and then constructs a histogram with buckets of ranges of individual wait-times, and how many tasks’ transition points are in each bucket.</p>

<p>From this, Barry identifies a small set of tasks that spent an unusually long time in the <code>waiting</code> state. Going back to the original feed, Barry finds the the records for those long waits, which include a link to the point in the source code where the long waits occurred.</p>

<p>Barry looks, and sees a call to <code>std::thread::sleep</code> instead of tokio&rsquo;s sleep function. [TODO: I&rsquo;d be happy to put in some other
example here of blocking code that should be replaced with non-blocking code.]<label for='&lsquo;todo-other-examples&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;todo-other-examples&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;This </span></p>

<p>Barry replaces the call <code>std::thread::sleep</code> with tokio&rsquo;s sleep function, and returns to the histogram to see what other instances of unusually long wait times he can find.</p>

<blockquote><p>And my lawn gets wet though I&rsquo;ve withheld my consent</p></blockquote>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
With the Chris story, we have a sudden shift from async-oriented performance issues to compiler developer performance issues. what can I say other than <a href="https://thewritepractice.com/write-what-you-know/">&ldquo;write what you know&rdquo;</a>.
</span>
<label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
(Interestingly, all the essays I can find on that <a href="https://tvtropes.org/pmwiki/pmwiki.php/Main/WriteWhatYouKnow">trope</a> indicate that it is meant to be about knowledge of <em>inner emotions</em>, not about facts or experience.)
</span></p>

<a name="User.Story.3:.Chris"></a>
<h2>User Story 3: Chris</h2>

<p>Chris is a contributor to the Rust compiler, <code>rustc</code>. Chris is well-versed with Rust, at least for batch programs like the compiler, but they do not do any async Rust development. Chris wants to gain better understanding of memory usage internal to <code>rustc</code> itself.</p>

<p>After asking around in the <code>#compiler-team</code> Zulip stream, Chris enables the <code>build.heap_inspector</code> setting in <code>rustc</code>&rsquo;s build
configuration file, and rebuilds the compiler.</p>

<p>Chris also fires up the TurboWish web frontend. This invocation of TurboWish uses a specialized config file developed and maintained by the Rust compiler team that handles interpreting the types that are special to the compiler.</p>

<p>Chris uses environment variables to indicate which points in the compiler&rsquo;s control flow are of interest to them. More specifically, Chris wants to inspect the heap as it stands immediately after the borrow-checker runs.</p>

<p>The compiler obliges: right after the borrow-checker runs, it starts from a set of known roots (tagged as such ahead of time by the rustc developer) and traverses the ownership graph from those roots,<label for='&lsquo;gc&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;gc&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;You </span> emitting a description of the arcs it encounters during its traversal. For each heap-allocated value the traversal encounters, the traversal code also
includes information needed to reconstruct its &ldquo;payload size&rdquo;; i.e., enum values will include their discriminant, vectors and string include their length, etc.</p>

<p>The TurboWish web front end receives this stream of graph traversal data. It uses this to provide a table describing the number of objects of each type, and how much internal fragmentation it detects based on the reported payload sizes. Chris inspects this table and determines that that there is an opportunity to reduce fragmentation by changing one of the enums to use a <code>Box</code>. Chris tries it out and sees the memory consumption of the compiler go down, and files a pull request
with the change.</p>

<p>(Note: This user story may or may not not provide value over other tools like dhat, depending on 1. whether it allows tracking allocations at a finer grain than malloc calls (e.g. sub-allocations within an arena) and/or 2. how much value one puts on being able to inspect portions of the heap rooted at certain owners. See also <a href="#Appendix">the appendix</a>, which includes a more ambitious “dream” proposal for Chris, but also one that I personally am not as sure actually pays off in terms of customer value versus mere “coolness” factor.)</p>

<blockquote><p>When this grey world crumbles like a cake</p></blockquote>

<a name="User.Story.4:.Daphne"></a>
<h2>User Story 4: Daphne</h2>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
With Daphne&rsquo;s story, we return to async-oriented performance analysis.
Async is a hot topic, and I figured it was worth exploring other stuff we could deliver. In this case, the idea is to turn the internal logging data into a rendered message sequence chart. (I actually do not know if people use message sequence charts on real logs in practice. I have seen them used <em>very</em> often for presenting small snippets that explain a protocol, but are they actually useful for traversing a complex series of interactions? I can imagine it could be, especially in an interactive presentation that can highlight links and automatically re-center on a selected end of a given arc in a graph.
</span>
Daphne is maintaining an existing a web service built atop tokio. She gets reports of poor performance for certain input queries that match the &ldquo;E&rdquo; command for her service, which already has TurboWish integrated. In response, she attaches <code>tokio-console</code> to her service, and tells it to trace the flow of requests matching the &ldquo;E&rdquo; command (more concretely, <code>[{req.path="/Q"}]=trace</code>), and then fires up the TurboWish web front-end.</p>

<p>Daphne chooses a tab that says &ldquo;Show Scheduler.&rdquo; The resulting page looks something like Message Sequence Chart: Each of tokio&rsquo;s executor threads has a vertical line, and as futures are polled, they have corresponding boxes on the corresponding thread. Since Daphne has limited the output to just events related to the &ldquo;E&rdquo; command, all the futures she sees being scheduled are part of that query.</p>

<p>From skimming the resulting charts, Daphne sees that when the &ldquo;E&rdquo; futures are being polled, they seem to yield again promptly. She does see some evidence the future is migrating to different threads, and she makes a note to try to investigate whether there is a way to ask tokio to avoid such thrashing (and also, whether there are metrics should could gather about whether doing so could help).</p>

<p>There are also points in the program flow when <em>no</em> future related to the &ldquo;E&rdquo; query is scheduled. The event stream does not include information about which futures are polled during those times. Those portions of the executor threads vertical lines are colored dark green: they may be doing useful work, but its not work directly related to the events that have been filtered in.</p>

<p>Daphne realizes that she needs to find out whether the &ldquo;E&rdquo; futures are being left unexecuted because they&rsquo;re still waiting for their corresponding wakers to be invoked, or if the &ldquo;E&rdquo; futures are all ready and there is some other issue in the scheduler (or in the other tasks that causes them to starve the executing threads). Daphne goes to <code>tokio-console</code> and issues the command requesting the feed of all tasks transitioning between (<code>running</code>, <code>waiting</code>, <code>ready</code>). With that, the message sequence chart now shows that her &ldquo;E&rdquo; futures are indeed ready much of the time. She also sees that there are large blocks of time where all of the threads in the pool are running without any interrupt. Daphne hovers the mouse over those rendered blocks of time,  and a pop-up window shows a description of the futures that are being polled at that time. Daphne goes off to investigate that piece of code, and discovers a <code>for</code>-loop with some semi-expensive body that never yields to the executor.</p>

<a name="Appendix"></a>
<h1>Appendix</h1>

<blockquote><p>I&rsquo;ll be hanging from the hope</p>

<p>That I&rsquo;ll never see that recipe again</p></blockquote>

<a name="User.Story.3b:.Chris.s.Dream"></a>
<h2>User Story 3b: Chris&rsquo;s Dream</h2>

<p>Chris wants to inspect the heap as it stands immediately after the borrow-checker runs.</p>

<p>The compiler obliges: right after the borrow-checker runs, it pauses and prompts for the user to connect TurboWish. Chris connects the <code>rustc-console</code> app and interactively asks what root objects are available to inspect. One of the named objects in the result is the &ldquo;MirBorrowckCtxt&rdquo; (i.e. the borrow-checking context). Still working at the terminal <code>rustc-console</code>, Chris first asks for how much memory is solely owned, potentially indirectly by the &ldquo;MirBorrowckCtxt&rdquo; object. <code>rustc-console</code> spits out a number. Chris then asks for how much memory is owned, potentially shared with others (e.g. via <code>Rc</code>), by the object. <code>rustc-console</code> spits out another, much larger number.</p>

<p>Chris connects the TurboWish web front-end, and then queries for a ownership tree describing the values owned by the &ldquo;MirBorrowckCtxt&rdquo; object.</p>

<p>TurboWish does a graph traversal over the owned heap allocated objects, starting from the borrow-checking context (<code>MirBorrowckCtxt</code>) as the root, and emits a description of the arcs it encounters during its traversal, as well as well as the data payload for any fields of types that have been previously marked by the rustc developers as of interest.</p>

<p>The TurboWish web front end renders the resulting graph. But in addition to the direct ownership relatinships implied by the Rust language semantics the graph, it also includes arcs for any <code>&amp;</code>/<code>&amp;mut</code> references in the graph, and it <em>also</em> includes some domain-specific dotted arcs for keys into tables that are meant to be interpreted as references. (This of course is only possible due to the rustc-specialized config file that was included when TurboWish was loaded up.)</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
I think this whole appendix was just an excuse to try to squeeze in a reference to Hyperbolic Trees. Just over twenty years ago, I spent a summer (or was it a year) hacking together code to render a graph via such trees as part of a project called <a href="http://alumni.media.mit.edu/~wex/CHI-99-Footprints.html">Footprints</a>; the linked paper still has screenshots of it.
</span></p>

<p>However, since the object graph is massive, the rendering does not fit on the window. Chris first toggles an option to change the rendering to use a hyperbolic tree (see <a href="https://en.wikipedia.org/wiki/Hyperbolic_tree">https://en.wikipedia.org/wiki/Hyperbolic_tree</a>), where the current object is presented centrally, and immediate children are surrounding smaller nodes, and grand-children are still smaller, et cetera. The hyperbolic tree presentation compacts the view significantly, at the cost of obscuring details of distant descendants and ancestors, as well as cousins.</p>

<p>There is also an option on the presentation UI to have the circles for each node be different sizes depending on how much space they individually occupy on the heap (not including their linked children); Chris enables this setting, just to get a rough visual feeling for where memory space is going in the ownership tree.</p>

<hr />

<p>And that&rsquo;s all the user stories. That&rsquo;s the whole document.</p>

<p>For the sequel, I will be presenting the design document that I think best represents the plan going forward.</p>

<p>We are still figuring things out, to some extent, but I continue to dream about what we can do for our customers, the Rust developers of the world.</p>

<blockquote><p>When the word comes down &ldquo;Never more will be around&rdquo;</p>

<p>Thought I&rsquo;ll wish we were there, I was less than we could bear</p>

<p>And I&rsquo;m not the only dust my mother raised</p>

<p>I am not the only dust my mother raised</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Road to TurboWish; Part 1: Goals]]></title>
    <link href="http://blog.pnkfx.org/blog/2021/04/26/road-to-turbowish-part-1-goals/"/>
    <updated>2021-04-26T12:51:35-04:00</updated>
    <id>http://blog.pnkfx.org/blog/2021/04/26/road-to-turbowish-part-1-goals</id>
    <content type="html"><![CDATA[<p>This is a post about some recent history. I want to tell the world about a project I am leading at Amazon Web Services, called &ldquo;TurboWish.&rdquo;</p>

<p>TurboWish, in a nutshell, is our umbrella term for a planned suite of tools for understanding your Rust program&rsquo;s dynamic behavior. We want the tools to especially focus on providing insights into the <em>performance</em> characteristics of your program.</p>

<!-- more -->


<p>Let me take a moment to tell you what has happened so far: How did I get here?</p>

<p>(if you want skip the history/motivations and jump <a href="#doc:.Opening.Line">straight to the doc</a>, you can follow that link; you may find yourself
in another part of the world.)</p>

<a name="Into.the.blue.again"></a>
<h2>Into the blue again</h2>

<p>About six months ago, I left Mozilla and joined Amazon Web Services (AWS). I am now part of a new team: the AWS Rust team.</p>

<p>Our team charter is simple: &ldquo;The AWS Rust team works to make Rust performant, reliable, and productive for all its users.&rdquo;</p>

<p>Details of what that means are spelled out via <a href="https://aws.amazon.com/blogs/opensource/how-our-aws-rust-team-will-contribute-to-rusts-future-successes/">our team&rsquo;s tenets</a>.
One of those tenets, one that is incredibly important to me, is that &ldquo;we work in the open.&rdquo; This blog post is itself my own attempt to follow through on that promise: I want to be more open about what I&rsquo;ve been writing down and circulating amongst a relatively small group of people, and try to be better about putting my draft ideas out into the open from the start going forward.</p>

<a name="Same.as.it.ever.was"></a>
<h2>Same as it ever was</h2>

<p>From my perspective, I still have the same personal career goals: make the Rust programming language an awesome option for developers, by improving the code of the Rust compiler, the design of the Rust language, and the organization of the Rust community.<label for='&lsquo;not-improve-community&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;not-improve-community&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;Our </span></p>

<p>Those were my goals when I was at Mozilla, and they are still my goals now.</p>

<a name="You.may.ask.yourself"></a>
<h2>You may ask yourself</h2>

<p>What do performance tools have to do with those goals?</p>

<p>Our team&rsquo;s inspiration for this focus was based on a few observations.</p>

<p>Part of Rust&rsquo;s promise, the reason people are trying Rust out at all, is that it says it can give you the kind of high-performance that in the past was normally the realm of low-level languages like C or C++.<label for='&lsquo;or-fortran&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;or-fortran&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;Or </span></p>

<p>At a customer-obsessed company like Amazon, that promise raises an important question.
Are our team&rsquo;s customers,<label for='&lsquo;on-customer-term&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;on-customer-term&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;Some </span>
the developers using Rust, actually seeing such performance wins in practice?</p>

<a name="There.is.water.at.the.bottom.of.the.ocean"></a>
<h2>There is water at the bottom of the ocean</h2>

<p>Based on some discussions and informal interviews with fellow Rust developers, I saw three groups of people with differing answers to that question.</p>

<p>The first group says &ldquo;Rust is great! Once I got it compiling and my unit tests passing, the code works and meets my performance expectations.&rdquo; These customers always made me happy; they are usually happy to then point out what pet features they want to see in the future.</p>

<p>The second group says: &ldquo;I got it compiling, but its not actually as fast as I had hoped. <strong>What should I do now?</strong>&rdquo;</p>

<p>Okay, to be fair, I&rsquo;m making a massive over-generalization there. The second group doesn&rsquo;t always say that. Some of them do <a href="https://blog.mozilla.org/nnethercote/2019/10/11/how-to-speed-up-the-rust-compiler-some-more-in-2019/">extensive analysis</a> to identify awesome ways to make things faster. Some also document exactly what they did and <a href="http://likebike.com/posts/How_To_Write_Fast_Rust_Code.html">how you can do it too</a>.</p>

<p>But the point remains: If Rust <em>isn&rsquo;t</em> meeting your performance goals, its not always obvious what to do. Some people with a lot of in-depth experience with compilers or systems analysis have tools in their utility belt that work well for C/C++ and &hellip; they sort of work for Rust.</p>

<p>But those tools do not work as well as I would like, and I&rsquo;m not sure they are the right answer for the bulk of our community.
I said five years ago that I want Rust to be <a href="https://www.infoq.com/presentations/rust/">Systems Programming for Everybody</a>, and part of that story is that we need tools that everybody can use and understand.</p>

<a name="How.do.I.work.this."></a>
<h2>How do I work this?</h2>

<p>The third group says: &ldquo;I struggle to figure out what design to use. I struggle to get my service compiling. You are asking me what I think about performance, but  I&rsquo;m debugging deadlocks from my <code>async</code> code.&rdquo;</p>

<p>This third group raises an entirely different line of thinking when it comes to tooling. When I first starting thinking about performance monitoring tools, I was thinking solely in terms of gathering and presenting metrics, such as CPU cycles, memory utilization. But this third group represents a broad set of customers for whom such focus is premature: They are hitting road blocks that prevent their project from ever leaving the prototype phase. One big source of problems was <code>async</code> code; there&rsquo;s a good chance that <code>async</code>-specific tooling will provide the biggest return on investment here.</p>

<p>The concerns of the second and third groups what led us to the TurboWish project: tools that will help our customers make Rust deliver on its promises: <a href="https://www.rust-lang.org/">performant, reliable, productive</a>.</p>

<a name="Letting.the.days.go.by"></a>
<h2>Letting the days go by</h2>

<p>After performing a set of informal interviews with various customers both within and outside of AWS, I felt confident that there <strong>are</strong> real problems here to solve. We want Rust developers to have good tools<label for='&lsquo;lang-feats&rsquo;' class='margin-toggle'> &#8853;</label><input type='checkbox' id='&lsquo;lang-feats&rsquo;' class='margin-toggle'/><span class='marginnote'>&lsquo;Ideally, </span>
on hand that will answer their questions.</p>

<p>So, I jumped into writing a goals document, so that our team could explain to other teams at AWS, and ourselves, what we want to make. I shared it with the rest of the AWS Rust team in the middle of February 2021; they had lots of feedback, but I am not including that here (mostly to avoid having to coordinate authorship of this blog post).</p>

<p>I am ending this blog post with that goals document, warts and all, along with meta-commentary in the right-hand margin notes.
In follow-on blog posts this week, I will share some of the next steps that followed after I wrote this.</p>

<a name="doc:.Opening.Line"></a>
<h3>doc: Opening Line</h3>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
You can see in the opening line itself the focus on <code>async</code>/<code>await</code>, for better or for worse.
</span>
TurboWish is a framework for profiling Rust programs, focused on illuminating the performance and resource usage of task-oriented code written with async/await.</p>

<a name="doc:.Goals"></a>
<h3>doc: Goals</h3>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
I played a bit of a semantic shell game here, with my use of the term &ldquo;production code.&rdquo; That term could be interpreted as &ldquo;code deployed as a live service.&rdquo; Or it could be interpreted as &ldquo;code compiled in release mode, but still running on development boxes.&rdquo; I plan to talk more about this distinction in later posts, but the short version is: I think we can provide great value today to developers working on their development boxes, without trying to concern ourselves with making a tool that is sufficiently low-overhead and security risk-free that it could be part of a deployed system.
</span>
<em>Profile Production Code</em>: Incorporating the TurboWish Framework is low-overhead: it can be incorporated into production code without producing an undue maintenance burden and without incurring significant performance overhead.</p>

<p><em>Domain-specific Feedback</em>: Frameworks and applications can provide data for specialized metrics, specific to their internal architecture.</p>

<p><em>Understand Hidden Costs and Connections</em>: Frameworks like tokio ease writing asynchronous code because they hide a number of details behind abstractions (such as generator code produced by the Rust compiler, or task queues managed by the tokio runtime). TurboWish exposes those hidden details, allowing developers to correlate them with other program events. It also exposes connections that humans usually have to reconstruct by hand (such as future to resource to future chains that can yield deadlock), allowing one to directly see from Rust’s ownership model how resources are being held in the object graph.</p>

<p><em>Framework Agnostic</em>: Many of Rust’s customers use tokio, but not all of them. async-std  and fuschia_async are other frameworks for asynchronous programming. TurboWish can provide value to any such framework (though it may also provide framework-specific functionality when warranted). For our initial releases, we can focus on tokio alone, but expect integration with others if tokio proves successful.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
I included this goal specifically because I had done a bunch of investigation into using <a href="https://rr-project.org/"><code>rr</code></a>, and discovered during that time that some of the cloud development machines hosted on <a href="https://aws.amazon.com/ec2/">EC2</a> do not support the performance counters that you need for <code>rr</code> to function.
</span>
<em>EC2 Instance Type Agnostic</em>: If we make use of any OS specific features (e.g. dtrace probes), they will be available on all EC2 AL2 instances, regardless of instance-type. (Specifically, we cannot require access to CPU performance counters.)</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
It was an interesting exercise writing this schedule. There are a number of constraints that I was trying to meet that are not represented in this table.
The biggest one was that the Rust release schedule itself follows a six-week cadence; if TurboWish needs any support from <code>rustc</code> itself, and we want it to be available in the stable version of the compiler at the end of October, then that means any such support needs to land in the nightly version of <code>rustc</code> before July 29th.
</span></p>

<a name="doc:.Milestones"></a>
<h3>doc: Milestones</h3>

<table>
<thead>
<tr>
<th>Milestone</th>
<th>Deadline</th>
</tr>
</thead>
<tbody>
<tr>
<td>3 to 5 User Stories identified for core focus</td>
<td>26 Feb 2021</td>
</tr>
<tr>
<td>Development Tracks identified</td>
<td>26 Mar 2021</td>
</tr>
<tr>
<td>PR/FAQ published</td>
<td>2 Apr 2021</td>
</tr>
<tr>
<td>3 Launch Partners established</td>
<td>30 Apr 2021</td>
</tr>
<tr>
<td>alpha prototype</td>
<td>2 Jul 2021</td>
</tr>
<tr>
<td>feedback gathered from demo of alpha to Launch Partners</td>
<td>16 Jul 2021</td>
</tr>
<tr>
<td>beta release</td>
<td>20 Aug 2021</td>
</tr>
<tr>
<td>beta integrated with Launch Partner code bases</td>
<td>17 Sep 2021</td>
</tr>
<tr>
<td>Evaluation Report of beta (interviews with Launch Partners)</td>
<td>24 Sep 2021</td>
</tr>
<tr>
<td>1.0 release</td>
<td>29 Oct 2021</td>
</tr>
</tbody>
</table>


<a name="doc:.Milestone.explanation"></a>
<h3>doc: Milestone explanation</h3>

<p><em>Development Tracks</em>: Some features of TurboWish will provide the most value to customers if they are developed in concert with additions to other components of the Rust ecosystem, such as the Rust compiler. However, we are not the sole owners of the Rust ecosystem nor those components. We need to identify target components of interest early (and I am assuming that part of that identification will require actual prototyping, which is why I am allocating a month for such prototyping in parallel with drafting the PR/FAQ<label for='&lsquo;pr-faq&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;pr-faq&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;I </span>), so that we can properly prioritize such development. In each case where we do not own the component, we must also establish the backup plan if our desired changes will not land in time for use in the product this year.</p>

<p><em>Launch Partners</em>: Customers within Amazon are willing to evaluate pre-release versions of the product. We should strategically select three such customers to partner with us; these are the Launch Partners. We will give each such launch partner 1.) demonstrations of the alpha proof of concept, 2.) access to the beta minimum viable product, and 3.) dedicated engineering time for integrating the beta into their service. In exchange, the launch partner will give us feedback on the alpha and beta versions of the product (which will inform each subsequent development sprint).</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
For some reason I was especially proud of the distinction being drawn in this paragraph. I have a somewhat superficial understanding of project management and Agile development methods, so I was not really thinking about whether demo&rsquo;s are common products of a sprint. (And a <a href="https://www.jrothman.com/mpd/2007/10/release-able-vs-demo-able/">post by Johanna Rothman</a> makes the great point that even a product that is &ldquo;only&rdquo; demo-able has still demonstrated <em>integration amongst the team</em>.)
From my perspective, the demo/release distinction had an entirely different motivation: I simply did not see time in the schedule for the year for two full release plus integration plus customer-feedback cycles.
</span>
<em>Alpha Demo</em> versus <em>Beta Release</em>: We want to move quickly, develop a minimum viable product and then iterate on it until we have something that delights our customers. We also want to work with a set of dedicated launch partners to evaluate an early version of the product (the beta). However, a product like this is unlikely to be a tool that can be trivially integrated: we expect there to be some amount of development effort associated with linking TurboWish into a given code base. Therefore, we do not expect our launch partners to be able to participate in multiple iterations of evaluating the product, simply due to the amount of development effort each integration is likely to take. So, we propose using different evaluation methodologies for different iteration cycles: For the alpha version, we will integrate TurboWish into code bases that we choose ourselves, give demos of the integrated result to our Launch Partners, and use their feedback in subsequent development of the alpha. For the beta version, we will work with our Launch Partners to integrate TurboWish into their code bases, and then at the end of the integration period, we will use the feedback they provide to make the final changes to the product.</p>

<a name="doc:.Risks..Mitigations"></a>
<h3>doc: Risks, Mitigations</h3>

<blockquote><p>Risk: Time from “development tracks identified” to “PR/FAQ published” is only a week.<label for='&lsquo;dev-track-to-pr-faq&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;dev-track-to-pr-faq&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;This </span></p></blockquote>

<p>Mitigation: We need to develop the PR/FAQ in parallel with doing the feasibility studies that identify the development tracks. (But I do not want to make them independent milestones; I want to be confident that the features in the PR/FAQ can be constructed before I try to enlist Launch Partners.)</p>

<blockquote><p>Risk: Rust compiler leadership/maintenance will distract pnkfelix.<label for='&lsquo;compiler-work&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;compiler-work&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;Another </span></p></blockquote>

<p>Mitigation 1. Get buy-in from others and spread development effort</p>

<p>Mitigation 2. Compiler Team focus for 2021 is rustc contributor experience, especially w.r.t. performance. Hopefully synergies will emerge from that.</p>

<blockquote><p>Risk: Not much time remaining in February to establish user stories. Felix’s personal focus for short term are memory usage issues, and so he has been contributing stories related to that. But many customers express concern related to async/await, especially about understanding why their tasks fail to progress (i.e. sources of deadlock).</p></blockquote>

<p><em>(No mitigation documented.)</em><label for='&lsquo;no-mitigation&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;no-mitigation&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;I </span></p>

<blockquote><p>Risk: Some features may depend on some amount of GC style tracing, potentially starting from local owned variables on the stack as roots, and in any case traversing values on the heap. (For example, automatically dissecting ownership chains between futures and resources in order to identify causes of deadlock could make use of such tracing.) pnkFelix has experience in this area and believes it to be a solvable problem (especially given the profiling goal, as opposed to correct integration with arbitrary 3rd party GC tech), but it is not a settled problem.</p></blockquote>

<p>Mitigation: Leverage ownership of relevant frameworks where possible. E.g. you don’t need to trace the local stack if you know your “root set” of interest is the set of tokio tasks. And you don’t need to make an general-purpose value-tracing system when a make-shift trait and associated derive will suffice for the specific problem at hand.</p>

<a name="Time.isn.t.holding.us...Time.isn.t.after.us"></a>
<h2>Time isn&rsquo;t holding us / Time isn&rsquo;t after us</h2>

<p>And that&rsquo;s the goals doc, as it stood in mid-February</p>

<p>Like I said above, there was a bit of a journey to get to this point. And even with this document in hand, we do not have enough to start making code: I wouldn&rsquo;t be able to hand this to a programmer and say &ldquo;do this.&rdquo;</p>

<p>But I had goals. And I had a schedule. What was next on the schedule? <em>User Stories.</em> (Those will be the subject of the next blog post.)</p>
]]></content>
  </entry>
  
</feed>
