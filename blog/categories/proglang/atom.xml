<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: proglang | The {pnk}f(eli)x Blog]]></title>
  <link href="http://blog.pnkfx.org/blog/categories/proglang/atom.xml" rel="self"/>
  <link href="http://blog.pnkfx.org/"/>
  <updated>2015-10-12T15:54:55+02:00</updated>
  <id>http://blog.pnkfx.org/</id>
  <author>
    <name><![CDATA[Felix S. Klock II]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[An insight regarding DST grammar for Rust]]></title>
    <link href="http://blog.pnkfx.org/blog/2014/03/13/an-insight-regarding-dst-grammar-for-rust/"/>
    <updated>2014-03-13T07:04:00+01:00</updated>
    <id>http://blog.pnkfx.org/blog/2014/03/13/an-insight-regarding-dst-grammar-for-rust</id>
    <content type="html"><![CDATA[<p>Executive summary: <code>type</code> = <code>unsized</code> ⊎ <code>sized</code>, so we should use
<code>type</code> as our generalization marker, not <code>unsized</code>.</p>

<ul>
<li><a href="#background_dst">Background: Dynamically Sized Types (DST)</a></li>
<li><a href="#the_insight">The Insight: <code>type</code> is a better generalization marker</a></li>
<li><a href="#the_examples">Examples ported from DST, Take 5</a></li>
</ul>

<h2 id="toc_0"><a id="background_dst">Background: Dynamically Sized Types (DST)</a></h2>

<p>The Rust team has been discussing incorporating &quot;dynamically-sized
types&quot; into the static semantics for Rust.  Essentially the idea is to
allow code to describe and name static types whose size is only known
at Runtime.  E.g. the integer vector <code>[int, ..5]</code> is known at compile
time to have five elements, and is considered (statically) sized,
while the vector <code>[int]</code> has unknown size at compile time, and so that
type is called unsized.</p>

<p><a href="http://smallcultfollowing.com/babysteps/blog/2013/04/30/dynamically-sized-types/">There</a>
is <a href="http://smallcultfollowing.com/babysteps/blog/2013/06/06/reducing-dst-annotation/">a</a>
series <a href="http://smallcultfollowing.com/babysteps/blog/2013/11/26/thoughts-on-dst-1/">of</a>
blog <a href="http://smallcultfollowing.com/babysteps/blog/2013/11/27/thoughts-on-dst-2">posts</a>
about <a href="http://smallcultfollowing.com/babysteps/blog/2013/11/27/thoughts-on-dst-3/">dynamically</a>
sized <a href="http://smallcultfollowing.com/babysteps/blog/2013/12/02/thoughts-on-dst-4/">types</a>
on <a href="http://smallcultfollowing.com/babysteps/blog/2014/01/05/dst-take-5/">niko&#39;s</a>
blog.
So I will not dive into the details too much here</p>

<p>The main points are that the compiler wants to know whether a type is
meant to always have a static size, or if it can potentially be
unsized.  In a language without type polymorphism, this might be easy
to determine directly from the parsed type expression (such as in the
vector examples I gave at the outset).  But once you add polymorphism,
things get a litle harder for the compiler.</p>

<p>Anyway, the plan drafted in Niko&#39;s
<a href="http://smallcultfollowing.com/babysteps/blog/2014/01/05/dst-take-5/">&quot;DST, Take 5&quot;</a>
is to add an <code>unsized</code> keyword, and then use it as a marker to make
certain spots more general than they are by default.  The reasoning
here is that in the common case, you want a type parameter to
represent a sized type.  (Since there are certain operations you
cannot do with a value of an unsized type, such copying the value into
some other location, the compiler needs to know its size statically so
that it can allocate an appopriate amount of space for it.)</p>

<p>So under that scheme, to write type parameter of most general type,
e.g. for a <code>struct</code> definition that ends with an unsized field,
you need to write:
```rust
struct Named<unsized T> {
    name: ~str,
    payload: T
}</p>

<p>// Accepts solely <em>sized</em> Named<T>.
fn foo<T>(&amp;Named<T>) { ... }</p>

<p>// Accepts both sized and <em>unsized</em> Named<T>
fn bar<unsized T>(&amp;Named<T>) { ... }
```</p>

<p>That is, you need to use what I will call a &quot;generalization&quot; marker at
the spot where you bind a type variable, to indicate that the domain of
that type variable is more general than the common-case default of 
a sized type.</p>

<p>For defining a trait that can be implemented on any possible type,
including unsized ones, you would need to use the <code>unsized</code> keyword
somewhere there as well.  &quot;DST, Take 5&quot; proposed
<code>trait Foo&lt;unsized Self&gt; : NormalBounds { ... }</code>
(or <code>trait Foo : unsized + NormalBounds { ... }</code>, but this is broken for
various reasons).
I had been suggesting <code>unsized trait Foo : NormalBounds { ... }</code>,
which Niko rightly objected to (since it is not the trait that is
unsized, but rather potentially its Self type).
Over the Rust work week last week I suggested
<code>trait Foo for unsized : NormalBounds</code> { ... }, which I think is the first
suggestion that Niko and myself could both stomach.  (The reasoning
behind the latter suggestion is that we write <code>impl Trait for
SelfType</code>, so it makes sense to put the generalization marker into the
same position, i.e. filling the placeholder in: <code>Trait for _</code>.)</p>

<h2 id="toc_1"><a id="the_insight">The Insight: <code>type</code> is a better generalization marker</a></h2>

<p>One of the concerns that Niko has pointed out to me is that it is easy
to (mis)read <code>unsized T</code> as saying &quot;<code>T</code> must be unsized&quot;.  But that is not
what it is saying; it is saying &quot;<code>T</code> <em>can</em> be unsized&quot;; you can still pass in
a sized type for <code>T</code>.</p>

<p>I was reflecting on that this morning, and I realized something:
The whole point of DST is to partition the type universe into (Sized ⊎ Unsized).
So if you want this construct to be more self-documenting, the
generalization marker should be using some name to describe that union
(Sized ⊎ Unsized), rather than the name <code>unsized</code>.</p>

<p>But we already have a very appropriate name for that union: <code>type</code>!</p>

<p>So that started me thinking: Why don&#39;t we use <code>type</code> as our generalization marker?
So the definition of <code>bar</code> in the example above would be written
<code>rust
fn bar&lt;type T&gt;(&amp;Named&lt;T&gt;) { ... }
</code>
In fact, this can have a very simple explanation: If we keep the <code>Sized</code> trait bound,
then you can just say that
<code>rust
fn foo&lt;T&gt;(args, ...){ ... }
</code>
desugars to
<code>rust
fn foo&lt;type T:Sized&gt;(args, ...) { ... }
</code>
and in general, any type variable formal binding <code>&lt;T:Bounds&gt;</code> desugars
to <code>&lt;type T:Sized+Bounds&gt;</code></p>

<p>I admit, when I first wrote this, I said &quot;hmm, this looks a bit like
C++, is that a problem?&quot;  But I&#39;m coming to like it.  The biggest
problem I can foresee is that a developer might be confused about when
they are suppposed to write <code>foo&lt;type T&gt;</code> versus <code>foo&lt;T&gt;</code>.  But chances
are that someone who does not understand the distinction will <em>not</em>
suffer if they just guess the answer; if they over-generalize, either:</p>

<ul>
<li><p>the code will compile successfully anyway, in which case there is
no harm, except perhaps w.r.t. forward-compatibility of their
library when they may have wished they had imposed the <code>Sized</code>
bound, or</p></li>
<li><p>the compiler will flag a problem in their code, in which case
hopefully our error messages will suggest to add a <code>:Sized</code> bound
or to just not use <code>type</code> in the binding for <code>T</code>.</p></li>
</ul>

<p>If they under-generalize, then they (or their library&#39;s clients) will
discover the problem when they apply <code>foo</code>.</p>

<p>For the trait case, it is a little less obvious what to do.
I think we could likewise write:
<code>trait Foo for type : NormalBounds</code>
for the maximally general case.
<code>trait Foo : NormalBounds</code> would then desugar to
<code>trait Foo for type : Sized + NormalBounds</code></p>

<p>So the point is that you would only use the <code>type</code> keyword when you
wanted to explicitly say &quot;I am generalizing over <em>all</em> types, not just
sized ones&quot;, and thus are opting into the additional constraints that
that scenario presents.</p>

<p>This approach wouldn&#39;t be so palatable under earlier envisioned
designs for DST where e.g. you were restricted to write explicitly
<code>unsized struct S { ... }</code> for structs that could end up being
unsized.  But at this point I think we have collectively decided that
such a restriction is unnecessary and undesired, so there is no worry
that someone might end up having to write <code>type struct S { ... }</code>,
which definitely looks nonsensical.</p>

<p>There is another potential advantage to this approach that I have not
explored much yet: we could also add an <code>Unsized</code> trait bound, and
allow people to write <code>&lt;type X:Unsized&gt;</code> for when they want to
restrict <code>X</code> to unsized types alone.  I am not sure whether this is
actual value in this, but it does not seem absurd to put in a special
case in the coherence checker to allow one to write
<code>impl&lt;X:Sized&gt; SomeTrait for X { ... }</code>
and
<code>impl&lt;X:Unsized&gt; SomeTrait for X { ... }</code>
in order to get full coverage of <code>SomeTrait</code> for all types.</p>

<p>Finally, another obvious (though obviously post Rust 1.0) direction
that this approach suggests is that if we decide to add
parameterization over constants, we can likewise use the <code>const</code>
keyword in the spot where I have written the generalization marker
<code>type</code>, e.g.
<code>rust
fn foo&lt;const N:int&gt;(nums: &amp;[f64, ..N]) { ... }
</code>
(In this case <code>const</code> would not be a generalization marker but instead
a <em>kind</em> marker, since it is changing the domain of the parameter from
being that of a type to being some value within a type.)</p>

<h2 id="toc_2"><a id="the_examples">Examples ported from DST, Take 5</a></h2>

<p>Here are the ported definitions of <code>Rc</code> and <code>RcData</code>.
(Update: had to turn off syntax highlighting to work-around a rendering bug on <code>*</code>.)
```text
struct Rc<type T> {
    ptr: *RcData<T>,
    // (a dummy field, just for illustrative purposes)
    dummy: uint,
}</p>

<p>struct RcData<type T> {
    ref_count: uint,</p>
<div class="highlight"><pre><code class="text">#[max_alignment]
data: T
</code></pre></div>
<p>}</p>

<p>impl<type T> Drop for Rc<T> {
    fn drop&lt;&#39;a&gt;(&amp;&#39;a mut self) {
        unsafe {
            intrinsics::drop(&amp;mut (*self.ptr).data);
            libc::free(self.ptr);
        }
    }
}
```</p>

<p>Here is the <code>ImmDeref</code> example:
```rust
trait ImmDeref<type T> {
    fn deref&lt;&#39;a&gt;(&amp;&#39;a self) -&gt; &amp;&#39;a T;
}</p>

<p>impl<type T> ImmDeref<T> for Rc<T> {
    fn deref&lt;&#39;a&gt;(&amp;&#39;a self) -&gt; &amp;&#39;a T {
        unsafe {
            &amp;(*self.ptr).data
        }
    }
}
```</p>

<p>(I think I need a wider variety of examples, but this is good enough for now.)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Detective Work on Rust Closures]]></title>
    <link href="http://blog.pnkfx.org/blog/2013/06/07/detective-work-on-rust-closures/"/>
    <updated>2013-06-07T10:17:00+02:00</updated>
    <id>http://blog.pnkfx.org/blog/2013/06/07/detective-work-on-rust-closures</id>
    <content type="html"><![CDATA[<ul>
<li><a href="#background_fns">Background: Closures (recurring and otherwise)</a></li>
<li><a href="#background_dst">Background: DST</a></li>
<li><a href="#the_problem">The Problem: DST and Closures</a>

<ul>
<li><a href="#is_fn_too_ugly">Is fn~ too ugly?</a></li>
<li><a href="#leveraging_proc">Leveraging a proc keyword/expression</a></li>
<li><a href="#other_ways_to_proc">Other ways to express proc</a></li>
<li><a href="#digression_on_macros">A Personal Digression on Macros</a></li>
<li><a href="#more_followup_on_procs_and_fns">More followups on procs and fns</a></li>
</ul></li>
<li><a href="#where_are_we">So where are we?</a></li>
</ul>

<p>I have recently been trying to keep myself abreast of a flurry of
discussion about reforming the design of Rust closures.  Niko has a
series of blog posts (<a href="http://smallcultfollowing.com/babysteps/blog/2013/04/30/the-case-of-the-recurring-closure/">1</a>, <a href="http://smallcultfollowing.com/babysteps/blog/2013/04/30/dynamically-sized-types/">2</a>, <a href="http://smallcultfollowing.com/babysteps/blog/2013/05/13/recurring-closures-and-dynamically-sized-types/">3</a>, <a href="http://smallcultfollowing.com/babysteps/blog/2013/05/13/mutable-fn-alternatives/">4</a>, <a href="http://smallcultfollowing.com/babysteps/blog/2013/05/14/procedures/">5</a>, <a href="http://smallcultfollowing.com/babysteps/blog/2013/05/30/removing-procs/">6</a>, <a href="http://smallcultfollowing.com/babysteps/blog/2013/06/03/more-on-fns/">7</a>, <a href="http://smallcultfollowing.com/babysteps/blog/2013/06/06/reducing-dst-annotation/">8</a>); the
content of some of those posts were further discussed at Rust team
meetings (<a href="https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-04-30">11</a>, <a href="https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-05-07">12</a>, <a href="https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-05-14">13</a>, <a href="https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-05-21">14</a>, <a href="https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-05-28">15</a>, <a href="https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-06-04">16</a>), and there have been some
more formalized proposals with their own set of discussions: (<a href="https://github.com/mozilla/rust/wiki/Proposal-for-closure-reform">9</a>,
<a href="https://github.com/mozilla/rust/wiki/Proposal-for-closure-reform-%28specific%29">10</a>).</p>

<p>There are also associated github issues (<a href="https://github.com/mozilla/rust/issues/2202">17</a>, <a href="https://github.com/mozilla/rust/issues/3569">18</a>, <a href="https://github.com/mozilla/rust/issues/6308">19</a>), though
without sufficient context the discussion in the github issues may not
always be intelligible.</p>

<p>Some of the links above are more about &quot;Dynamically Sized Types&quot;
(DST), a related topic, as we shall see.</p>

<p>This post is my attempt to condense all of this information down into
something where I can see all the pieces at once, and discard the
red herrings along the way.</p>

<h2 id="toc_0"><a id="background_fns">Background: Closures (recurring and otherwise)</a></h2>

<p>In Rust circa version 0.6, closures have three categories according to
the type system (<code>&amp;fn</code>, <code>@fn</code>, and <code>~fn</code>), but <a href="http://smallcultfollowing.com/babysteps/blog/2013/05/14/procedures/">as Niko describes</a>,
they can be divided into two kinds: by-reference closures and copying
closures.  By-reference closures are also referred to as
stack-allocated closures or sometimes &quot;stack closure.&quot;
(There is also a orthogonal division of <code>once</code> closures, versus
closures that can be invoked more than once; some of these things are,
to my knowledge, only part of planned future implementation.  Niko
discusses them in the blog posts but I&#39;m mostly sidestep them here.)</p>

<p>As Niko states in the first paragraph of <a href="http://smallcultfollowing.com/babysteps/blog/2013/04/30/the-case-of-the-recurring-closure/">1</a>, a stack closure is
allocated on the stack, and can refer to and manipulate the local
variables of the enclosing stack frame (by reference).</p>

<p>In Rust (as of version 0.6), one creates a stack-allocated closure by
writing an expression <code>|x ...| { ... }</code> within an expression context
dictating that it wants a closure of <code>&amp;fn</code> type.  Analogously, a
closure allocated on the exchange-heap is expressed by putting the
expression into a context of <code>~fn</code> type, et cetera.  Since a
stack-allocated closure is currently expressed solely by use of <code>&amp;fn</code>
type, Niko often uses the term <code>&amp;fn</code> closure synonymously with
stack-allocated closure.</p>

<p>(However, Niko also points out (first section of
<a href="http://smallcultfollowing.com/babysteps/blog/2013/05/14/procedures/">&quot;Procedures, Continued&quot;</a>) that one can borrow a <code>@fn</code> or <code>~fn</code> to
a <code>&amp;fn</code>, so the type does <em>not</em> tell you whether you actually have a
by-reference or a copying-closure.)</p>

<p>Here is the example of an unsound function that Niko described in
his <a href="http://smallcultfollowing.com/babysteps/blog/2013/04/30/the-case-of-the-recurring-closure/">Case of the Recurring Closure</a> post from 2013-04-30,
making use of higher-order functions to express a fixed-point
combinator:
```rust
struct R&lt;&#39;self&gt; {
    // This struct is needed to create the
    // otherwise infinite type of a fn that
    // accepts itself as argument:
    c: &amp;&#39;self fn(&amp;R)
}</p>

<p>fn innocent_looking_victim() {
    let mut vec = ~[1, 2, 3];
    conspirator(|f| {
        if vec.len() &lt; 100 {
            vec.push(4);
            for vec.each |i| {
                f.c(&amp;f)
            }
        }
    })
}</p>

<p>fn conspirator(f: &amp;fn(&amp;R)) {
    let r = R {c: f};
    f(&amp;r)
}</p>
<div class="highlight"><pre><code class="text">As Niko explains, the vector `vec` is mutated while being traversed by
an iterator; this is illegal.  The closure `|f| { ... }` captures
a reference to `vec`, and Rust&#39;s borrow checker is not treating the argument
`f` as a potential source of aliases to `vec`, even though it does alias
`vec` because `f` ends up being bound to the closure `|f| { ... }`.

An important detail here is that the closure in question is
a stack-allocated closure.

Niko has described his solution to this problem in [1]; it would
entail adding some new rules about how `&amp;fn` closures are invoked
and passed as parameters.  One of the main changes imposed by his
solution was that `&amp;fn` closures would become non-aliasable;
this would ensure that one could not express the Y-combinator.
The restriction to ensure `&amp;fn` closures are unaliasable interacts
with other proposals, as we shall see.
(Note that Rust does have a way of expressing a non-aliasable pointer
to `T` for any `T`: `&amp;mut T`.)

## &lt;a id=&quot;background_dst&quot;&gt;Background: DST&lt;/a&gt;

The heart of the Dynamically Sized Types proposal is the discrepancy
described in Niko&#39;s [DST, Revisited][2] post from 2013-04-30
(published contemporaneously with [Case of the Recurring Closure][1]).
Niko has been wrestling with the idea for a while, as one can see on
his posts from [2012-04-23][20] and [2012-04-27][21].

In Rust, vectors (and strings, which we will treat as a special case
of vectors) come in the following forms:

* dynamic-length: heap-allocated, carries its length N as part of its
  record structure.  Consists of some amount of meta-data, including
  the length word, followed by the inline-allocated array of N
  elements.  Expressed as `~[T]` and `@[T]` in Rust.
* slice: represents a substring of a vector; consists of two words: a
  pointer to the payload, and a length bound.  Expressed as `&amp;[T]` in Rust.
* fixed-length: represents exactly N elements, where N is statically
  tracked at compile-time.  Consists of just the array of elements,
  `T[N]`, and nothing more.  Expressed as `[T, ..N]` in Rust.

Niko points out that a slice&#39;s two-word representation is quite
different from the representations of the other variants.  His
proposal is to unify the first two representations, by laying out
`~[T]` and `@[T]` as pairs of words (a pointer to the boxed elements
array, and a length).
(Niko claimed that this makes a `~[T]` and `@[T]` valid slices, &quot;apart
from the box header&quot;; it seems to me like the box header is quite
relevant here, unless the idea is that when you coerce a `@[T]` to a
slice, you increment the pointer value accordingly...)

Then, Niko classifies the types of Rust into two categories: Sized and
Unsized; i.e., size is statically known, versus size is tracked at
runtime (maybe the letters S and R would have been more appropriate
than S and U...).  The &quot;unsized types&quot; cannot themselves be assigned
as types of local variables, and you cannot have vectors of elements
of unsized type; this all stems from the fact that &quot;unsized types&quot; do
not have a static size.
(The &quot;unsized types&quot; are arguably not actually types; we might be
well-served by referring to them as &quot;pretypes&quot; or something).
But pointers to unsized types are valid types.  Such pointers are the
pairs of words discussed above, aka &quot;fat pointers&quot;: `(payload, meta)`,
where `payload` is the pointer to the data, and `meta` is the
descriptor that includes some way to determine the size of the payload
(to support runtime bounds checks).

The fact that &quot;unsized types&quot; need to be treated specially leads to a
complication, discussed further in the post; how to differentiate
between type-parameterized code that works on both kinds of types,
versus typed-parameterized code that solely operates on sized types.
The method proposed in the post is to express the distinction via a
trait bound: the `Sized` bound would restrict the type parameter to
one of statically-known size; you would not be able to express
types like `[X, ..3]` (a fixed-length vector of 3 X&#39;es), unless you
include the bound `X:Sized`.  (There is more on this restriction
and ways to ease it further down.)

One of the benefits of DST that Niko proposes early on is that
Traits and closures are other instances of unsized types, so that
Rust&#39;s type hierarchy could be presented uniformly like so:
</code></pre></div>
<p>T = S            // sized types
  | U            // unsized types
S = &amp;&#39;r T        // region ptr
  | @T           // managed ptr
  | ~T           // unique ptr
  | [S, ..N]     // fixed-length array
  | uint         // scalars
  | ...
U = [S]          // vectors
  | str          // string
  | Trait        // existential (&quot;exists S:Trait.S&quot;)
  | fn(S*) -&gt; S
``<code>
(Note that the actual types assigned to expressions would be instances
of</code>S` according to this grammar.)</p>

<h2 id="toc_1"><a id="the_problem">The Problem: DST and Closures</a></h2>

<p>So, from the &quot;Case of the Recurring Closure&quot;, we saw that
<code>&amp;fn</code> closures were to become non-copyable.
But under the DST proposal, generic code should be able to treat <code>&amp;T</code>
the same for all <code>T</code>, <em>including</em> when <code>T</code> is some <code>fn(S*) -&gt; S</code>.
These two criteria are not compatible; Niko has lots more explanation
in his corresponding post:
<a href="http://smallcultfollowing.com/babysteps/blog/2013/05/13/recurring-closures-and-dynamically-sized-types/">&quot;Recurring Closures and Dynamically Sized Types&quot;</a>,
from 2013-05-13.</p>

<p>Niko&#39;s immediate proposals to resolve this were either:</p>

<ul>
<li>we write <code>&amp;mut fn</code> instead of <code>&amp;fn</code>.  <code>&amp;mut T</code> for all <code>T</code>
(including <code>fn (S ...) -&gt; S</code>) is forced to be unaliasable by the
borrow-checker, and so the hole goes away, or,</li>
<li>we change notation, and move the sigils for closures <em>after</em> the fn,
side-stepping the special treatment of <code>&amp;fn</code> versus <code>&amp;T</code> by getting
rid of <code>&amp;fn</code> and replacing it with <code>fn&amp;</code>.</li>
</ul>

<h3 id="toc_2"><a id="is_fn_too_ugly">Is fn~ too ugly?</a></h3>

<p>Niko at first favored the latter, then he wrote a second post,
<a href="http://smallcultfollowing.com/babysteps/blog/2013/05/13/mutable-fn-alternatives/">&quot;Mutable Fn Alternatives&quot;</a> on 2013-05-13,
which reconsidered whether <code>fn~</code> is too ugly, and included
new survey of the options:</p>

<ul>
<li>Maybe <code>&amp;mut fn</code> is not that bad, or</li>
<li>Maybe make <em>all</em> closures borrowed (i.e. stack-allocated), removing
the need for any sigil, or</li>
<li>Make <code>fn</code> denote stack-allocated closures,
and replace <code>fn~</code> with a new keyword, like <code>proc</code>.  (This is a variation
on the previous bullet.)</li>
</ul>

<p>For the second and third bullets, the main point is: If you need to
capture state in a manner that cannot be expressed via the available
options (stack-allocated closure, or a <code>proc</code>, if present), then you
have to use an trait instead (i.e. an object or a record).
(I personally am not thrilled about losing the option of using
closures to express combinator libraries, a use case for <code>fn@</code>.)</p>

<h3 id="toc_3"><a id="leveraging_proc">Leveraging a proc keyword/expression</a></h3>

<p>Then a third post, <a href="http://smallcultfollowing.com/babysteps/blog/2013/05/14/procedures/">&quot;Procedures, Continued&quot;</a> from
2013-05-15, refined the <code>proc</code> proposal a bit further.  As stated in
the background on closures, Rust has by-reference closures and copying
closures; the choice of which variant to construct is based on the
type expected by the context of the <code>|x ...| { ... }</code> expression.
In this post, Niko proposed that the distinction here deserves a
starker line between the two forms.  (In that post, he proposed both a
revision to English jargon and also to the Rust syntax; I&#39;m going to
focus solely on the Rust syntax changes, and let those guide the
changes to my own jargon here.)</p>

<p>So Niko proposes distinguishing a by-reference closure from a copying
closure via keywords.  A stack-allocated closure would be constructed
solely via <code>fn</code>, and a copying closure would be constructed solely via
<code>proc</code>.  While discussing this proposal henceforth, I will refer to a
by-reference closure as an <code>fn</code>-closure and a copying closure as a
<code>proc</code>-closure.</p>

<p>The type hierarchy that Niko then provides for this is:
<code>
T = S               // sized types
  | U               // unsized types
S = fn(S*) -&gt; S     // closures (*)
  | &amp;&#39;r T           // region ptr
  | @T              // managed ptr
  | ~T              // unique ptr
  | [S, ..N]        // fixed-length array
  | uint            // scalars
  | ...
U = [S]             // vectors
  | str             // string
  | Trait           // existential (&quot;exists S:Trait.S&quot;)
  | proc(S*) -&gt; S   // procedures (*)
</code></p>

<p>Now, <code>fn</code>-closures are considered <em>sized types</em>, because they are
always represented by two words: a (borrowed) environment pointer (to
the stack in Niko&#39;s proposal, though perhaps it could be generalized
to point elsewhere) and a function pointer.  <code>proc</code>-closures are
<em>unsized types</em>, because their copied lexical environment is of some
dynamically-determined size that they must carry in their record
structure.</p>

<p>In this version of the proposal, <code>proc</code> can now be allocated to either
the exchange heap (<code>~proc</code>) or the task heap (<code>@proc</code>).  So this
brings back the ability to express combinator libraries.</p>

<p>Niko&#39;s post provides further detail, such as dissection of the <code>fn</code>
and <code>proc</code> closure types (which include important details like the
lifetime and trait <em>bounds</em> for the closed-over variables; this is
important since with a separate keyword, it is now reasonable for
different defaults to be chosen for two cases; useful for making the
common case succinct).  He also describes a couple variations on the
theme, including modeling <code>proc</code> closures via traits (i.e. boxed
traits are objects carrying virtual method dispatch tables), and then
expressing them via a <code>proc!</code> macro (which means they could be left
out of the core language).</p>

<h3 id="toc_4"><a id="other_ways_to_proc">Other ways to express proc</a></h3>

<p>In his next post, <a href="http://smallcultfollowing.com/babysteps/blog/2013/05/30/removing-procs/">&quot;Removing Procs&quot;</a>, Niko elaborates further
on the idea that <code>proc</code> need not be supported in the language at all.
Stack-allocated <code>fn</code>-closures would remain, expressed via <code>fn(S ...) -&gt; T</code>,
and the language already supports raw (environment-less) function
pointers via <code>extern &quot;ABI&quot; fn(S ...) -&gt; T</code>.
Niko points out two ways to re-express copying closures:</p>

<ol>
<li>One could pass around function pointers along with
records that carry the captured environment; this is basically
<a href="http://matt.might.net/articles/closure-conversion/">lambda-lifting</a> (the variant that turns the free variables
into fields of a single environment structure, rather than passing each
variable as a separate parameter), or</li>
<li>As stated earlier, (boxed) traits can used to express copying
closures.</li>
</ol>

<p>Niko surveyed how these patterns would look in his post, by considered
existing use cases of <code>@fn</code> and <code>~fn</code> in the standard libraries,
namely task spawning and futures.  Without more language support, the
lambda-lifting transformation requires that one list the captures
variables (at least once, though further repetitions can be avoided
via appropriate macro definitions).  I am personally hesistant to
approve of removing non stack-allocated closures wholesale, though
<em>if</em> it turns out that capture clauses are essentially unavoidable (or
if understanding behavior without them is unworkable), then my main
problem with the <code>proc!</code> macros (the explicit list of free variables)
would go away.</p>

<p>Alternatively, if the macro system were somehow extended to allow a
macro to query an expression for its free variables, then that might
help.</p>

<h4 id="toc_5"><a id="digression_on_macros">A Personal Digression on Macros</a></h4>

<p>Actually, this latter idea brings up a problem with the explicit list
of captured variables that I had not thought of before: some macros
may intentionally inject references to free variables, where the
injected free variables are not meant to be part of the public
interface of the macro (i.e., the macro is enforcing some protocol of
usage, and the variable is meant to be otherwise private to the module
where the macro is defined).  I know we do not currently have macros
exported from modules, but I thought it was supposed to be part of the
long term plans for Rust.</p>

<ul>
<li><p>Do we intend to disallow the use of such macros within copying closures?</p></li>
<li><p>Will we require the modules to expose those variable names, solely
so that they can be included on the lists of free variables?</p></li>
<li><p>Or, if a macro could query an expression for its free variables
(where even module-private identifiers might be included on such
a list), that might help impose a usage discipline that would
support a <code>proc!</code> macro,</p></li>
<li><p>Or, this whole example might serve as an argument for keeping
copying closures as a primitive linguistic construct.</p></li>
</ul>

<p>Okay, end of digression.</p>

<h3 id="toc_6"><a id="more_followup_on_procs_and_fns">More followups on procs and fns</a></h3>

<p>A few days passed, then Niko had a fourth post,
<a href="http://smallcultfollowing.com/babysteps/blog/2013/06/03/more-on-fns/">&quot;More on Fns&quot;</a>, from 2013-06-03.
This proposal renamed of a proposed <code>Task</code> trait to <code>Thunk</code>, since
Niko felt that the concept at hand (an encapsulated function and the
parameters it needs) is better reflected by that name.</p>

<p>More importantly, given the immediately preceding digression, the form
<code>thunk { ... }</code> would automatically determine the captured variables
instead of requiring an explicit list; this sidesteps the whole question
of how to handle macros that inject new free variable references.</p>

<p>There is then much discussion of whether or not to support <code>once fn</code>s,
which I won&#39;t summarize here.  The important detail of the post is
that we do not necessarily have to list the captured variables
explicitly.</p>

<p>After a few more days, Niko had a followup on the related topic of
dynamically sized types (DST), <a href="http://smallcultfollowing.com/babysteps/blog/2013/06/06/reducing-dst-annotation/">&quot;Reducing DST Annotation&quot;</a>, from
2013-06-06.  It took into account an <a href="https://github.com/mozilla/rust/issues/6308#issuecomment-18880575">investigation</a> by Ben Blum
on the implications of a <code>Sized</code> trait bound.  This led to Niko
exploring some alternatives to adopting DST with a <code>Sized</code> bound:</p>

<ul>
<li>Abandon DST altogether: Niko summarizes what DST still buys us, but
also points out where it does not live up to its original promises.</li>
<li>Make type parameters default to <code>Sized</code>, and adopt a different
syntactic mechanism to distinguish <code>Sized</code> from <code>Unsized</code> (such as
a keyword).</li>
<li>Use some sort of inference: the type-checker can use properties
of a function&#39;s parameter list to provide feedback
on whether the type parameter has an implicit <code>Sized</code> bound.
(Niko wonders if this approach is too clever; I am inclined to
affirm that it is.)</li>
</ul>

<h2 id="toc_7"><a id="where_are_we">So where are we?</a></h2>

<p>The above summarizes the series of blog posts from Niko.  I had hoped
to get through the actual proposals (and maybe also the team meeting
notes), but at this point, it is late enough in the day and this post
is long enough that I think I will stop here.</p>

<p>The language is young, and I am a Rust novice.  So, grains of salt
for everyone:</p>

<ul>
<li>My intuition is that we should leave in copying closures in some form.</li>
<li>The <code>thunk { ... }</code> expression might suffice, but ... I am not yet
convinced that I would be satisfied using boxed traits
to express the cases that need input arguments (like combinator
libraries).</li>
<li>I am not thrilled by the idea of writing out lists of free
variables.  Of course, this is a systems programming language,
and such a list may simply be the simplest way to accomplish
certain goals (e.g. to indicate whether a referenced value
is moved or copied).</li>
<li>If we do require a list of free variables in our copying
<code>proc</code>/<code>thunk</code>/etc, please ensure that the question of free
variables injected by macro invocations is addressed.</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Designing syntax for associated items in Rust]]></title>
    <link href="http://blog.pnkfx.org/blog/2013/04/22/designing-syntax-for-associated-items-in-rust/"/>
    <updated>2013-04-22T14:37:00+02:00</updated>
    <id>http://blog.pnkfx.org/blog/2013/04/22/designing-syntax-for-associated-items-in-rust</id>
    <content type="html"><![CDATA[<ul>
<li><a href="#background">Background</a>

<ul>
<li><a href="#encodingunpalatable">Encoding via parameters is unpalatable</a></li>
</ul></li>
<li><a href="#rustspec">Rust-specific issues</a>

<ul>
<li><a href="#nikoposts">Niko&#39;s blog posts</a></li>
<li><a href="#thinkbinding">Simpler syntax: What about binding?</a></li>
</ul></li>
<li><a href="#insight">Insight</a></li>
<li><a href="#proposal">The proposed syntax for associated items in Rust</a></li>
<li><a href="#futurework">What the proposal does not cover</a></li>
</ul>

<p>Executive summary: if you don&#39;t want or need the background information
or the discussion motivating the proposal, then just jump
straight to the <a href="#proposal">proposal</a> itself.</p>

<h2 id="toc_0"><a id="background">Background</a></h2>

<p>Early in my experimentation with Rust, I thought a reasonable exercise
would be to take the simple C++ programs from
<a href="http://www.elementsofprogramming.com/">Elements of Programming</a> (Stepanov and McJones), which make heavy yet
disciplined use of abstraction and C++ templates to encode various
mathematical concepts.  The early chapters of the book use templates
rather than classes as the means of code reuse, so translating those
examples seemed like a good way to exercise Rust&#39;s generic type and
trait systems.</p>

<p>However, almost immediately after starting the experiment, I encountered
a problem: code that makes heavy use of C++ templates is quite likely
to use particular features of C++ templates that are not a universal
part of another language&#39;s generic type system.</p>

<p>In particular, the code from Elements of Programming (hereby
abbreviated &quot;EOP&quot; in this post) almost immediately makes use of
&quot;associated types&quot;, such as in the following definition for <code>distance</code>:</p>
<div class="highlight"><pre><code class="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
    <span class="n">requires</span><span class="p">(</span><span class="n">Transformation</span><span class="p">(</span><span class="n">F</span><span class="p">))</span>
<span class="n">DistanceType</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="n">distance</span><span class="p">(</span><span class="n">Domain</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="n">x</span><span class="p">,</span> <span class="n">Domain</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="n">y</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Precondition: $y$ is reachable from $x$ under $f$</span>
    <span class="k">typedef</span> <span class="n">DistanceType</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="n">N</span><span class="p">;</span>
    <span class="n">N</span> <span class="nf">n</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">N</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>The interesting thing about the above code is that it is parameterized
over one type: <nobr><code>F</code>,</nobr> but it uses other type expressions within the body
of the procedure, namely:</p>

<ul>
<li><p><code>Domain(F)</code>: this is a <code>type -&gt; type</code> operator that, given a
Transformation (which we can think of as some type classifying a
set of <code>T -&gt; T</code> functions for some type <code>T</code>), returns <code>T</code>.</p></li>
<li><p><code>DistanceType(F)</code>: this is a <code>type -&gt; type</code> operator that, given a
Transformation, returns a numeric type (think <code>uint8_t</code>,
<code>uint32_t</code>, <code>uintptr_t</code>, <code>BigNum</code>, etc) suitable for counting the
minimum number of applications of the transformation necessary to
get from any particular <code>T</code> value to some other <code>T</code> value.</p></li>
</ul>

<p>(Operators like <code>DistanceType</code>, to my mind, only makes sense when you
 look at things simultaneously in terms of bytes of memory in the
 machine and also in terms of pure abstract mathematical values.  If
 you omit either perspective, then the operator appears either
 pointless or nonsensical.)</p>

<p>It also requires that <code>F</code> obeys a constraint, specified in the
<code>requires</code> clause; I am going to conveniently ignore this detail for
now.  (The C++ code for EOP even macro-expands <code>requires(..)</code> into whitespace,
so treating them as helpful comments for the time being is not absurd.)</p>

<p>Type expressions like <code>triple&lt;A, B, C&gt;</code> (assuming three type expressions
<code>A</code>, <code>B</code>, and <code>C</code>), are the bread-and-butter of any generic type
system.  But these <code>type -&gt; type</code> operators are interesting.  How are
they implemented?  Here is a snippet from <code>type_functions.h</code> in the
EOP source code distribution:</p>
<div class="highlight"><pre><code class="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
    <span class="n">requires</span><span class="p">(</span><span class="n">Transformation</span><span class="p">(</span><span class="n">F</span><span class="p">))</span>
<span class="k">struct</span> <span class="n">distance_type</span><span class="p">;</span>

<span class="c1">// If all transformations on a type T have the same distance type,</span>
<span class="c1">// then DistanceType(T) is defined and returns that type.</span>

<span class="c1">// For any fixed-size type T, there is an integral type of the same</span>
<span class="c1">// size that is a valid distance type for T.</span>

<span class="cp">#define DistanceType(T) typename distance_type&lt; T &gt;::type</span>
</code></pre></div>
<p>This code is making use of a C-style macro to define a easy-to-read
interface for the <code>DistanceType</code> operator (the subset of C++ used
for EOP&#39;s textbook examples is meant to be LL(1)), but the implementation
of the operator is using C++&#39;s template system to define a partial
mapping from types to (integral) types.  One can add new entries to
this mapping by defining a new template instantiation of
<code>struct distance_type&lt;F&gt;</code>, as illustrated in <code>tests.h</code> for the following
transformation <code>gen_orbit</code>:</p>
<div class="highlight"><pre><code class="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">I</span><span class="p">,</span> <span class="k">typename</span> <span class="n">N</span><span class="o">&gt;</span>
    <span class="n">requires</span><span class="p">(</span><span class="n">Integer</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">Integer</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">DistanceType</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">=</span> <span class="n">N</span><span class="p">)</span>
<span class="k">struct</span> <span class="n">gen_orbit</span> <span class="c1">// transformation</span>
<span class="p">{</span>
    <span class="n">gen_orbit_predicate</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">gen_orbit</span><span class="p">(</span><span class="n">I</span> <span class="n">x_0</span><span class="p">,</span> <span class="n">N</span> <span class="n">h</span><span class="p">,</span> <span class="n">N</span> <span class="n">c</span><span class="p">)</span> <span class="o">:</span> <span class="n">p</span><span class="p">(</span><span class="n">x_0</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Precondition: h &lt; N(MaximumValue(I)) &amp;&amp; c &lt; N(MaximumValue(I))</span>
        <span class="c1">// Precondition: !negative(h) &amp;&amp; !negative(c)</span>
    <span class="p">}</span>
    <span class="n">I</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="n">I</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Assert</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">successor</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">p</span><span class="p">.</span><span class="n">x_0</span> <span class="o">+</span> <span class="n">I</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">h</span><span class="p">)</span> <span class="o">+</span> <span class="n">I</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">c</span><span class="p">))</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">x_0</span> <span class="o">+</span> <span class="n">I</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">h</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">;</span> 
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">I</span><span class="p">,</span> <span class="k">typename</span> <span class="n">N</span><span class="o">&gt;</span>
    <span class="n">requires</span><span class="p">(</span><span class="n">Integer</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">Integer</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">DistanceType</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">=</span> <span class="n">N</span><span class="p">)</span>
<span class="k">struct</span> <span class="n">distance_type</span><span class="o">&lt;</span> <span class="n">gen_orbit</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">N</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>Thus, the definition of <code>gen_orbit</code> (including its instantiation of
<code>distance_type</code>) collaborates with the definition of <code>DistanceType</code> to
indicate that <code>DistanceType(gen_orbit&lt;I, N&gt;)</code> is <code>N</code>.  As one adds new
structs (classes) representing other transformations, one is expected
to instantiate <code>distance_type</code> (as well as a host of other
template-abstracted structs) accordingly.</p>

<hr>

<p>So, what&#39;s the problem here?  Well, Rust, much like Java, does not
provide a way to define general <code>type -&gt; type</code> mappings like
<code>DistanceType(F)</code>.</p>

<p>One can try to work around this via a code transformation and lift any
type of interest up to a generic class&#39;s parameter list, like this
example in Rust:
<code>rust
trait Transformation&lt;DISTANCETYPE, DOMAIN&gt; {
    fn apply(&amp;self, elem: DOMAIN) -&gt; DOMAIN;
}
</code>
or if you prefer Java:
<code>java
    interface Transformation&lt;DISTANCETYPE, DOMAIN&gt; {
        DOMAIN apply(DOMAIN elem);
    }
</code></p>

<p>At first glance, one might think this does not look so bad; after all,
the <code>gen_orbit</code> struct similarly was parameterized over a domain <code>I</code>
and a distance type <code>N</code>.  However, the problem comes when one
then attempts to write a function like distance:</p>

<p>Rust:
<code>rust
fn distance&lt;F: Transformation&lt;DT, DOM&gt; &gt;(x: ???, y: ???, f: F) -&gt; ??? {
    /* ... */
}
</code></p>

<p>Java:
<code>java
    public static &lt;F extends Transformation&lt;DT, DOM&gt; ??? distance(??? x, ??? y, F f) {
        /* ... */
    }
</code></p>

<p>What do we put in for the <code>???</code> portions?  We already established that
we do not have general <code>type -&gt; type</code> operators, so we cannot just
derive it form <code>F</code>.  And for that matter, where did <code>DT</code> and <code>DOM</code>
come from?  In Rust and Java, we cannot just make up fresh type
variables and then add constraints upon them after the fact.  The only
option is to make any type we wish to use an additional type parameter
to the generic method.</p>

<p>Rust:
<code>rust
fn distance&lt;DT, DOM, F: Transformation&lt;DT, DOM&gt; &gt;(x: DOM, y: DOM, f: F) -&gt; DT {
    /* ... */
}
</code></p>

<p>Java:
<code>java
    public static &lt;DT, DOM, F extends Transformation&lt;DT, DOM&gt; &gt;
        DT distance(DOM x, DOM y, F f) {
        /* ... */
    }
</code></p>

<h3 id="toc_1"><a id="encodingunpalatable">Encoding via parameters is unpalatable</a></h3>

<p>The Rust and Java results above are made barely readable by using
short (obscure) parameter names.  More troubling is the fact that this
pollution of the parameter list will bubble transitively backwards
through the callers of <code>distance</code> until we reach the point where <code>F</code>
is instantiated.  Any use of <code>Transformation</code> needs to be
parameterized in the same manner.</p>

<p>It also makes explicit instantiation of a parameterized method or
class quite painful.  (This pain is somewhat alleviated in the
presence of type-inference, at least in terms of what text ends up in
the final code, but I argue that that in this case the pain has in
fact been <em>shifted</em>: instead of having pain while reading the code,
one instead suffers when trying to wade through type-errors that
inevitably arise during the compile-edit cycle.)</p>

<p>If anything, the above presentation <em>understates</em> the problem, since:</p>

<ol>
<li><code>Transformation</code> has only one argument in its domain, and its codomain
 is the same as its domain; many real traits with associated types
 are each likely to require multiple parameters.</li>
<li>The above example has direct uses of <code>DOM</code> and <code>DT</code> in the domain
 and codomain, respectively, of <code>distance</code>.  However, <em>every</em> client
 of <code>Transformation</code> will be forced to be parameterized over <code>DOM</code>
 and <code>DT</code>; while it is likely that any client of <code>Transformation</code> is likely
 to need to refer to the type <code>DOM</code>, many are likely to not require
 use of the distance type <code>DT</code> in their public interface or even in
 the internals of their code.  Thus, our abstraction is not very abstract
 at all.</li>
<li>As a follow-on to the previous point: We are only illustrating
 <em>one</em> added concept: <code>DistanceType</code>; each additional concept
 would require a new type parameter to be threaded through the
 parameter lists of all methods and classes.  This blows up to an
 unmaintainable mess fairly quickly, discouraging use of generics
 to define these abstractions (and instead relying on
 e.g. separate class-hierarchies).</li>
</ol>

<hr>

<h2 id="toc_2"><a id="rustspec">Rust-specific issues</a></h2>

<p>I encountered this problem while porting EOP code to Rust.  After
wrestling with the type parameter lists for a while, I eventually
wised up and asked on the #rust IRC channel if there was a better
option.  Tim Chevalier informed me of the relevant terminology:
the feature I want is called &quot;associated types access&quot; (or often just
&quot;associated types&quot;).
An associated type specifies a mapping from some type to another type.</p>

<p>&quot;Associated type access&quot; is listed as one of eight properties considered important in
&quot;<a href="http://osl.iu.edu/publications/prints/2003/comparing_generic_programming03.pdf">A comparative study of language support for generic programming</a>&quot;
(Garcia et al., 2003 <a href="http://dl.acm.org/citation.cfm?id=949317">ACM</a>).
If you found <a href="#encodingunpalatable">the argument above</a> unconvincing,
you should read the Garcia paper for a completely different example motivated by
a Graph abstraction.</p>

<p>After I read the Garcia paper, I promptly filed <a href="https://github.com/mozilla/rust/issues/5033">an RFC</a> on the
Rust github repository requesting support for Associated Type
Synonyms.  After this, I had several discussions with Niko Matsakis,
both over IRC and in person, on the problems that associated types
present for Rust.</p>

<h3 id="toc_3"><a id="nikoposts">Niko&#39;s blog posts</a></h3>

<p>You can see Niko&#39;s thorough overview of the matter,
including his natural generalization of the topic from &quot;associated
types&quot; to &quot;associated <em>items</em>&quot;, on his pair of blog posts (<a href="http://www.smallcultfollowing.com/babysteps/blog/2013/04/02/associated-items/">part
I</a>, <a href="http://www.smallcultfollowing.com/babysteps/blog/2013/04/03/associated-items-continued/">part II</a>).  The generalization to &quot;associated items&quot;
enables one to define, in addition to <code>type -&gt; type</code> mappings as
illustrated <a href="#background">above</a>, also <code>type -&gt; function</code>
mappings (called in some languages &quot;static&quot; functions) and <code>type -&gt;
(constant) value</code> mappings, which may enable certain interesting
coding patterns, such as allowing a type representing a vector in a
multi-dimensional space to state, statically, how many dimensions
it carries.</p>

<p>The following are the specific points that Niko makes in his posts (some of 
are just pointing out artifacts of current Rust language syntax).</p>

<h3 id="toc_4">Current Rust syntax focuses on deriving associated functions from traits</h3>

<p>Rust does not currently offer general associated items, but it does
offer a kind of associated function access.</p>

<p>If a trait <code>T</code> defines a function <code>f</code> that returns <code>Self</code> (which means
that implementations of <code>T</code> are obligated to provide an implementation
of <code>f</code>), and one has a type <code>X</code> implementing that trait, then one can
derive <code>f</code>.</p>

<p>But in current Rust syntax, one does not write this derivation of <code>f</code>
as something attached to the type <code>X</code>; instead, one writes <code>T::f(..)</code>,
and the compiler is responsible for inferring which implementation of
the function <code>f</code> one is referring to, by using type-inference on the
context of the invocation <code>T::f(..)</code> to determine that the return type
of <code>f</code> must be <code>X</code> (and thus the <code>f</code> in question must be the one that
the type <code>X</code> implements to satisfy the obligation established by the
trait <code>T</code>).</p>

<h4 id="toc_5"><a id="nikoenctt1">Resolving ambiguities in general implies you need both the trait and type</a></h4>

<p>The choice of deriving a function&#39;s implementation from the trait
rather than the type is understandable when one considers that a
software system may have multiple traits <code>T</code>, <code>U</code>, <code>V</code>, ... that all
define a function of the same name (say <code>f</code>), and a type may be
specified as implementing more than one of these traits in a single
piece of code.  (It would be anti-modular to require every trait to
choose globally unique names for its set of associated functions).  So
to handle this case, one must provide some way to disambiguate which
<code>f</code> is being referenced.  Rust did so by making the trait expression
part of the invocation syntax.  Niko points out that if one switches
to a syntax where one derives <code>f</code> from the type
<code>X</code> (e.g. <nobr>&quot;<code>X::f</code>&quot;</nobr>) then one must tackle this problem in
some manner; in his first blog post, he suggests doing so by allowing
one to encode both the type and the trait in the referencing syntax
(e.g. <nobr>&quot;<code>X::(T::f)</code>&quot;</nobr> or <nobr>&quot;<code>X::(U::f)</code>&quot;</nobr>.</p>

<p>I dislike this syntax because I think it
would be confusing for a reader to comprehend the distinct roles of
the <nobr>&quot;<code>::</code>&quot;</nobr> path operator, both when learning the language
and when casually skimming Rust code in general.</p>

<h4 id="toc_6">Rust type expressions do not naturally fit into Rust path expressions</h4>

<p>Niko also points out that when one wants to write <code>X::f</code> where <code>X</code> is
a type, it is not always the case that <code>X</code> is a type parameter; it
could be a concrete type known to the programmer, such as the type of
owned vecs of ints, denoted by the type expression
<nobr><code>~[int]</code>.</nobr> So it seems natural to want to substitute such
a type expression for (the meta-variable) <code>X</code>.</p>

<p>But the syntax <code>~[int]::f</code> is not legal, because <code>~[int]</code> is
not a legitimate path component.  Niko describes a couple of
work-arounds, e.g. allowing one to wrap a type expression that appears
in a path expression with brackets, yielding: <code>&lt;~[int]&gt;::f</code>.</p>

<p>All of the work-arounds presented by Niko do require allowing
arbitrary type-expressions in some form to appear as a sub-expression,
which would complicate the parser in the Rust compiler (there has been
a slight push to try to <em>simplify</em> the path expression syntax, which
this would conflict with).</p>

<h4 id="toc_7">Further syntactic exploration of encoding trait and type</h4>

<p>In his second blog post, Niko provides some alternative syntactic forms
for resolution:</p>

<ul>
<li><p><code>X::(T::f)</code>, as described <a href="#nikoenctt1">above</a>.</p></li>
<li><p><code>T::f::&lt;X&gt;</code> (from &quot;Functional-style name resolution (take 1)&quot;); here
<code>X</code> is a synthetic type parameter added to the type parameter list
(if any) of <code>f</code>; so now we get to retain syntactic backwards
compatibility.  Since Rust allows one to omit the explicit type
instantiation <code>::&lt;X, ...&gt;</code> when the compiler is able to infer
the instantiation, this would be a natural way to continue
doing return-type based inference of the desired type, the way
it does already.</p></li>
<li><p><code>T::f::&lt;for X&gt;</code> as a way of distinguishing the synthetic parameter
from other entries on the parameter list.</p></li>
</ul>

<p>I have already stated my problems with the first option.</p>

<p>For the second option, I anticipate being personally confused by the
synthetic type parameter being injected into the type parameter list.
I understand the appeal of enabling the compiler to continue doing
heavy lifting and lighten the programmers syntactic load.  <a href="http://www.smallcultfollowing.com/babysteps/blog/2013/04/03/associated-items-continued/">Niko&#39;s
post</a> does a good job of laying out some of the unexpected
interactions of the synthetic type parameter with the other forms of
generic type parameterization.</p>

<p>The third option would reduce confusion somewhat, since the
synthetic parameter would receive special attention at points of type
instantiation, but I still think it is an abuse of the parameter list.</p>

<h3 id="toc_8"><a id="thinkbinding">Simpler syntax: What about binding?</a></h3>

<p>So I set about trying to come up with another syntactic form
for associated item access.  My primary focus initially was:
all of these examples would be so much simpler, to my mind,
if we were able to go back to using a single identifier
for the relevant path component in the referencing form,
the way that C++ uses <nobr><code>C::f</code>.</nobr>
How can Rust make its own analogous <nobr><code>R::f</code></nobr> (the &quot;R&quot; is for Rust).</p>

<p>Of course, we have already covered that this will be ambiguous if
<code>R</code> is a mere type (and it is of course ambiguous if <code>R</code> is just a trait).</p>

<p>But what if <code>R</code> is a way of referring to the type <code>X</code> and the trait <code>T</code>
together: the (type, trait) pairing (X,T)?  Clearly once one specifies the
pair, then it is easy to tell what items are associated with the pair.
Even a human without a sophisticated IDE would know in that case to try
invoking <code>grep</code>, searching for <code>impl T.* for X.*</code>; a compiler can do even better.</p>

<p>Another way of looking at this: What if we could introduce local names
for the impl that corresponds to the (type, trait) pairing.</p>

<p>So I started working on ideas all centering around a declaration
form like <code>let R = trait T for type X;</code> or <code>use impl R = T for X</code>
and other variations (I think Patrick Walton actually deserves credit
for that last one; we will revisit it later).  But Niko quickly pointed
the huge failing of all of these declaration forms: a very common
use case for associated <em>types</em> (remember, that was our original goal)
is for function signatures, like:
```rust
fn distance<F: Transformation>(x: Domain(F), y: Domain(F), f: F) -&gt; DistanceType(F);</p>

<p>fn remove_edge<G: IncidenceGraph + EdgeCollection>(g: &amp;mut G, e: Edge(G));
``<code>
where</code>Domain(F)<code>,</code>DistanceType(F)<code>, and</code>Edge(G)<code>are replaced
with appropriately Rust-friendly syntactic forms.  There is no *place*
there to put a declaration form</code>let ...<code>or</code>use ...<code>that refers to
</code>F`.  The same applies for other parameterized forms, such as structs,
enums, and traits.</p>

<p>So, back to the drawing board.</p>

<hr>

<h2 id="toc_9"><a id="insight">An Insight</a></h2>

<p>Even though my attempt to solve this problem via a declaration form had
failed, I continued to focus on the fact that associated item access
is all about the (type, trait) pairing.  So how could I surmount the
parameterized signature wall?</p>

<p>After reflecting on the parameterized signature itself, I said, &quot;where
is a natural place to put a binding from an identifier to a (type,
trait) pair?&quot;  And this reduced to &quot;where does the (type, trait) pair
come from?&quot;  This was my insight: The parameterized signature
<nobr><code>&lt;X: T&gt;</code></nobr> <em>itself</em> is where the pairing is defined;
(or in the case of <nobr><code>&lt;X: T + U&gt;</code></nobr>: <em>pairings</em>).</p>

<p>My only problem was to put the identifier binding in there.  Once I
saw the pairing waiting right in the parameter list, the place for the
identifier became clear: in-between the type and the trait:
<nobr><code>&lt;X: R=T&gt;</code></nobr> binds <code>R</code> to the <code>impl T for X</code>;
for multiple traits, we have <nobr><code>&lt;X: R=T + R2=U&gt;</code></nobr>,
where <code>R</code> is bound as above, and <code>R2</code> is bound to the <code>impl U for X</code>.</p>

<p>And now we can consider writing our examples like so:
```rust
fn distance<F: T=Transformation>(x: T::Domain, y: T::Domain, f: F) -&gt; T::DistanceType;</p>

<p>fn remove_edge<G: IncidenceGraph + EC=EdgeCollection >(g: &amp;mut G, e: EC::Edge);
```</p>

<p>The other cute insight is this: the only time we need to add these
identifiers explicitly is when there are multiple trait bounds.
When there is a single trait bound <nobr><code>&lt;X:R=T&gt;</code></nobr>, the
identifier <code>X</code> is just as reasonable (or at least unambiguous) as <code>R</code>
is as a way to reference the impl.  So why not treat
<nobr><code>&lt;X:T&gt;</code></nobr> as an abbreviation for <nobr><code>&lt;X:X=T&gt;</code></nobr>:
boom!  The biggest potential complaint with this extension (namely,
the notational complexity of making people pepper their code with
explicit bindings of the impls) goes away!  And our first example becomes:</p>
<div class="highlight"><pre><code class="rust"><span class="k">fn</span> <span class="n">distance</span><span class="o">&lt;</span><span class="n">F</span><span class="o">:</span> <span class="n">Transformation</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">F</span><span class="o">::</span><span class="n">Domain</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="n">F</span><span class="o">::</span><span class="n">Domain</span><span class="p">,</span> <span class="n">f</span><span class="o">:</span> <span class="n">F</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">F</span><span class="o">::</span><span class="n">DistanceType</span><span class="p">;</span>
</code></pre></div>
<p>(our second example remains unchanged, since <code>G</code> has two trait bounds there, and
so <code>G</code> alone cannot unambiguously denote a (type, trait) pair.</p>

<p>Note also that this binding form does not suffice on its own; in
particular, if one wants to introduce a binding for a (type,trait)
pairing that does not appear in the generic parameter bounds of the
signature.  But the latter is exactly the case that <em>is</em> handled by a
declaration form such as those <a href="#thinkbinding">proposed earlier</a>!</p>

<p>So neither solution suffices on its own, but the two together cover
many use cases of interest.</p>

<hr>

<h2 id="toc_10"><a id="proposal">The proposed syntax for associated items in Rust</a></h2>

<p>So, with that insight explained, here is my proposal for associated items:</p>

<ol>
<li><p>A trait can now declare names for things besides methods.
 In terms of the grammar that John has been working on:</p>
<div class="highlight"><pre><code class="text"> trait_decl: TRAIT ident
                (generic_decls)? (COLON trait_list)?
                LBRACE trait_method* RBRACE ;
</code></pre></div>
<p>is replaced with</p>
<div class="highlight"><pre><code class="text"> trait_decl: TRAIT ident
                (generic_decls)? (COLON trait_list)?
                LBRACE trait_item* RBRACE ;
 trait_item: trait_method | trait_constant | trait_type
 trait_type: TYPE ident (generic_decls)? SEMI
           | TYPE ident (generic_decls)? COLON boundseq SEMI ;
 trait_const: STATIC ident COLON ty SEMI ;
</code></pre></div></li>
<li><p>The identifier bound by a trait types is in scope of its enclosing
 trait; trait method declarations and trait const declarations
 can reference it.</p></li>
<li><p>Extend the Rust grammar to allow an optional binding of
 an identifier to a (type, trait) pair in a type parameter bound.
 In terms of the grammar:</p>
<div class="highlight"><pre><code class="text"> bound : STATIC_LIFETIME | trait | obsoletekind ;
</code></pre></div>
<p>is replaced with:</p>
<div class="highlight"><pre><code class="text"> bound : STATIC_LIFETIME | trait | ident = trait | obsoletekind ;
</code></pre></div></li>
<li><p>Extend the Rust grammar to allow a declaration binding 
 an identifier to a (type, trait) pair.
 In terms of the grammar, I <em>think</em> this is close to what I want:</p>
<div class="highlight"><pre><code class="text"> view_item : attrs_vis use ;
</code></pre></div>
<p>is replaced with:</p>
<div class="highlight"><pre><code class="text"> view_item : attrs_vis use | USE impl ident = trait for ty ;
</code></pre></div>
<p>Of potential interest, we do not allow visibility attributes
 on <code>use impl R = T for X;</code>, because these definitions are always
 local shorthands and thus private to the module.  (Maybe in
 the future we will see motivation to allow the bindings to
 be exposed, but I have not yet seen a motivation for this.)</p>

<p>I am not attached to the particulars of the syntax above;
 in particular, if someone wants to throw in the <code>trait</code>
 and/or <code>type</code> keywords into the above to make the purpose
 all the more clear, I will not object.  More so if it is
 somehow <em>necessary</em> for disambiguation, but I do not
 anticipate that being the case.</p></li>
<li><p>A bound of the form <code>R=T</code> (<code>ident = ty</code>) in the context of a <code>ty_param</code>
 production <code>X : ... [] ...</code> (<code>ident COLON bound + ... + [] + ... + bound</code>)
 (where <code>[]</code> denotes the contextual hole that the <code>R=T</code> is plugged into)
 is treated as binding <code>R</code> to the code defined by the <code>impl T for X</code>.
 The scope of the binding for <code>R</code> encompasses: the rest of the boundseq
 (to the right of the <nobr><code>&quot;R=T&quot;</code></nobr>) and the remainder of this decl
 that follows the generic_decls within which the <nobr><code>R=T</code></nobr> bound appears.</p></li>
<li><p>This binding of <code>R</code> can shadow earlier bindings of the same identifier
 (either other impl-bindings, or module names).  It seems like this
 should be a reasonable thing to signal via a lint-warning.</p></li>
<li><p>A path identifier component can now be an <code>R</code>, binding an <code>impl T for X</code>.</p>

<p>So one can access trait items (see trait_item above) as R::item.
 Associated items can be type-parametric whenever the corresponding
 item could be type-parameteric when exported from a module.</p></li>
<li><p>A boundseq with a single bound of variant <code>ty</code> above, where ty is
 itself of the form <code>ident</code> (i.e. the <code>&lt;X:T&gt;</code> case) is implicitly
 expanded into <code>&lt;X:X=T&gt;</code>.</p></li>
</ol>

<hr>

<h2 id="toc_11"><a id="futurework">What the proposal does not cover</a></h2>

<p>There are cases of interest that are not covered by the above proposal.</p>

<p>Most obvious to me are situations where one wants to describe mutual
constraints <em>between</em> the items associated with type parameters.
(An example of this is provided by the <code>gen_orbit</code> example with
the constraint <code>DistanceType(I) = N</code>, and more generally much of the
content of the <code>requires(..)</code> clauses from EOP that I deliberately
ignored).  For the examples from EOP, C++ handles this by doing the
template instantiation blindly and applying the type checker to
code after concrete types have been substituted for the parameters;
this approach is not compatible with Rust&#39;s design where we want to
type-check a generic body of code in terms of the guarantees provided
by the trait-bounds, <em>not</em> delaying those checks until after
the concrete types have been plugged in.</p>

<p>Also, in the changes I proposed above to the Rust grammar (and
somewhat implicitly to its semantics), I deliberately constrained my
focus to the cases Niko described in his blog posts: types, functions,
and constants.  But one might consider further extensions, such as
allowing traits to define <em>other</em> traits.  (I found that subject hard
to wrap one&#39;s mind around, and I wanted to keep the focus limited for
Rust 1.0; we can leave generalizations of this approach for after Rust
1.0.)</p>

<p>Also, I&#39;m not sure whether there is need and/or utility in further
generalizing this topic to <a href="http://www.haskell.org/haskellwiki/GHC/Type_families#An_associated_data_type_example">associated data families</a>.  Again,
I want to limit the scope of the work to something we believe we can
accomplish for Rust 1.0.</p>

<p>What else have I missed?  Let me know, leave a comment.  (Or look
for me in the #rust irc channel.)</p>
]]></content>
  </entry>
  
</feed>
