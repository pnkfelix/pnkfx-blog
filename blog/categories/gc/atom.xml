<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: gc | The {pnk}f(eli)x Blog]]></title>
  <link href="http://blog.pnkfx.org/blog/categories/gc/atom.xml" rel="self"/>
  <link href="http://blog.pnkfx.org/"/>
  <updated>2019-06-28T02:51:58+02:00</updated>
  <id>http://blog.pnkfx.org/</id>
  <author>
    <name><![CDATA[Felix S. Klock II]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GC and Rust Part 2: The Roots of the Problem]]></title>
    <link href="http://blog.pnkfx.org/blog/2016/01/01/gc-and-rust-part-2-roots-of-the-problem/"/>
    <updated>2016-01-01T00:00:00+01:00</updated>
    <id>http://blog.pnkfx.org/blog/2016/01/01/gc-and-rust-part-2-roots-of-the-problem</id>
    <content type="html"><![CDATA[<p>This is the second in a series of posts will discuss why garbage
collection is hard, especially for Rust, and brainstorm about
solutions to the problems we face.</p>

<p>The <a href="/blog/2015/11/10/gc-and-rust-part-1-specing-the-problem/">previous post</a> wrote down some criteria for integration.
Now I want to delve into why satisfying those criteria is hard,
at least in Rust as it stands today.</p>

<!-- more -->




<script>
// See https://github.com/imathis/octopress/issues/424
$(document).ready(function(){
    $('body').addClass('collapse-sidebar');
});
</script>


<p>(The body of this post makes heavy use of client-side rendering,
because of author idiosyncrasies.  You may need to wait a moment while
the supporting Javascript loads.)</p>

<script src="http://blog.pnkfx.org/javascripts/viz.js" charset="utf-8"></script>


<script src="http://blog.pnkfx.org/javascripts/js_to_dot.js" charset="utf-8"></script>


<script src="http://blog.pnkfx.org/javascripts/gc_rendering.js" charset="utf-8"></script>


<a name="Simplifying.Assumptions"></a>
<h2>Simplifying Assumptions</h2>

<p>Let us make some assumptions, so that we can focus on why
this problem is still hard even <em>after</em> being somewhat simplified.</p>

<p>As previously discussed in <a href="http://blog.pnkfx.org/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work/#how-gc-works">the proloque</a>, one can think of the
main program and the GC as <em>coroutines</em>. We will continue with that
mind set.</p>

<p>Let us assume (for now) that the main program will not be running
concurrently with the GC;<label for='&lsquo;no-concurrent-mutation&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;no-concurrent-mutation&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;This </span> or more specifically, the main program
thread(s) will not read or write any GC roots nor GC Heap-allocated
objects concurrently with the GC thread.</p>

<p>In addition, let us assume that in the context of the GC coroutine, no
mutator roots are live values in CPU registers;<label for='&lsquo;no-register-roots&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;no-register-roots&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;This </span>
 in other words, all mutator register values that the GC might care about
will have been saved somewhere in a mutator stack frame
(and will be reloaded from those saved stack slots
before subsequent use by the mutator).</p>

<p>Again, these assumptions are <em>not</em> meant to be interpreted as specific
requirements of Rust&rsquo;s final solution for GC; instead, they describe a
simplified version of &ldquo;the GC integration problem&rdquo; that
I claim is <em>still</em> hard to solve for Rust in general.</p>

<p>Throughout most of this post, I will be discussing various data
structures to support GC activity. When providing concrete examples of
the runtime state, the goal will usually be to represent something analogous
to the following
fragment of an object graph (or some small variant thereof).</p>

<p id="running_example_graph"></p>




<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var rust_heap = { rankdir:"LR", id: "cluster_rust_heap", label: "Rust Heap", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };

var o = object_record("O: StructZ", "<f0> field z (root)");
o.id = "O";
var x = object_record("X1", "...");
var y = object_record("Y", "...");
var x2 = object_record("X2", "...");
x.style = "rounded";
y.style = "rounded";
x2.style = "rounded";

var local_x = { id: "local_x", label: "local x: Gc&lt;X&gt; (root)", shape: "record" };
var local_y = object_record("StructY", "<f0> field y (root)");
var local_o = { id: "local_o", label: "local o = Box(O)", shape: "record" };

stack[1] = local_x;
stack[2] = local_y;
stack[3] = local_o;
local_x.ref = edge_from_to_ports(":e", ":id:nw", x);
local_y.ref = edge_from_to_ports(":f0", ":id", y);
local_o.box = edge_to_port(":id", o);

o.f0 = edge_from_to_ports(":f0", ":id:w", x);
rust_heap[0] = o;

gc_heap[2] = x;
gc_heap[3] = y;
gc_heap[4] = x2;

var objects = [stack, gc_heap, rust_heap];

stack.rank = "same";

post_objects("running_example_graph", objects, { rankdir:"LR", nodesep:0.2, no_dims: true, with_code: false });
</script>


<p>Instances of structured data are
shown with a label<label for='&lsquo;labels-for-presentation&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;labels-for-presentation&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;These </span>
(<code>StructY</code>, <code>O: StructZ</code>, <code>X</code>, <code>Y</code>) that identifies the data and usually includes its type.</p>

<p>Often I will omit the type of a local variable or member (such as with
<code>o</code>, <code>y</code>, and <code>z</code> above). If I want to specify the type, I will do so via
type-ascription
syntax (e.g. <code>x: Gc&lt;X&gt;</code> above), and if I want to specify the particular
value given to a variable, I will use assignment syntax (e.g. <code>o = Box(O)</code> above).
(Note that the assigned value should always be redundant, since there
should also be an arrow linking to the assigned value in these diagrams.)</p>

<p>Values of type <code>Gc&lt;T&gt;</code> hold references to objects allocated on the GC Heap.
Every object on the GC Heap will have a label that is derived from the
type <code>T</code> and, if necessary, a numeric suffix to disambiguate between
multiple instances of <code>T</code> on the GC Heap.</p>

<p>I have denoted the <em>contents</em> of the objects on the GC Heap by
ellipses, because I am focusing in this post
solely on problems related to finding the roots;
the contents of the objects referenced by the roots, and the remaining
transitively reachable objects beyond them, are not important to us today.</p>

<p>Objects allocated on the Rust Heap will tend to be boxes owned by
values of type <code>Box&lt;T&gt;</code>; they will have an identifying label and the
type of the contents (e.g. <code>O: StructZ</code> above).</p>

<p>I will tend to present examples of structured data with trivial
structs that have one field; e.g. <code>StructY</code> has a single field <code>y</code>,
and likewise <code>StructZ</code> has just the field <code>z</code>. (Of course in real
programs there will be structs and arrays with multiple members, but single field
structs simplifies the diagrams here.)</p>

<a name="Rust.complicates.Root.Identification"></a>
<h2>Rust complicates Root Identification</h2>

<p>At some point, probably in response to a memory allocation request,
the GC is going to initiate a collection.</p>

<p>That requires traversing the root set of the main program, since those
roots will be the kernel that the GC uses to identify the reachable
objects.</p>

<p>What are the options for traversing the root-set?</p>

<a name="Do.we.need.to.solve.this.problem."></a>
<h3>Do we need to solve this problem?</h3>

<p>One approach is to &ldquo;define away the problem&rdquo;; one version of this I
<a href="#Interoperation.with.a..black.box..GC">previously described</a> is to
hide the root-set itself inside the black-box abstraction
that we are interoperating with, and expose only handles that
point to the roots.</p>

<p id="target_anchor_black_box_gc_1" class="fullwidth"></p>


<p>The key principle in this picture is that the GC is meant to be
completely isolated from the state of the main program; when it does a
collection, the GC just starts from the root-set hidden within the
<code>handles</code> in the GC-heap. It does not inspect any state in the boxes
labelled &ldquo;Stack&rdquo; nor &ldquo;Rust Heap.&rdquo;</p>

<p>But a big problem with this, that I failed to stress in my earlier
post, is that you now need to <em>manage</em> the hidden-root set stored in
the <code>handles</code> array.</p>

<p>In particular, in the above picture, every entry in <code>handles</code> maps to
exactly one <code>Handle</code> value on the &ldquo;Stack&rdquo; or &ldquo;Rust Heap.&rdquo; This leads
to some troubling questions.</p>

<ul>
<li><p>What happens when you clone the box referenced by the local variable <code>o</code>: does that need to create a new entry in the hidden <code>handles</code> array?</p></li>
<li><p>How about if you instead dropped <code>o</code> &ndash; does that clear the <code>handles</code> entry at index 2?</p>

<ul>
<li><p>If not, when/how will the root set be updated appropriately?</p></li>
<li><p>If so, are previously cleared entries reused? If so, how do you determine whether an entry is available for reuse &ndash; do you keep a mark-bit on each handle?</p></li>
</ul>
</li>
<li><p>This handle array maintenance sounds expensive, maybe
we should instead periodically scan the stack to look for pointers to handles &hellip;</p></li>
</ul>


<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
Just to be clear: the joke here is that we are basically
suggesting layering our own semi-automated memory management system
on top of a third-party automated memory management system. We should be striving to
<em>reduce</em> our problems to smaller subproblems, not <em>reproducing</em> them.
</span>
&hellip; maybe we should rethink our overall approach here.</p>

<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var rust_heap = { rankdir:"LR", id: "cluster_rust_heap", label: "Rust Heap", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };
var handles = object_record("handles", "<h2> Y | <h1> X | <h3> X");

var c = object_record("C", "<f0> Gc(X) | <f1> Box(O)");
c.style = "rounded";
var o = object_record("O: StructZ", "<f0> field z = Handle(2)");
o.id = "O";
var x = object_record("X", "...");
var y = object_record("Y", "...");
x.style = "rounded";
y.style = "rounded";
var local_x = { id: "local_x", label: "local x = Handle(1)", shape: "record" };
var local_y = { id: "local_y", label: "StructY | <f0> field y = Handle(0)", shape: "record" };
var local_o = { id: "local_o", label: "local o = Box(O)", shape: "record" };

o.f0 = edge_from_to_ports(":f0", ":h3", handles);

c.f0 = edge_from_to_ports(":f0", ":id", x);
c.f1 = edge_from_to_ports(":f1", ":id", o);

stack[1] = local_x;
stack[2] = local_y;
stack[3] = local_o;

rust_heap[0] = o;
gc_heap[0] = handles;
handles.x1 = edge_from_to_ports(":h1", ":id", x);
handles.y2 = edge_from_to_ports(":h2", ":id", y);
handles.x3 = edge_from_to_ports(":h3", ":id:sw", x);
local_x.handle = edge_to_port(":h1", handles);
local_y.handle = edge_from_to_ports(":f0", ":h2", handles);
local_o.box = edge_to_port(":id", o);
gc_heap[2] = x;
gc_heap[3] = y;

var objects = [stack, gc_heap, rust_heap];
post_objects("target_anchor_black_box_gc_1", objects, { rankdir:"LR", nodesep:0.2, no_dims: true });
</script>


<a name="Scanning.the.Mutator.State"></a>
<h3>Scanning the Mutator State</h3>

<p>So let&rsquo;s assume we are <em>not</em> dealing with a complete black box;
instead, the main program (aka &ldquo;the mutator&rdquo;) and the GC are going
to collaborate in some more fundamental way.</p>

<p>In other words, let&rsquo;s assume that roots are allowed to leak outside of
the GC Heap and into the mutator; no more black-box.</p>

<p>Once we have roots floating around under the control of the mutator,
we need to talk about identifying those roots by inspecting/querying the mutator
state.</p>

<p>Some relevant issues to consider on this topic:</p>

<ul>
<li><p>Are all roots <em>precisely</em> identified as roots?</p></li>
<li><p>Where can the roots reside in the mutator? (Frames on the stack? Boxes on the Rust Heap?)</p></li>
<li><p>How is the GC informed about the location of the roots in the mutator?</p></li>
<li><p>How does the mutator itself access the roots?</p></li>
<li><p>What information might the mutator maintain on the behalf of the GC?</p></li>
<li><p>Might a given root&rsquo;s value (i.e. the address of the referenced
object on the GC Heap) be changed by the GC during the collection
(in other words, does the GC rule out <a href="http://blog.pnkfx.org/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work/#pinning-support">pinning</a>)?</p></li>
</ul>


<p>Let&rsquo;s explore some of the problems associated with these
questions, especially how it relates to Rust.</p>

<a name="Are.roots.precisely.identified."></a>
<h2>Are roots precisely identified?</h2>

<p>The roots are somewhere in mutator-managed memory.
The GC will need to know the values held in those roots,
and possibly will need to update those values if the referenced
objects are moved in memory.</p>

<p>There are two basic options for root scanning: conservative or precise.</p>

<p>A <em>conservative</em> scan is needed when some of the values
might hold an actual root, but might also hold a false-positive.</p>

<p>This arises when, for example, there is not enough type information
available<label for='&lsquo;avail-types&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;avail-types&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;&ldquo;Not </span>
to know that a scanned word is meant to be interpreted by the mutator as an object
reference.</p>

<p>If there are any conservatively-scanned roots, the GC needs to
validate their values (e.g. by checking if it lies within one of the
ranges of addresses used for the objects allocated on the GC Heap),
and trace any object potentially referenced by such values.</p>

<p>An earlier discussion on &ldquo;<a href="http://blog.pnkfx.org/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work/#pinning-support">pinning</a>&rdquo; established that any object
referenced by a conservatively scanned root
cannot be moved by the GC.
Therefore, integrating with a GC that does not support object pinning
(such as a fully-copying collector)
will require we scan the roots precisely, not conservatively.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
One problem with ensuring that a word on the stack is precisely identified
is that it requires close cooperation with the compiler backend.
E.g. if the backend (LLVM in the case of <code>rustc</code>) is permitted to reuse a stack
slot for two values of different types (and disjoint extents) then
we need to take care that the GC knows whether the current value in that slot
is or is not a GC reference.
(LLVM is a very expressive backend, so it provides mechanisms to account for this scenario, but it is not automatic.)
</span>
A given word in memory can be <em>precisely</em> scanned
if we ensure that the root&rsquo;s location in memory is
unambiguously interpreted by the mutator as an object reference.
I will say that such a root can be
&ldquo;unambiguously classified&rdquo; only if such assurance is established.</p>

<p>Often the ability to classify a root unambiguously is derived from
static types, runtime type information, and global system invariants.</p>

<p>Where the roots might reside influences the design space for
unambiguous classification quite a bit.
For example, if all roots are members of heap-allocated objects, then
the allocator might embed a type-tag in the header of such an object,
or segregate objects into disjoint regions of memory based on that
type.</p>

<p>Therefore, we will explore the question of where roots reside next.</p>

<a name="Where.are.the.roots."></a>
<h2>Where are the roots?</h2>

<p>There are two components to the question &ldquo;where are the roots?&rdquo;:</p>

<ul>
<li><p>Where can roots <em>possibly</em> reside?</p></li>
<li><p>Where do the roots <em>actually</em> reside?</p></li>
</ul>


<p>The first bullet is a question about the system as a whole; it is a
question that we must answer as designers.</p>

<p>The second bullet is about encoding how the GC will look up the memory
addresses of the roots (potentially with the mutator&rsquo;s help) every
time it wants to initiate a root scan.</p>

<p>The two parts interact with each other, so we will address them both
somewhat simultaneously.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
This list is leaving out some other options,
such as <em>completely unconstrained</em>, where roots might live in memory
unknown to the both the GC and Rust runtime (I do not see a way this first option could work without
requiring programmers to instrument foreign code with calls to root registration
and deregistration functions),
or keeping the roots solely on a <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.5570">shadow stack</a>
with structure isomorphic to the actual stack, but not vulnerable
to disruption due to compiler code transformations (I am omitting
this second option since it is known to carry a significant performance penalty).
</span></p>

<p>Consider these options for locations where roots can reside:</p>

<ol>
<li><p><em>Constrained To Boxed Values</em>:
 Solely found embedded in boxed values on the Rust Heap.</p></li>
<li><p><em>Constrained To Stack</em>:
 Stored solely on the program stack, and</p></li>
<li><p><em>Rust-Managed But Otherwise Unconstrained</em>:
 Stored either on the stack or embedded in boxed values on Rust Heap.</p></li>
</ol>


<a name="Roots.Constrained.To.Boxed.Values..Option.1."></a>
<h3>Roots Constrained To Boxed Values (Option 1)</h3>

<p>If roots are <em>solely</em> stored in members of boxed values, then we might
store runtime-type metadata in an allocator-injected header.</p>

<p>This option is seductive: Adding a header via the runtime system&rsquo;s
<code>#[allocator]</code> crate could sidestep a significant amount of compiler
integration (maybe even all of it).</p>

<p>There are some interesting ideas to explore from that starting point,
such as collecting all such boxed values together in a linked list
whose head is known to the GC (and thus the answer to &ldquo;how does the
GC scan the roots?&rdquo; is just &ldquo;it walks the list&rdquo;<label for='&lsquo;list-maintenance&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;list-maintenance&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;Do </span>).</p>

<p>However,
constraining roots to solely live in members of boxed
values may not be feasible in Rust as it stands today.
For example, one is always free to move the instance of <code>T</code> out of a
<code>Box&lt;T&gt;</code>, deallocating the backing storage but moving the <code>T</code> into
another location, such as a stack-allocated local variable.</p>

<p>Let&rsquo;s look at the remaining two
approaches.</p>

<a name="Roots.Constrained.To.Stack..Option.2."></a>
<h3>Roots Constrained To Stack (Option 2)</h3>

<p>If roots can be stored directly on the stack (i.e. options 2 or 3 above),
then when the GC initiates a root scan, it will need to find those
roots.</p>

<p>This search of the stack can be guided by
&ldquo;stack maps&rdquo;:<label for='&lsquo;stack' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;stack' class='margin-toggle'/><span class='sidenote'>maps&rsquo; </span>
compiler-generated metadata providing a mapping from a
code address<label for='&lsquo;code-address&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;code-address&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;This </span>
to the set of stack slots<label for='&lsquo;stack-map-slot&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;stack-map-slot&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;More </span>
that hold values of interest.</p>

<p>However, restricting the roots to live solely on the stack may be
problematic for much the same reason that plagues the earlier idea of
restricting roots to boxed values: in Rust today, one is always free
to move instances of <code>T</code> from a stack-local slot into a member of a
boxed value.</p>

<p>In some circumstances, we might be able to counteract these
&ldquo;freedom of movement&rdquo; issues in a backwards-compatible manner with a compiler
plugin (lint) that analyzes the source and trys to flag any code might move a root
into an illegal location. (<a href="https://servo.org/">Servo</a> already uses <a href="https://blog.mozilla.org/research/2014/08/26/javascript-servos-only-garbage-collector/#custom-static-analysis">a lint like this</a>
for its integration with the Spidermonkey GC.)</p>

<p>Or, if we are willing to extend the language itself,
we might add marker trait <code>Immobile</code> that indicates
that values of such type <em>cannot</em> be
moved.<label for='&lsquo;hunh-moved&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;hunh-moved&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;Proper </span></p>

<p>But either of those options are just ways of enforcing a restriction,
and it will outlaw certain kinds of program composition.<label for='&lsquo;vec-composition&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;vec-composition&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;An </span></p>

<p>In practice, we simply may be better off lifting such restrictions
entirely. So, let us now consider our remaining option:
allowing roots to be embedded in values on the stack or boxed on the Rust Heap.</p>

<a name="Roots.are.Rust-Managed..But.Otherwise.Unconstrained..Option.3."></a>
<h2>Roots are Rust-Managed, But Otherwise Unconstrained (Option 3)</h2>

<p>Now we come to what is probably the most realistic option for Rust/GC integration:
allowing roots to reside anywhere that the Rust compiler or runtime knows about.</p>

<p>Arguably, I might well have <em>started</em> this discussion with this
approach, since it is by definition the most general of the three, and
thus if we <em>do</em> have a solution for it, then why not jump to it?</p>

<p>The reason I left it for last is that I suspect any design we adopt
for GC integration in Rust 1.x is going to require a hybrid of the
approaches described in the prior two sections (allocator-injected
metadata <em>and</em> stack maps), and therefore I wanted to outline them in
isolation, before I started mixing them together.</p>

<a name="GC:..Where.are.the.roots....Mutator:......"></a>
<h2>GC: &ldquo;Where are the roots?&rdquo;, Mutator: &ldquo;&hellip;&rdquo;</h2>

<p>If we assume that roots can be embedded in values either on the stack
or in boxes on the Rust Heap, then how will the GC find the roots when
it needs to scan them?</p>

<p>The support for the GC&rsquo;s root scanning capability can be seen as having three parts:</p>

<ol>
<li><p>What work does the GC itself do, on the fly, to determine the roots
when it needs them,</p></li>
<li><p>What work does the mutator do (if any) as it executes the
program<label for='&lsquo;mutator-work&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;mutator-work&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;&ldquo;Mutator </span>
to support a potential root scan by the GC in a future, and,</p></li>
<li><p>What meta-data must be gathered and emitted by the compiler
to support root-scanning?</p></li>
</ol>


<p>One idea for enabling easy GC root traversal was mentioned earlier:
why not collect the roots together in a linked list structure?
Towards this goal, we might
consider maintaining an intrusive
 links forming a list of all roots.</p>

<p id="intrusive_list_of_roots"></p>




<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var rust_heap = { rankdir:"LR", id: "cluster_rust_heap", label: "Rust Heap", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };

var o = object_record("O: StructZ", "<f0> field z (root) | <next> next_root = null");
o.id = "O";
var x = object_record("X", "...");
var y = object_record("Y", "...");
x.style = "rounded";
y.style = "rounded";

var local_x = object_record("local_x", "<f0> (root) | <next> next_root");
var local_y = object_record("StructY", "<f0> field y (root) | <next> next_root");
var local_o = { id: "local_o", label: "local o = Box(O)", shape: "record" };

stack[1] = local_x;
stack[2] = local_y;
stack[3] = local_o;

local_x.ref = edge_from_to_ports(":f0", ":id", x);
local_y.ref = edge_from_to_ports(":f0", ":id", y);
local_o.box = edge_to_port(":id", o);

o.f0 = edge_from_to_ports(":f0", ":id:sw", x);
rust_heap[0] = o;

gc_heap[2] = x;
gc_heap[3] = y;

root_head = object_record("roots", "<next> next_root");
var anonymous_xy = {id: "anonymous_xy", style:"invis", shape: "point"};

// gc_heap[0] = root_head;

root_head.next = edge_from_to_ports(":next", ":f0", local_x);
local_x.next = edge_from_to_ports(":next", ":f0", anonymous_xy);
local_x.next.arrowhead = "none";

anonymous_xy.ref = edge_to_port(":f0:w", local_y);
local_y.next = edge_from_to_ports(":next", ":f0", o);

// anonymous_yx.ref.constraint = "false";
// anonymous_yx.ref.arrowhead = "none";

stack.rank = "same";

// root_head.presentation = invisible_edge(anonymous_yx);
// local_y.presentation = invisible_edge(local_x);
// local_x.presentation = invisible_edge(anonymous_xy);
// stack[4] = anonymous_yx;

var objects = [stack, gc_heap, rust_heap, root_head];
post_objects("intrusive_list_of_roots", objects, { rankdir:"LR", nodesep:0.2, no_dims: true, with_code: false });
</script>


<p>This is an <em>intrusive</em> list because the pointers in the list are
pointing into the interiors of objects. This allows traversing the
list to be completely uniform (from the viewpoint of the GC,
it looks like nothing more than a linked list of pairs).
In this scenario, the GC does essentially <em>zero</em> work on-the-fly
to find the locations of the roots;
maintaining the list would become the reponsibility of the mutator as
it creates and moves values with embedded roots.</p>

<p>However, Rust today does not have good support for intrusive data structures (<a href="https://github.com/rust-lang/rfcs/issues/417">RFC Issue 417</a>).
The already-mentioned capability to move values freely, as well as the
capability to swap a pre-existing <code>T</code> with the value held beind a
<code>&amp;mut T</code> reference, are among the reasons that intrusive structures
are difficult today, since it changes the addresses associated
with objects, and thus requires updating of the interior links.</p>

<p>So, what other options do we have?</p>

<p>Having the GC traverse the memory of the call-stack, even with the assistance of a stack map
to provide precise type information, will not give us the locations of all the roots,
since some are located on the Rust Heap. A stack map cannot hold the addresses of the blocks
of memory dynamically allocated for a box on the heap.</p>

<p>However, the stack map <em>can</em> hold the type information for the local
variables, and that sounds promising: If we record that a local
variable <code>o</code> has type <code>Box&lt;Struct&gt;</code>, then treat the contents of the
box on the heap as owned by the stack, so that when we encounter <code>o</code>
during the stack scan, we can recursively scan the memory of the box,
using the type <code>Struct</code> to inform the scan about how to treat each of
the embedded members.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
I have slightly modified the running example to show two instances
of the local <code>x</code> on the call-stack in separate frames, each corresponding
to a distinct (recursive) invocation of the function <code>fn f</code>.
<br></br>
This is just to bring home the point that the stack map info encodes
static information about the frame for a function (at a particular call-site),
and thus recursive invocations of the same function can potentially
reuse the same entry in the stack map.
</span></p>

<p id="stack_map_boxes"></p>




<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var rust_heap = { rankdir:"LR", id: "cluster_rust_heap", label: "Rust Heap", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };

var frame0 = { id: "cluster_frame0", label: "frame0: fn f()", is_subgraph: true };
var frame1 = { id: "cluster_frame1", label: "frame1: fn g()", is_subgraph: true };
var frame2 = { id: "cluster_frame2", label: "frame2: fn h()", is_subgraph: true };
var frame3 = { id: "cluster_frame3", label: "frame3: fn f()", is_subgraph: true };

var o = object_record("O: StructZ", "<f0> field z (root) = Gc(X1)");
o.id = "O";
var x  = object_record("X1", "...");
var x2 = object_record("X2", "...");
var y = object_record("Y", "...");
x.style = "rounded";
x2.style = "rounded";
y.style = "rounded";

var local_x = { id: "local_x1", label: "local x (root) = Gc(X1)", shape: "record" };
var local_x2 = { id: "local_x2", label: "local x (root) = Gc(X2)", shape: "record" };

var local_y = object_record("StructY", "<f0> field y (root) = Gc(Y)");
var local_o = { id: "local_o", label: "local o = Box(O)", shape: "record" };

frame0[0] = local_x;
frame1[0] = local_y;
frame2[0] = local_o;
frame3[0] = local_x2;

// frame3[0].ref = { is_edge: true, target: frame2[0], ltail: frame3.id, lhead: frame2.id, constraint: false };
// frame2[0].ref = { is_edge: true, target: frame1[0], ltail: frame2.id, lhead: frame1.id, constraint: false };
// frame1[0].ref = { is_edge: true, target: frame0[0], ltail: frame1.id, lhead: frame0.id, constraint: false };

stack[0] = frame0;
stack[1] = frame1;
stack[2] = frame2;
stack[3] = frame3;

local_x.ref = edge_to_port(":id:nw", x);
local_x2.ref = edge_to_port(":id:sw", x2);
local_y.ref = edge_from_to_ports(":f0", ":id", y);
local_o.box = edge_to_port(":id", o);

o.f0 = edge_from_to_ports(":f0", ":id:w", x);
rust_heap[0] = o;

gc_heap[2] = x;
gc_heap[3] = y;
gc_heap[4] = x2;

var objects = [stack, gc_heap, rust_heap];

stack.rank = "same";

post_objects("stack_map_boxes", objects, { rankdir:"LR", nodesep:0.2, compound: true, no_dims: true, with_code: false });
</script>


<p>The principle is that when control shifts to the GC coroutine,
it walks through the stack backtrace, consulting the stack
map for each callsite.</p>

<pre><code>stack_map_info for callsite 0x0010_ABBA in fn f:
  local x:
    offset: [...]
    type: Gc&lt;X&gt;

stack_map_info for callsite 0x0020_BACA in fn g:
  local _:
    offset: [...]
    type: StructY

stack_map_info for callsite 0x0030_C0C0 in fn h:
  local o:
    offset: [...]
    type: Box&lt;StructZ&gt;
</code></pre>

<p>From the stack map, it finds the offsets of relevant local variables
within that stack frame, and the type information for those locals, so
that it knows when it needs to dereference an pointer to inspect a
block on the Rust Heap (such as the <code>Box(O)</code> in our running example).</p>

<p>The GC will need separate meta-data describing the layout of each
type, with the offset and type of each field of interest:</p>

<pre><code>type_map_info for type StructY:
  field y:
    offset: [...]
    type: Gc&lt;Y&gt;

type_map_info for type Box&lt;StructZ&gt;:
  field 0:
    offset: [...]
    type: StructZ

type_map_info for type StructZ:
  field z:
    offset: [...]
    type: Gc&lt;X&gt;
</code></pre>

<p>The boxed objects may themselves own other root-holding objects on the Rust Heap,
like so:</p>

<p id="nested_stack_map_boxes" class="fullwidth"></p>




<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var rust_heap = { rankdir:"LR", id: "cluster_rust_heap", label: "Rust Heap", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };

var frame0 = { id: "cluster_frame0", label: "frame0: fn f()", is_subgraph: true };
var frame1 = { id: "cluster_frame1", label: "frame1: fn g()", is_subgraph: true };
var frame2 = { id: "cluster_frame2", label: "frame2: fn h()", is_subgraph: true };
var frame3 = { id: "cluster_frame3", label: "frame3: fn f()", is_subgraph: true };

var o = object_record("O: StructB", "<f0> field b (root) = Box(Z)");
o.id = "O";
var b = object_record("Z: StructZ", "<f0> field z (root) = Gc(X1)");
b.id = "B";
var x  = object_record("X1", "...");
var x2 = object_record("X2", "...");
var y = object_record("Y", "...");
x.style = "rounded";
x2.style = "rounded";
y.style = "rounded";

var local_x = { id: "local_x1", label: "local x (root) = Gc(X1)", shape: "record" };
var local_x2 = { id: "local_x2", label: "local x (root) = Gc(X2)", shape: "record" };

var local_y = object_record("StructY", "<f0> field y (root) = Gc(Y)");
var local_o = { id: "local_o", label: "local o = Box(O)", shape: "record" };

frame0[0] = local_x;
frame1[0] = local_y;
frame2[0] = local_o;
frame3[0] = local_x2;

// frame3[0].ref = { is_edge: true, target: frame2[0], ltail: frame3.id, lhead: frame2.id, constraint: false };
// frame2[0].ref = { is_edge: true, target: frame1[0], ltail: frame2.id, lhead: frame1.id, constraint: false };
// frame1[0].ref = { is_edge: true, target: frame0[0], ltail: frame1.id, lhead: frame0.id, constraint: false };

stack[0] = frame0;
stack[1] = frame1;
stack[2] = frame2;
stack[3] = frame3;

local_x.ref = edge_to_port(":id:w", x);
local_x2.ref = edge_to_port(":id:sw", x2);
local_y.ref = edge_from_to_ports(":f0", ":id", y);
local_o.box = edge_to_port(":id", o);

o.f0 = edge_from_to_ports(":f0", ":id:w", b);
b.f0 = edge_from_to_ports(":f0", ":id:nw", x);
rust_heap[0] = o;
rust_heap[1] = b;

gc_heap[2] = x;
gc_heap[3] = y;
gc_heap[4] = x2;

var objects = [stack, gc_heap, rust_heap];

stack.rank = "same";

post_objects("nested_stack_map_boxes", objects, { rankdir:"LR", nodesep:0.2, compound: true, no_dims: true, with_code: false });
</script>


<p>To find all the roots starting from the stack
in the presence of such ownership chains
(which may go through other types like <code>Vec</code>),
the GC will need to recursively traverse the boxes,
or otherwise enqueue them onto a worklist structure.
In principle, if we can prove that certain types never
transitively own roots, then the GC should be able to skip traversing
boxed data for such types.</p>

<p>Using the stack map and type map data to find all roots transitively
owned by the stack is a promising approach. What is the catch, if any?</p>

<a name="Unsafe.Pointers"></a>
<h2>Unsafe Pointers</h2>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
The <code>from_raw</code> method that converts a <code>*mut T</code> to <code>Box&lt;T&gt;</code>
is unsafe, but <code>into_raw</code> is a safe method. Safe code
can always convert a <code>Box&lt;T&gt;</code> to a <code>*mut T</code>, and clients
expect it to also be reasonable to round-trip via <code>from_raw</code>.
</span>
What should we do about unsafe pointers <code>*mut T</code> and <code>*const T</code>.
For example, it is not uncommon for library code to convert
boxed data <code>Box&lt;T&gt;</code> to a <code>*mut T</code> or vice versa;
that is an ownership transfer.</p>

<p>I used <code>local o = Box(O)</code> above (where <code>o: Box&lt;StructB&gt;</code>),
but it is entirely possible that <code>o</code> has type <code>*mut StructB</code>.</p>

<p>Here are some options for how to handle unsafe pointers:</p>

<ul>
<li><p>Skip unsafe pointers during root scanning.</p>

<p>This seems almost certain to cause unsound behavior; as noted above,
transmuting <code>Box&lt;T&gt;</code> to <code>*mut T</code> is an ownership transfer, and if
<code>T</code> holds a root, then later code might access it. This means that
the roots owned by <code>T</code> need to be scanned, to keep their associated
objects on the GC Heap alive.</p></li>
<li><p>Punt the question: if a program uses GC, any use of unsafe pointers
(as local variables or as members of structures) needs some sort of
attribute or annotation that tells the GC how to interpret the value
held in the unsafe pointer.</p>

<p>This would be quite difficult to put into practice. <a href="/blog/2015/11/10/gc-and-rust-part-1-specing-the-problem/">Part 1</a>
included a <a href="/blog/2015/11/10/gc-and-rust-part-1-specing-the-problem/#modularity">&ldquo;Modularity&rdquo; goal</a>:</p>

<blockquote><p>A Rust program that uses GC should be able to link to a crate
whose source code was authored without knowledge of GC.</p></blockquote>

<p>Requiring annotations on
every use of unsafe pointers means sacrificing this goal.</p></li>
<li><p>Treat unsafe pointers as potential root owners: Traverse them
and use their type as the basis for the scan.</p>

<p>This seems like the most reasonable option. But, can the types
of unsafe pointers be trusted?</p></li>
</ul>


<a name="Is.the.meta-data.trustworthy."></a>
<h2>Is the meta-data trustworthy?</h2>

<p>We assumed the existence of stack and type maps.
But where do they come from?</p>

<p>These maps need to be generated by the <code>rustc</code> compiler; after all,
they rely on low-level details of the generated code, such as the
offsets of fields within types, the offsets of local variables in a
stack frame, or the addresses of function call-sites.</p>

<p>The <code>rustc</code> compiler, in turn, is going to generate the information
based on the source code text. So far, so good.</p>

<p>Here&rsquo;s the rub: we assumed that the stack map will tell us the types
we need for all local variables of interest for all frames on the call
stack.</p>

<p>But in practice, a value can be <em>cast</em> to a different type.</p>

<p>In particular, in today&rsquo;s Rust 1.x, it is considered <em>safe</em> to cast
between <code>*mut T</code> and <code>*mut U</code> for any <code>T</code> and <code>U</code>:</p>

<pre><code class="rust">fn main() {
    let b = Box::new("peanut butter"); // (imagine if this held rooted data)
    let mut p = Box::into_raw(b);
    let pb = p as *mut String; // bogus type, but safe
    p = Box::into_raw(Box::new("jelly"));
    // this is where a potential GC would be worrisome
    println!("p: {:?} p2: {:?}", p, pb);

    // (just demonstrating recovery of original value via unsafe code)
    let pb = pb as *mut &amp;'static str;
    let recover = unsafe { Box::from_raw(pb) };
    println!("recovered: {:?}", recover);
}
</code></pre>

<p>This is a real problem, in terms of the goals we have set up for ourselves.
100% modular GC requires that we be able to link with code that does things
like the above with the owners of its roots, and that includes when the roots
are indirectly held in boxes on the Rust Heap.</p>

<p>We may be able to add constraints on the <code>Gc&lt;T&gt;</code> type to prevent such things
from occurring when the types are apparent (e.g. when one is working with a
local variable of type <code>Gc&lt;T&gt;</code>). But in general, the types will
not be apparent to the code performing the cast; in particular,
we would still need to address type-parametric code that performs
such casts of unsafe pointers.</p>

<a name="Solutions"></a>
<h2>Solutions</h2>

<p>What can we do about these problems?</p>

<p>One obvious response to the untrustworthy meta-data problem would be to change the language and make casts from <code>*T</code> to <code>*U</code>
<em>unsafe</em>.<label for='&lsquo;unsafe-casts&rsquo;' class='margin-toggle sidenote-number'></label><input type='checkbox' id='&lsquo;unsafe-casts&rsquo;' class='margin-toggle'/><span class='sidenote'>&lsquo;Indeed, </span>
 This would deal with the problem at a surface level, in the sense that
we would be able to at least allow a program using GC to link to a
GC-oblivious crate if the latter crate did not use any <code>unsafe</code>
blocks.
But it would not be terribly satisfactory; we want Rust&rsquo;s
solution for GC to be able to link to as many crates as possible, and
ruling out all code that does any cast of an unsafe pointer seems quite limiting.</p>

<p>We could also revise the set of goals, e.g. scale back our ambitions
with respect to compositionality, and return to ideas like having the
roots constrained to stack, as <a href="#Roots.Constrained.To.Stack..Option.2.">discussed above</a>.</p>

<p>An alternative solution I have been considering is to try to adopt a
hybrid approach for root scanning: use stack maps for the local
variables, but also have the allocator inject tracing meta-data onto
the objects allocated on the Rust Heap, and do a kind of conservative
scanning, but <em>solely</em> for finding roots embeded in objects on the
Rust Heap. This way, unsafe casts might become irrelevant: when
encountering <em>any</em> native pointer (e.g. <code>*mut u8</code>), we would ignore
the referenced type and instead look up whether it is an object on the
Rust Heap, and if so, extract the allocator-injected tracing
information.</p>

<p>I plan to dive more deeply into discussing solutions in a follow-up post.
This post is already quite long, but more importantly, I want to get some
concrete data first on the overheads imposed by the metadata injected during
allocation in state of the art conservative GC&rsquo;s like <a href="http://www.hboehm.info/gc/">BDW</a>.</p>

<hr />

<p>Oh, and finally (but completely unrelated): Happy 2016 to all the hackers out there!
Hope that you copied over all your live objects from 2015!</p>

<script>
// ## References
//
// * [On LLVM’s GC Infrastructure][on-llvms-gc]
//
// * [Compiler Support for Garbage Collection in a Statically Typed Language][diwan-moss-hudson]
</script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GC and Rust Part 1: Specifying the Problem]]></title>
    <link href="http://blog.pnkfx.org/blog/2015/11/10/gc-and-rust-part-1-specing-the-problem/"/>
    <updated>2015-11-10T17:45:00+01:00</updated>
    <id>http://blog.pnkfx.org/blog/2015/11/10/gc-and-rust-part-1-specing-the-problem</id>
    <content type="html"><![CDATA[<p>This is the first in a series of posts will discuss why garbage
collection is hard, especially for Rust, and brainstorm about
solutions to the problems we face.</p>

<p>The relationship between garbage collection (GC) and the Rust
programming language has been an interesting one.</p>

<p>GC was originally deeply integrated into the language, complete with
dedicated syntax (good old <code>@T</code> &hellip;). Over time the team found ways to
lessen the dependency on GC, and then finally remove it from the
language entirely.</p>

<p>However, we still want to provide support for garbage collection.</p>

<p>To explain why, I need to define the actual problems we seek to solve.
So let us explore the problem space.</p>

<!-- more -->


<a name="L.....now.you.have..nyh..two.problems"></a>
<h1>&hellip; <a href="http://regex.info/blog/2006-09-15/247">now you have</a> two problems</h1>

<p>(The body of this post makes heavy use of client-side rendering,
because of author idiosyncrasies.  You may need to wait a moment while
the supporting Javascript loads.)</p>

<script src="http://blog.pnkfx.org/javascripts/viz.js" charset="utf-8"></script>


<script src="http://blog.pnkfx.org/javascripts/js_to_dot.js" charset="utf-8"></script>


<script src="http://blog.pnkfx.org/javascripts/gc_rendering.js" charset="utf-8"></script>


<a name="The.Problem.Space"></a>
<h2>The Problem Space</h2>

<p>Now that we have <a href="/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work/">reviewed</a> what GC is and how it works, let us
discuss what GC could mean to Rust.</p>

<p>I have identified two distinct kinds of support that we could provide:
&ldquo;GC&rdquo; could describe a feature for pure Rust programs, or &ldquo;GC&rdquo; could mean a
3rd-party runtime interoperation feature. Let us discuss each in turn.</p>

<a name="One.GC.shared.by.every.crate"></a>
<h3>One GC shared by every crate</h3>

<p>We could add a smart-pointer to <code>libstd</code>, e.g. a <code>Gc&lt;T&gt;</code> type, that
arbitrary library crates could use as they create or receive instances
of <code>T</code>. The intention here would be similar to how <code>Rc&lt;T&gt;</code> is used:
One does not want to track ownership precisely, but rather treat
ownership as shared amongst all users of a value, and let the runtime
system handle reclaiming the value.</p>

<p>So for example, we might want to write code that looks like this:</p>

<pre><code class="rust">use std::gc::Gc;

struct Cons&lt;T&gt; {
    head: T,
    tail: Cell&lt;Option&lt;Gc&lt;Self&gt;&gt;&gt;,
}

impl&lt;T&gt; Cons&lt;T&gt; {
    fn new(head: T, tail: Option&lt;Gc&lt;Self&gt;&gt;) -&gt; Self {
        Cons { head: head, tail: Cell::new(tail) }
    }
    fn head(&amp;self) -&gt; &amp;T { &amp;self.head }
    fn tail(&amp;self) -&gt; Option&lt;Gc&lt;Self&gt;&gt; { self.tail.get() }
}

#[test]
fn demo() {
    let a;
    let f: Gc&lt;_&gt;;
    {
            a = box Cons::new(1, None);
        let b = box Cons::new(2, Some(a));
        let c = box Cons::new(3, Some(a));
        let d = box Cons::new(4, Some(b));
        let e: Gc&lt;_&gt;;
            e = box Cons::new(a, Some(b));
            f = box Cons::new(c, Some(d));

        let mut g = box Cons::new(10, None);
        let     h = box Cons::new(20, Some(g));
        g.tail.set(Some(h));
    }
    // here, locals `a` and `f` are the roots
}
</code></pre>

<p>(The above snippet assumes we have extended <code>box EXPR</code> to an
overloaded operator in the manner similar to that described in
<a href="https://github.com/rust-lang/rfcs/blob/master/text/0809-box-and-in-for-stdlib.md">RFC 809</a>, so that <code>let g: Gc&lt;_&gt; = box EXPR;</code> works, and that
the type inference figures out that all the locals need to be
in <code>Gc&lt;_&gt;</code>.)</p>

<p>This results in a stack and heap modelled by this picture.</p>

<p id="target_anchor_gc_demo_1" class="fullwidth"></p>


<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };
var a = object_record("A", "<head> head: 1 | <tail> tail: None");
var b = object_record("B", "<head> head: 2 | <tail> tail: Some(A)");
var c = object_record("C", "<head> head: 3 | <tail> tail: Some(A)");
var d = object_record("D", "<head> head: 4 | <tail> tail: Some(B)");
var e = object_record("E", "<head> head: A | <tail> tail: Some(B)");
var f = object_record("F", "<head> head: C | <tail> tail: Some(D)");
var g = object_record("G", "<head> head: 10 | <tail> tail: Some(H)");
var h = object_record("H", "<head> head: 20 | <tail> tail: Some(G)");

var local_a = { id: "local_a", label: "a", shape: "record" };
var local_f = { id: "local_f", label: "f", shape: "record" };

stack[1] = local_a;
stack[2] = local_f;

b.tail = edge_from_port(":tail", a);
c.tail = edge_from_port(":tail", a);
d.tail = edge_from_to_ports(":tail", ":id", b);
e.head = edge_from_port(":head", a);
e.tail = edge_from_to_ports(":tail", ":id", b);
f.head = edge_from_to_ports(":head", ":id", c);
f.tail = edge_from_to_ports(":tail", ":id", d);
g.tail = edge_from_to_ports(":tail", ":id", h);
h.tail = edge_from_to_ports(":tail", ":id", g);

local_a.ref = a;
local_f.ref = edge_to_port(":id", f);

gc_heap[0] = a;
gc_heap[1] = b;
gc_heap[2] = c;
gc_heap[3] = d;
gc_heap[4] = e;
gc_heap[5] = f;
gc_heap[6] = g;
gc_heap[7] = h;

var objects = [stack, gc_heap];
post_objects("target_anchor_gc_demo_1", objects, { rankdir:"LR", nodesep:0.2, no_dims:true });
</script>


<p>The GC would be allowed to collect the objects labelled &ldquo;E&rdquo;, &ldquo;G&rdquo;, and
&ldquo;H&rdquo; in the picture, since they are not reachable from the roots.
(However, the GC is not obligated to reclaim them at any particular
time. Usually GC&rsquo;s provide little guarantees about how soon objects
will be reclaimed.)</p>

<p>This kind of feature could be useful in any Rust library.</p>

<a name="Advantages.of.Gc.T..over.Rc.T."></a>
<h4>Advantages of Gc<T> over Rc<T></h4>

<p>The main hypothesized advantages over <code>Gc&lt;T&gt;</code> over <code>Rc&lt;T&gt;</code> are:</p>

<ul>
<li><p><code>Gc&lt;T&gt;</code> is <code>Copy</code>, which makes it possible to construct types like
<code>Cell&lt;Gc&lt;T&gt;&gt;</code>.</p>

<p>(It also has nicer programmer ergonomics in some cases; e.g. some
programmers dislike having to write <code>x.clone()</code> every time they
want to make a copy of ref-counted <code>x</code>.)</p></li>
<li><p><code>Gc&lt;T&gt;</code> allows cyclic structure to be reclaimed (e.g. the objects
 &ldquo;G&rdquo; and &ldquo;H&rdquo; in the picture above.</p></li>
<li><p>Using <code>Gc&lt;T&gt;</code> <em>might</em> have less overhead than <code>Rc&lt;T&gt;</code>: every time
you clone an <code>Rc&lt;T&gt;</code> it incurs reference-count overhead, while
<code>Gc&lt;T&gt;</code> just copies the reference.</p>

<p>(However, this stated advantage must be tempered by the
realization that GC incurs its own separate overheads, as
discussed in the <a href="/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work/">background post</a>.</p></li>
</ul>


<a name="Drawbacks.of.one.GC.for.everyone"></a>
<h4>Drawbacks of one GC for everyone</h4>

<p>There are two immediate drawbacks with this kind of collector
support.</p>

<p>First, adding it would require that the standard library either
provide a garbage collector (that all clients of <code>Gc&lt;T&gt;</code> would have to
link in), or at least standardize a fixed API that third-party
collector implementations would have to satisfy to support <code>Gc&lt;T&gt;</code>.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
In particular, smart-pointers in Rust
require at <em>least</em> support for the <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code> trait</a>, so
that dereferencing expressions like <code>gc_ref.field</code> and
<code>gc_ref.method()</code> are compiled into code that resolves the <code>gc_ref</code> to
a<code>&amp;T</code> reference (and then the subsequent field or method lookup is
performed with respect to that <code>&amp;T</code> reference).
<br></br>
As a reminder, the signature of the <code>deref</code> method, before lifetime
elision, is <code>fn deref&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a Self::Target</code> (and the
associated <code>Target</code> type for <code>Gc&lt;T&gt;</code> would be <code>T</code>).  Thus, the
compiler will ensure that the reference <code>&amp;'a T</code> we extract from the
<code>gc_ref</code> outlive the <code>gc_ref</code> itself; this means that the <code>gc_ref</code>
will be one (of potentially many) root keeping the object from being
reclaimed for the entirety of the lifetime <code>'a</code>, and thus supporting
the <code>Deref</code> trait design on a <code>Gc&lt;T&gt;</code> could work seamlessly on an
entirely non-moving GC.
<br></br>
However, moving objects complicate <code>Deref</code> support; now one needs to
ensure not only that the object remains alive, but also that the
reference <code>&amp;'a T</code> consistently points to the same object that the
original <code>Gc&lt;T&gt;</code> pointed to, and that references to substructure
within the object (e.g. a <code>&amp;Left</code> within a <code>Gc&lt;(Left, Right)&gt;</code> that
has been deref'ed to <code>&amp;(Left, Right)</code>) also retain a consistent view
of the heap structure. Doing this at an acceptable cost is difficult;
I may discuss this more in a future post.
</span>
Second, it is difficult to provide the ergonomics that one expects
from a smart-pointer type analogous to
<code>Rc&lt;T&gt;</code>.</p>

<p>Okay, so that&rsquo;s the outline of the tradeoffs of providing
a &ldquo;GC for everyone&rdquo; in <code>libstd</code>.  What about a more limited
GC feature, where the audience is not &ldquo;every Rust crate&rdquo;, but instead
just the crates linking to a managed runtime.</p>

<a name="GC.as.Interoperation.Feature"></a>
<h3>GC as Interoperation Feature</h3>

<p>GC as an interoperation feature means that Rust would provide
introspective hooks to improve integration with application frameworks
that are using their own garbage collector. One example of this is
Servo&rsquo;s use of the SpiderMonkey Virtual Machine for its Javascript
support.</p>

<p>Servo is relying on SpiderMonkey&rsquo;s garbage collection for memory
management, not only for Javascript values, but even for
<a href="https://blog.mozilla.org/research/2014/08/26/javascript-servos-only-garbage-collector/">native-code DOM objects</a>.</p>

<p>That post describes (unchecked) scenarios where one can end up with
dangling pointers &ndash; that is, they invite unsoundness.  Proper support
for GC-interoperation in Rust could address this; I will discuss this
further down in this post.</p>

<p>Critically, GC-interoperation does not require the same level of
ergonomics that <code>Rc&lt;T&gt;</code> provides. For example, in this context it is
acceptable for <code>Gc&lt;T&gt;</code> to not support <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a>.</p>

<p>(Furthermore, in this context, it may even be acceptable to require
unchecked constraints like &ldquo;the programmer must ensure the collector
is not invoked during this extent&rdquo;, or perhaps &ldquo;the programmer must
periodically invoke a call that tells the GC that this is an
acceptable time to do collection work that could move objects.&rdquo;)</p>

<p>Without a <code>Deref</code> trait and with such unchecked requriements, such
interoperation might end up looking something like this:</p>

<pre><code class="rust">fn double_last(x: Gc&lt;Vec&lt;i32&gt;&gt;) {
    unsafe {
        let ptr: *mut Vec&lt;i32&gt; = x.get_ptr();

        // during the extent of this block, it is the responsibility
        // of the double_last author to ensure the GC never gets
        // invoked (i.e., do not do any allocations to the GC'ed heap
        // during this unsafe-block).

        if Some(i) = (*ptr).last_mut() {
            *i = *i * 2;
        }
    }
}
</code></pre>

<p>In this context, interoperation still requires defining a standard
interface that the third-party collector implementation has to conform
with.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
In truth, even for a conservative collector like <a href="http://www.hboehm.info/gc/">BDW</a>,
one must do more than just &ldquo;swap in a new <code>#[allocator]</code>&rdquo; to actually
integrate it properly; the current Rust standard library does not
provide a way to intercept thread spawns and register the new
stack associated with each new thread.
<br></br>
I only realized this only <a href="https://github.com/swgillespie/boehm_gc_allocator/issues/2">recently</a>.
</span>
In a simple world (e.g., a conservative collector designed to
interoperate with C/C++, such as <a href="http://www.hboehm.info/gc/">boehm-demers-weiser</a> (BDW)), this
standard interface could be nothing more than just &ldquo;swap in a
different <a href="https://doc.rust-lang.org/nightly/book/custom-allocators.html">#[allocator] crate</a> that your GC provides.&rdquo;</p>

<p>(The actual interface is unlikely to be so
simple, but the point is, there is a wide
design space to be explored here.)</p>

<a name="Interoperation.with.a..black.box..GC"></a>
<h4>Interoperation with a &ldquo;black box&rdquo; GC</h4>

<p>One way to look at the difference between &ldquo;GC for pure Rust programs&rdquo;
versus &ldquo;GC for interoperation&rdquo; is that in the former case, the GC
feels deeply integrated with the language and standard library, while
in the latter case, the GC is clearly the concern of some entity
outside the language (and we are just trying to accommodate it as best
we can).</p>

<p>An extreme instance of a GC that is definitely an entity outside the
language is a case where the whole GC heap is treated like a black
box, and the objects inside the heap are never directly exposed to the
application code outside the box.</p>

<p>For example, one can imagine a virtual machine (VM) interface where
the code outside the VM is never given addresses of objects on the
heap. Instead, such foreign code only has <em>handles</em> that indirectly
point to those objects.</p>

<p id="target_anchor_black_box_gc_1" class="fullwidth"></p>


<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var rust_heap = { rankdir:"LR", id: "cluster_rust_heap", label: "Rust Heap", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };
var handles = object_record("handles", "<h2> Y | <h1> X | <h3> X");

var c = object_record("C", "<f0> Gc(X) | <f1> Box(O)");
c.style = "rounded";
var o = object_record("O", "<f0> Handle(2)");
var x = object_record("X", "<f0> 'a' | <f1> next");
var y = object_record("Y", "<f0> 'b' | <f1> next");
var z = object_record("Z", "<f0> 'c' | <f1> (next)");
x.style = "rounded";
y.style = "rounded";
z.style = "rounded";
var local_x = { id: "local_x", label: "handle_x", shape: "record" };
var local_y = { id: "local_y", label: "handle_y", shape: "record" };
var local_o = { id: "local_o", label: "boxed_o", shape: "record" };

x.next = edge_from_to_ports(":f1", ":id:sw", y);
y.next = edge_from_to_ports(":f1", ":id", z);

o.f0 = edge_from_to_ports(":f0", ":h3", handles);

c.f0 = edge_from_to_ports(":f0", ":id", x);
c.f1 = edge_from_to_ports(":f1", ":id", o);

stack[1] = local_x;
stack[2] = local_y;
stack[3] = local_o;

rust_heap[0] = o;
gc_heap[0] = handles;
handles.x1 = edge_from_to_ports(":h1", ":id", x);
handles.y2 = edge_from_to_ports(":h2", ":id", y);
handles.x3 = edge_from_to_ports(":h3", ":id:sw", x);
local_x.handle = edge_to_port(":h1", handles);
local_y.handle = edge_to_port(":h2", handles);
local_o.box = edge_to_port(":id", o);
gc_heap[2] = x;
gc_heap[3] = y;
gc_heap[4] = z;

var objects = [stack, gc_heap, rust_heap];
post_objects("target_anchor_black_box_gc_1", objects, { rankdir:"LR", nodesep:0.2, no_dims: true });
</script>


<p>In this setting, direct references to objects <em>never</em> escape the black
box. Instead, by setting up a level of indirection, the management of
the objects within the GC heap is completely abstracted away.</p>

<p>In a black box GC setting, one would not expose the data structure of
the objects (since they can never be directly addressed
anyway). Instead, one would define functions on handles that extract
the fields and maps them to handles when necessary:</p>

<pre><code class="rust">extern fn handle_data(a: Handle) -&gt; char;
extern fn handle_next(a: Handle) -&gt; Option&lt;Handle&gt;;
extern fn handle_set_next(a: Handle, b: Option&lt;Handle&gt;);

// sample code interacting with the black box GC

// all of these predicates hold of the above heap diagram
assert_eq!(handle_data(handle_x), 'a');
assert_eq!(handle_data(handle_next(handle_y).unwrap()), 'c');
assert!(handle_next(handle_next(handle_y).unwrap()).is_none());

// this changes the heap to match the diagram below.
handle_set_next(handle_x, handle_next(handle_y));
</code></pre>

<p id="target_anchor_black_box_gc_2" class="fullwidth"></p>




<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var rust_heap = { rankdir:"LR", id: "cluster_rust_heap", label: "Rust Heap", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };
// var handles = object_record("handles", "<h2> Y | <h1> X | <h3> X | <h4> (temp for Z)");
var handles = object_record("handles", "<h2> Y | <h1> X | <h3> X");

var c = object_record("C", "<f0> Gc(X) | <f1> Box(O)");
c.style = "rounded";
var o = object_record("O", "<f0> Handle(2)");
var x = object_record("X", "<f0> 'a' | <f1> next");
var y = object_record("Y", "<f0> 'b' | <f1> next");
var z = object_record("Z", "<f0> 'c' | <f1> (next)");
x.style = "rounded";
y.style = "rounded";
z.style = "rounded";
var local_x = { id: "local_x", label: "handle_x", shape: "record" };
var local_y = { id: "local_y", label: "handle_y", shape: "record" };
var local_o = { id: "local_o", label: "boxed_o", shape: "record" };

x.next = edge_from_to_ports(":f1", ":id:w", z);
y.next = edge_from_to_ports(":f1", ":id:n", z);

o.f0 = edge_from_to_ports(":f0", ":h3", handles);

c.f0 = edge_from_to_ports(":f0", ":id", x);
c.f1 = edge_from_to_ports(":f1", ":id", o);

stack[1] = local_x;
stack[2] = local_y;
stack[3] = local_o;

rust_heap[0] = o;
gc_heap[0] = handles;
handles.x1 = edge_from_to_ports(":h1", ":id", x);
handles.y2 = edge_from_to_ports(":h2", ":id", y);
handles.x3 = edge_from_to_ports(":h3", ":id:sw", x);
// handles.z4 = edge_from_to_ports(":h4", ":id:sw", z);
local_x.handle = edge_to_port(":h1", handles);
local_y.handle = edge_to_port(":h2", handles);
local_o.box = edge_to_port(":id", o);
gc_heap[2] = x;
gc_heap[3] = y;
gc_heap[4] = z;

var objects = [stack, gc_heap, rust_heap];
post_objects("target_anchor_black_box_gc_2", objects, { rankdir:"LR", nodesep:0.2, no_dims: true });
</script>


<p>In case it isn&rsquo;t clear, supporting interoperation with this kind of
&ldquo;black box&rdquo; GC requires very little from the Rust side; potentially
nothing at all. The object addresses are hidden, so the GC could move
an object and update its address in the handle
array.<label for='&lsquo;handles&rsquo;' class='margin-toggle'> &#8853;</label><input type='checkbox' id='&lsquo;handles&rsquo;' class='margin-toggle'/><span class='marginnote'>&lsquo;If </span></p>

<p>However, this so-called interoperation is also quite limited in
expressiveness. The defining property of the &ldquo;black box&rdquo; GC, the fact
that it does not expose the addresses of the objects held within, also
means that we cannot expose <code>&amp;</code>-references to the objects or the state
within them, which means we cannot use these objects with the large
number of Rust functions that operate on <code>&amp;</code>-references and slices.</p>

<a name="Digression.on.limits.of..black.box..GC"></a>
<h3>Digression on limits of &ldquo;black box&rdquo; GC</h3>

<p>In addition to the limits regarding exposure of <code>&amp;</code>-references
described above, another issue with &ldquo;black box&rdquo; GC is that
it is not clear whether client code hooking
into the &ldquo;black box&rdquo; GC would be able to instantiate the GC objects
with its own types.</p>

<p>For example, one might think that the objects in the GC heap could be
defined via type parameterization: <code>fn bbox_gc_alloc&lt;T&gt;(t: T) -&gt; Handle;</code>
would create an object on the heap, copy <code>t</code> into it, and return a
handle to that object.</p>

<p>For this to work, the layout of the list cells in the GC heap above
would need to look something like this:</p>

<pre><code class="rust">struct Cons&lt;T&gt; {
    data: T,
    next: Option&lt;GcPtr&lt;Cons&lt;T&gt;&gt;&gt;,
}
</code></pre>

<p>Then constructing a list like the &ldquo;X, Y, Z&rdquo; in the heap diagrams
above would look like:</p>

<pre><code class="rust">let handle_z = bbox_gc_alloc(Cons { data: 'c', next: None });
let handle_y = bbox_gc_alloc(Cons { data: 'b', next: None });
let handle_x = bbox_gc_alloc(Cons { data: 'a', next: None });
handle_set_next(handle_y, handle_z);
handle_set_next(handle_x, handle_y);
</code></pre>

<p>But there are two (related) problems:</p>

<ol>
<li><p>How does one instantiate values that <em>unconditionally</em> hold
 pointers to GC objects.  (For example, how do we allocate an
 instance of <code>Cons&lt;GcPtr&lt;Cons&lt;char&gt;&gt;&gt;</code>?)
 <br></br>
 We have already established that the address in the GC Heap are
 not exposed outside of the heap, so the approach of passing in an
 <code>T</code> value that we used with <code>bbox_gc_alloc</code> above will not work,
 because we cannot put our hands on a <code>GcPtr</code> to use for the
 <code>data</code> field.</p></li>
<li><p>How do we get from the <code>struct</code> definition for <code>Cons</code> to
 the family of methods defined in terms of <code>Handle</code>?
 <br></br>
 Every occurrence of <code>GcPtr</code> used for the struct (as seen from
 the point of view of the GC Heap) needs to be mapped to
 a <code>Handle</code> in the functions exposed to the functions outside
 of GC Heap.</p></li>
</ol>


<p>Also, the hidden object addresses may complicate client code trying to
instantiate GC objects with its own types.</p>

<p>It could be that there is a solution to the problem lurking here.
In any case, interoperation with a blackbox GC is not a primary goal,
since the level of indirection and (perhaps more crucially)
the maintenance of the handles array are not ideal.</p>

<a name="Objectives.and.Requirements..oh.no..now.five.problems."></a>
<h2>Objectives and Requirements (oh no, now five problems)</h2>

<p>The two (or perhaps three) kinds of support described above are
distinct features; there is overlap between them, but trying to find a
single solution that solves both problems completely may not be
possible, and in any case we do not want to wait for that single
solution to be discovered.</p>

<p>Since <code>Rc&lt;T&gt;</code> is already a workable solution for many (though not all)
use cases of <code>Gc&lt;T&gt;</code>, the above idealized &ldquo;one GC shared by every
crate&rdquo; is not a main priority right now (and may never be added to the
Rust language).</p>

<p>Let us focus on GC as an interop feature, and dive into what we would
want to get out of it.</p>

<p>There are a number of objectives for Rust/GC integration that are
worth noting, which I will list here and then define and discuss
below.</p>

<ol>
<li><a href="#safety">Safe</a></li>
<li><a href="#modularity">Modular</a></li>
<li><a href="#zero-cost">Zero-Cost</a></li>
<li><a href="#compositionality">Compositional</a></li>
<li><a href="#precision">Precise (Space-Efficient)</a></li>
</ol>


<a name="L.span.id..safety..Safety.with.respect.to.GC..span."></a>
<h3><span id="safety">Safety with respect to GC</span></h3>

<p>If a Rust crate does not use <code>unsafe</code> constructs (<code>unsafe</code> blocks,
attributes or types with &ldquo;unsafe&rdquo; in their name, etc.), then linking
it with a sound set of crates that use GC must maintain soundness.</p>

<p>In other words, linking in a crate that uses no <code>unsafe</code> construct
should not inject any dereferences of dangling pointers, nor any data
races.</p>

<p>By the way, we absolutely do need to provide criteria that says what
<code>unsafe</code> code <em>is</em> allowed to do when linked with a crate that uses
GC. I am going to assume for these initial posts that we will solve
that problem eventually, but not attempt to address it at the outset.</p>

<a name="L.span.id..modularity..Modularity.with.respect.to.GC..span."></a>
<h3><span id="modularity">Modularity with respect to GC</span></h3>

<p>A Rust program that uses GC should be able to link to a crate whose
source code was authored without knowledge of GC.</p>

<p>For example, if I make a parsing library today that works on string
slices <code>&amp;str</code>, you should be able to link that parsing library into a
program that uses GC, without having to worry about whether the
parsing library carries hidden requirements that invalidate
assumptions made by the GC.</p>

<p>Note: A crate being &ldquo;authored without knowledge of GC&rdquo; is a
property of the source code, not the generated object code. Given
such a crate, the Rust compiler may itself inject metadata
related to GC, such as descriptions of object layout, or
automatically-generated code that dictate how objects should
traced by the collector.</p>

<p>Note: A crate being &ldquo;authored without knowledge of GC&rdquo; is entirely
distinct a crate not supporting GC. That is, we may add well a way for
a crate to declare that it is not compatible with GC. (This would
count as having knowledge of GC; in fact, enough knowledge to know, or
at least guess, that its presence would cause the GC to break, or vice
versa.)</p>

<p>If we cannot satisfy this requirement, then the addition of GC
will, at best, split the growing space of library crates (such as
those available on <a href="https://crates.io/">crates.io</a>) into two disjoint
sub-communities: crates that support GC, and those that do not
(since the latter were written without accounting for the
potential presence of a GC).</p>

<p>An aside: I would really like to find a way to combine the
descriptions of &ldquo;modularity&rdquo; and &ldquo;safety&rdquo;, since they seem to be
attempted to express similar or related objectives.</p>

<p>A final note: There are some features available to crates, such as
requiring a specific low-level allocator, that are likely to be
incompatible with a program that uses GC. We need to define these
caveats and incorporate them into the above definition of
&ldquo;modularity&rdquo;, without weakening it to the point of uselessness.
(However, I will not attempt to tackle that here.)</p>

<a name="L.span.id..zero-cost..Zero-Cost.GC..span."></a>
<h3><span id="zero-cost">Zero-Cost GC</span></h3>

<p>If you don&rsquo;t use the GC feature (in whatever form it takes), your code
should not pay for it.</p>

<p>This applies to the quality of the generated code (in execution
time and code size), and also to the source code, with respect to
difficulty in writing a program or library.</p>

<p>There are two forms of the zero-cost property relevant here:</p>

<ol>
<li><p>Strongly zero-cost: A unit of code generation that does not use
 GC should not pay for it.</p>

<p> For example, in the above example of the string parsing module,
 ideally the code generated for parsing <code>&amp;str</code> values should have
 the same performance characteristics, regardless of whether it is
 linked into a program that uses GC or not.</p></li>
<li><p>Weakly zero-cost: A program that does not use GC should not pay
 for it.</p>

<p> (At worst, one can imagine ensuring this property by compiling
 two different versions of each code unit, and then linking to the
 appropriate one. Hopefully we will not need to resort to that.)</p></li>
</ol>


<p>Strongly zero-cost implies weakly zero-cost, but not vice-versa.</p>

<a name="L.span.id..compositionality..Compositional.GC..span."></a>
<h3><span id="compositionality">Compositional GC</span></h3>

<p>One can use a reference to a gc-allocated object (call it a <code>GcRef</code>)
as the field type in a <code>struct</code>, store it into a <code>Vec&lt;GcRef&gt;</code>, and
in general do anything with it that one can do with a normal Rust value.</p>

<p>Furthermore, one should be able to describe, via a Rust type
definition, the layout of a value allocated on the GC heap, allocate
such values there, and acquire a suitable <code>GcRef</code> to the allocated
object.</p>

<p>To be concrete about this, consider the following program,
which uses a hypothetical <code>make_gc_ref</code> function to move
values into a newly-allocated spot on the GC heap, and returns
a reference to that spot. (In the future one will probably use
the <code>box</code> syntax for this, and rely on type-context to inform
box that this is a GC-allocation.)</p>

<pre><code class="rust">fn demo() {
    let gc_v = {
        let ref_x1 = make_gc_ref("data_one");
        let ref_x2 = make_gc_ref("data_two");
        let v = vec![x1, x1, x2];
        make_gc_ref(v)
    };
    ...
}
</code></pre>

<p>This results in the following diagram:</p>

<p id="target_anchor_demo_composition_1"></p>


<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var rust_heap = { rankdir:"LR", id: "cluster_rust_heap", label: "Rust Heap", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };

var x1 = object_record("X1", "<f0> 'data_one'");
var x2 = object_record("X2", "<f0> 'data_two'");

x1.style = "rounded";
x2.style = "rounded";

var gc_v = { id: "gc_v", label: "Gc(V)", shape: "record" };

var v = object_record("V", "<f0> len: 3 | cap: 4 | <f2> ptr: Arr");
v.style = "rounded";
var arr = object_record("Arr", "<f0> Gc(X1) | <f1> Gc(X1) | <f2> Gc(X2)");
arr.color = "blue";

v.f2 = edge_from_to_ports(":f2", ":id", arr);
gc_v.f0 = edge_to_port(":id", v);

arr.f0 = edge_from_to_ports(":f0", ":id", x1);
arr.f1 = edge_from_to_ports(":f1", ":id", x1);
arr.f2 = edge_from_to_ports(":f2", ":id", x2);

stack[0] = gc_v;
rust_heap[0] = arr;
gc_heap[0] = v;
gc_heap[1] = x1;
gc_heap[2] = x2;

var objects = [stack, gc_heap, rust_heap];
post_objects("target_anchor_demo_composition_1", objects, { rankdir:"LR", nodesep:0.2 });
</script>


<p>Here, I have made explicit the heap-allocated backing store <code>Arr</code> (in
blue) for the vector that holds the references to <code>x1</code> and <code>x2</code>.</p>

<p>This shows that if we want GC to reasonably usable (i.e., allow GC
references to be used like other Rust values), we need to support
references out of the GC heap and into the Rust heap, and likewise
references out of the Rust heap and into the GC heap.</p>

<p>It can sometimes be simpler (without necessarily eliminating the
fundamental problem) to just a <code>Box</code> rather than a <code>Vec</code>:</p>

<p id="target_anchor_demo_composition_2"></p>


<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var rust_heap = { rankdir:"LR", id: "cluster_rust_heap", label: "Rust Heap", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };
var c = object_record("C", "<f0> Gc(X) | <f1> Box(O)");
c.style = "rounded";
var o = object_record("O", "<f0> Gc(X)");
var x = object_record("X", "<f0> 'data'");
x.style = "rounded";
var gc_a = { id: "gc_c", label: "Gc(C)", shape: "record" };

gc_a.f0 = edge_to_port(":id", c);

o.f0 = edge_from_to_ports(":f0", ":id", x);

c.f0 = edge_from_to_ports(":f0", ":id", x);
c.f1 = edge_from_to_ports(":f1", ":id", o);

stack[0] = gc_a;
rust_heap[0] = o;
gc_heap[0] = c;
gc_heap[1] = x;

var objects = [stack, gc_heap, rust_heap];
post_objects("target_anchor_demo_composition_2", objects, { rankdir:"LR", nodesep:0.2, no_dims: true });
</script>


<p>The program to construct the above picture might look like
this:</p>

<pre><code class="rust">fn demo() {
    struct C(Gc&lt;str&gt;, Box&lt;Gc&lt;str&gt;&gt;);
    let gc_c = {
        let ref_x = make_gc_ref("data");
        let box_o = Box::new(ref_x);
        make_gc_ref(C(ref_x, box_o))
    };
    ...
}
</code></pre>

<p>(The types in the demo program above assume certain features like
allowing <code>Gc&lt;T&gt;</code> for <code>T: ?Sized</code>, which may or may not be reasonable.)</p>

<p>The compositionality constraint may seem obvious (especially if one
starts by assuming that references to gc-allocated objects will be
values of type <code>Gc&lt;T&gt;</code> for arbtrary <code>T</code>).</p>

<p>But using &ldquo;black box&rdquo; GC interop (as described above) would likely
<em>defeat</em> compositionality.  That is why I point out this objective
explicitly.</p>

<a name="L.a.id..precision..Precision..Space-Efficiency...a."></a>
<h3><a id="precision">Precision (Space-Efficiency)</a></h3>

<p>A 100% precise GC is one that knows the type of every object and field
that it encounters, in terms of being able to classify a word of
memory as an integer or a pointer, and also classify whether a given
word of memory is actually usable according to the type of the value
the word is embedded within.</p>

<p>A space-efficient GC, in essence, is one that is eventually able to
reclaim all garbage, without being subverted by particular details of
the host program or the system state.</p>

<p>(Calling a language implementation space-efficient is a reference to
the <a href="http://www.cesura17.net/~will/professional/research/papers/tail.pdf">asymptotic space complexity</a> of a language implementation.  I am
employing the term here because the objective I want to capture is
more general than just precision.)</p>

<p>A <a href="/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work/#conservative-gc">conservative GC</a> lacks precision. In other words,
a precise GC is more space-efficient than a conservative GC: There
exists a program that will exhibit worse (asymptotic) space
performance atop a conservative GC than it would atop a precise GC.</p>

<p>We would like Rust to be able to interoperate with 100% precise
collectors.</p>

<p>Ideally, we would also like to be able to interoperate with collectors
that do not support <a href="/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work/#pinning-support">pinning</a>.</p>

<p>Finally, we would like to ensure that the heap patterns associated
with <a href="#compositionality">Compositionality</a> do not cause garbage to go unreclaimed.</p>

<ul>
<li>Note that a precise GC that treats <em>all</em> objects on the &ldquo;Rust Heap&rdquo;
as roots is not very space-efficient: it will fail to collect
cyclic garbage structure like the below.</li>
</ul>


<p id="target_anchor_demo_garbage_cycle_thru_rust_heap"></p>


<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var rust_heap = { rankdir:"LR", id: "cluster_rust_heap", label: "Rust Heap", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };

var local_a = { id: "local_a", label: "a", shape: "record" };

var a = object_record("A", "<f0> Some(Gc(B)) | <f1> None");
a.style = "rounded";
var b = object_record("B", "<f0> None | <f1> None");
b.style = "rounded";
var c = object_record("C", "<f0> Some(Gc(B)) | <f1> Some(Box(O))");
c.style = "rounded";
var o = object_record("O", "<f0> Gc(C)");

a.f0 = edge_from_to_ports(":f0", ":id:n", b);

c.f0 = edge_from_to_ports(":f0", ":id", b);
c.f1 = edge_from_to_ports(":f1:s", ":id", o);
o.f0 = edge_from_to_ports(":f0", ":id", c);

stack[1] = local_a;
local_a.ref = edge_to_port(":id", a);

gc_heap[0] = a;
gc_heap[1] = b;
gc_heap[2] = c;
rust_heap[0] = o;

var objects = [stack, gc_heap, rust_heap];
post_objects("target_anchor_demo_garbage_cycle_thru_rust_heap", objects, { rankdir:"LR", nodesep:0.2, no_dims: true});
</script>


<p>In the above diagram, &ldquo;C&rdquo; and &ldquo;O&rdquo; are unreachable by the program
itself (&ldquo;O&rdquo; is owned by the gc-allocated &ldquo;C&rdquo;), but if you treat all
objects in the Rust Heap as roots, then it will classify &ldquo;O&rdquo; as a
root, and &ldquo;C&rdquo; will never be reclaimed.</p>

<p>This is why compositionality can interact with space-efficiency.
Allowing gc-allocated objects to own data allocated on the Rust heap,
while also allowing references to gc-allocated objects to be stored in
values on the Rust heap, then you will encounter cyclic structure like
this. (This was the design bug that led me to withdraw my &ldquo;Take II&rdquo;
<a href="https://github.com/rust-lang/rfcs/pull/244">allocator RFC</a>.)</p>

<a name="Conclusion"></a>
<h2>Conclusion</h2>

<p>This post was dedicated to identifying criteria that we would
like GC-integration with Rust to satisfy.</p>

<p>Next up: Why is it hard to satisfy the above criteria simultaneously?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GC and Rust Part 0: Garbage Collection Background]]></title>
    <link href="http://blog.pnkfx.org/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work/"/>
    <updated>2015-10-27T14:09:00+01:00</updated>
    <id>http://blog.pnkfx.org/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work</id>
    <content type="html"><![CDATA[<p>This post is a prequel to a series of posts discussing why garbage
collection is hard, especially for Rust, and brainstorming about
solutions to the problems we face.</p>

<p>The goal of this post is to provide the background foundational material
about Garbage Collection that the other posts will then build upon.</p>

<!-- more -->


<p>You can skip ahead to the follow-up posts (once they are published) if
you feel you are already well-versed in the low-level mechanics of
garbage collection.</p>

<p>I may add more material to this post in the future if I discover a
need to provide more detail on a particular subtopic, such as &ldquo;write
barriers&rdquo;.</p>

<p>(The body of this post makes heavy use of client-side rendering,
because of author idiosyncrasies.  You may need to wait a moment while
the supporting Javascript loads.)</p>

<p>Update (17 November 2015): It has come to my attention that portions
of the post are not rendering properly in Google Chrome. I will try to
fix this, but in the meantime, you should be able to get the proper
renderings in Safari or Firefox. (I do not yet know about other
browsers.) If your browser is working as original expected, then
you should see a picture load immediately beneath this text.</p>

<p>Update (18 Novemer 2015): many thanks to <code>othermike</code> on reddit who
pointed out <a href="https://www.reddit.com/r/rust/comments/3t6nk7/gc_and_rust_part_1_specifying_the_problem/cx40odj">my bug</a>.
The content should now render properly on Chrome (and hopefully other
browsers too).</p>

<script src="http://blog.pnkfx.org/javascripts/viz.js" charset="utf-8"></script>


<script src="http://blog.pnkfx.org/javascripts/js_to_dot.js" charset="utf-8"></script>


<script src="http://blog.pnkfx.org/javascripts/gc_rendering.js" charset="utf-8"></script>


<script>
function simple_gc_structure() {
    var rf = make_regfile("RF");
    var a = { id: "A" };
    var b = { id: "B" };
    var c = { id: "C" };
    var d = { id: "D" };
    var e = { id: "E" };
    var f = { id: "F" };
    var g = { id: "G" };
    b.f0 = c;
    d.f0 = a;
    d.f1 = e;
    e.f0 = f;
    f.f0 = e;
    c.f0 = g;

    rf.link(0, a);
    rf.link(1, b);
    rf.link(3, c);

    return [rf, d];
}

function copied_gc_structure() {
    var rf = make_regfile("RF");
    var a = { id: "A" };
    var b = { id: "B" };
    var c = { id: "C" };
    var d = { id: "D" };
    var e = { id: "E" };
    var f = { id: "F" };
    var g = { id: "G" };

    var a2 = { id: "A2", label: "A'" };
    var b2 = { id: "B2", label: "B'" };
    var c2 = { id: "C2", label: "C'" };
    var g2 = { id: "G2", label: "G'" };

    b.f0 = c;
    c.f0 = g;
    d.f0 = a;
    d.f1 = e;
    e.f0 = f;
    f.f0 = e;

    b2.f0 = c2;
    c2.f0 = g2;

    a.fwd = dashed_edge(a2);
    b.fwd = dashed_edge(b2);
    c.fwd = dashed_edge(c2);
    g.fwd = dashed_edge(g2);

    rf.link(0, a2);
    rf.link(1, b2);
    rf.link(3, c2);

    return [rf, d, a, b, c];
}

function simple_gc2() {
    var gc_struct = simple_gc_structure();
    var rf = gc_struct[0];
    var d = gc_struct[1];
    // for_each_reachable([d], hide, { on_edge: hide });
    // for_each_reachable([rf], unhide);
    var content = render_objects([rf, d]);
    return digraph(content, { rankdir:"LR" });
}
</script>




<p id="target_anchor1"></p>


<script>
var gc_struct = simple_gc_structure();
var rf = gc_struct[0];
var d = gc_struct[1];
var content = render_objects([rf]);
post_graph("target_anchor1", digraph(content, { rankdir:"LR" }), { no_dims: true });
</script>


<a name="What.is.Garbage.Collection"></a>
<h2>What is Garbage Collection</h2>

<p>A garbage collector is a component in the runtime for a programming
language that periodically attempts to reclaim memory (without
requiring explicit calls to memory-freeing routines in the programning
language). To do this soundly, the collector must identify blocks of
memory that cannot possibly be used in the future by the program
(i.e., &ldquo;dead objects&rdquo;).</p>

<p>Discussions of garbage collection often equate the notion of &ldquo;dead
object&rdquo; with &ldquo;unreachable object&rdquo;: If no chain of references exists
that could lead the program to an object, then that object cannot be
reached<label for='&lsquo;collecting-more-garbage&rsquo;' class='margin-toggle'> &#8853;</label><input type='checkbox' id='&lsquo;collecting-more-garbage&rsquo;' class='margin-toggle'/><span class='marginnote'>&lsquo;Researchers </span>
 (and therefore cannot be used in the future).</p>

<p>When one says &ldquo;garbage collector&rdquo;, one usually means a &ldquo;<em>tracing</em>
garbage collector&rdquo;: a collector that works by identifying the
reachable objects by computing the connected components that include
the &ldquo;roots&rdquo; of the object graph. (The &ldquo;roots&rdquo; are the starting points
from which any chain of references must originate in the source
program.)</p>

<p>So, for example, we might have the following set of
gc-managed objects (labelled &ldquo;A&rdquo; through &ldquo;F&rdquo; below),
along with a register file labelled &ldquo;RF&rdquo;.</p>

<p id="target_anchor2"></p>


<script>
post_objects("target_anchor2", simple_gc_structure(), { rankdir:"LR", no_dims: true });
</script>


<p>In the simple model above, the roots <em>are</em> the processor
registers. Such a model is applicable to a language runtime where all
memory blocks (<em>including</em> the stack frames) are managed by the garbage
collector. (In other words, we are not talking about Rust yet.)</p>

<p>The reachable objects, as stated above, are the connected
components of the graph that includes the roots, highlighted
below.</p>

<p id="target_anchor3"></p>


<script>
// Overriding the `highlight` I put into js_to_dot.js
function highlight(object) {
    object.penwidth = "3.0";
    return object;
}

var objects = simple_gc_structure();
for_each_reachable([objects[0]], { on_node: highlight, on_edge: highlight });
post_objects("target_anchor3", objects, { rankdir:"LR", no_dims: true });
</script>


<p>A garbage collector would determine that the objects
labelled &ldquo;D&rdquo;, &ldquo;E&rdquo;, and &ldquo;F&rdquo; are unreachable, and thus
their storage can be reclaimed.</p>

<a name="L.span.id..how-gc-works..How.Garbage.Collection.works..span."></a>
<h2><span id="how-gc-works">How Garbage Collection works</span></h2>

<p>A garbage collector is often presented as a <em>coroutine</em>
<label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
Coroutines are much like subroutines,
except that instead of having a parent-child relationship (where the
child subroutine &ldquo;returns&rdquo; to the parent caller), a call from
coroutine A to coroutine B: saves the current context of where A
currently is, transfers control to B, and the next time B calls A,
resumes the context that was saved at the outset.
<br></br>
In other words, once the linkage has been established between A and B,
then A&rsquo;s calls to B look like <em>returns</em> from the viewpoint of B, (and
B&rsquo;s calls to A look like returns from the viewpoint of A).
</span>
 that is linked in with the main
program. The main program itself is often referred to as a &ldquo;mutator&rdquo;,
since it is the entity that <em>mutates</em> the object graph.  (The
collector does not modify the abstract object graph, but rather the
<em>representation</em> of the object graph in memory.)</p>

<p>The mutator requests memory from some allocation service (usually
deeply integrated with the garbage collector for reasons we will see).
If there is a memory block immediately available to satisfy the
request, then the allocator hands that over. If there is not
sufficient free memory, then the mutator&rsquo;s allocation attempt invokes
the garbage collector coroutine.</p>

<p>Garbage collectors are also often divided into two categories: Copying
collectors, and Mark-Sweep collectors. Both collectors accomplish the
goal of identifying the reachable objects and reclaiming the
remainder, but they do it in different ways.</p>

<p>It is worthwhile to remember at this point that even though our object
graphs above are drawn as abstract circles and arrows, the objects are
represented somehow in memory.</p>

<p>For example, here is one potential representation for the above object
graph, where <code>-</code> denotes some value that the GC knows is not a
memory reference.</p>

<p id="target_anchor4" class=fullwidth></p>


<p>(Assume for this example that every GC allocated
object is made from four consecutive words in memory.)</p>

<script>
function make_memory_label(count, name_callback, val_callback) {
    var addresses = "ADDRESS";
    var contents = "CONTENT";
    var saw_one = true;
    for (i = 0; i < count; i++) {
        if (saw_one) { addresses += " | "; contents += " | ";}
        var name;
        if (name_callback) {
            name = name_callback(i);
        } else {
            name = "0x1";
            name += ("0000" + (i * 8).toString(16)).slice(-4);
        }
        addresses += name;
        if (val_callback) { contents += val_callback(i, name); }
        saw_one = true;
    }
    var label = "{ { " + addresses + " } | { " + contents + " } }";
    return label;
}
function make_memory_addr_val(state) {
var marks = state.marked;
var swept = state.swept;
var a_copied = state.a_copied;
var b_copied = state.b_copied;
var c_copied = state.c_copied;
var g_copied = state.g_copied;
var a_scanned = state.a_scanned;
var b_scanned = state.b_scanned;
var c_scanned = state.c_scanned;
var g_scanned = state.g_scanned;
var addr1=[
          "<nd> 0x10000 "+(swept?"":"(D) ")+"\\l",
          "0x10004 "+(swept?" (next)":"")+"\\l",
          "0x10008 \\l",
          "0x1000c \\l",
          "<na> 0x10010 (A) \\l",
          "0x10014 \\l",
          "0x10018 \\l",
          "0x1001c \\l",
          "<ne> 0x10020 "+(swept?"":"(E) ")+"\\l",
          "0x10024 "+(swept?" (next)":"")+"\\l",
          "0x10028 \\l",
          "0x1002c \\l",
          "<nb> 0x10030 (B) \\l",
          "0x10034 \\l",
          "0x10038 \\l",
          "0x1003c \\l",
         ];
var addr2 = [
          "<nc> 0x10040 (C) \\l",
          "0x10044 \\l",
          "0x10048 \\l",
          "0x1004c \\l",
          "<ny> 0x10050 \\l",
          "0x10054 "+(swept?" (next)":"")+"\\l",
          "0x10058 \\l",
          "0x1005c \\l",
          "<nf> 0x10060 "+(swept?"":"(F) ")+"\\l",
          "0x10064 "+(swept?" (next)":"")+"\\l",
          "0x10068 \\l",
          "0x1006c \\l",
          "<ng> 0x10070 (G) \\l",
          "0x10074 \\l",
          "0x10078 \\l",
          "0x1007c \\l",
         ];
var addr3 = [
          "<na> 0x20000 "+(a_copied?"(A') ":"")+"\\l",
          "0x20004 \\l",
          "0x20008 \\l",
          "0x2000c \\l",
          "<nb> 0x20010 "+(b_copied?"(B') ":"")+"\\l",
          "0x20014 \\l",
          "0x20018 \\l",
          "0x2001c \\l",
          "<nc> 0x20020 "+(c_copied?"(C') ":"")+"\\l",
          "0x20024 \\l",
          "0x20028 \\l",
          "0x2002c \\l",
          "<ng> 0x20030 "+(g_copied?"(G') ":"")+"\\l",
          "0x20034 \\l",
          "0x20038 \\l",
          "<lastg> 0x2003c \\l",
];
var val1 = [
           (swept ? "<vd> (free) " : "<vd> (header)"), // (D)
           (swept ? "<f0> 0x10020" : "<dpa> 0x10010"),
           (swept ? " - "          : "<dpe> 0x10020"),
           " - ",
           (marks ? "<va> (marked)" : a_copied ? "<va> (fwd)" : "<va> (header)"), // (A)
           (a_copied ? "<afwd> 0x20000" : " - "),
           " - ",
           " - ",
           (swept ? "<ve> (free) " : "<ve> (header)"), // (E)
           (swept ? "<f1> 0x10050" : "<epf> 0x10060"),
           " - ",
           " - ",
            // (B)
           (marks ? "<vb> (marked)" : b_copied ? "<vb> (fwd)" : "<vb> (header)"),
           (b_copied ? "<bfwd> 0x20010" : "<bpc> 0x10040"),
           " - ",
           " - ",
          ];
var val2 = [
           (marks ? "<vc> (marked)" : c_copied ? "<vc> (fwd)" : "<vc> (header)"), // (C)
           (c_copied ? "<cfwd> 0x20020" : "<cpg> 0x10070"),
           " - ",
           " - ",
           (swept ? "<vy> (free) " : "<vy> (header)"), // unused
           (swept ? "<f2> 0x10060" : " - "),
           " - ",
           " - ",
           (swept ? "<vf> (free) " : "<vf> (header)"), // (F)
           (swept ? "<f3> null " : " - "),
           (swept ? " - "          : "<fpe> 0x10020"),
           " - ",
           (g_copied ? "<vg> (fwd)" : marks ? "<vg> (marked)" : "<vg> (header) "), // (G)
           (g_copied ? "<gfwd> 0x20030" : " - "),
           " - ",
           " - ",
          ];
var val3 = [
           ((a_scanned || a_copied) ? "<va> (header)" : " - "), // (A')
           " - ",
           " - ",
           " - ",
           // (B')
           (b_scanned ? "<vb> (header) " : b_copied ? "<vb> (header)" : " - "),
           (b_scanned ? "<bpc2> 0x20020 " : b_copied ? "<bpc> 0x10040" : " - "),
           " - ",
           " - ",
           // (C')
           (c_scanned ? "<vc> (header) " : c_copied ? "<vc> (header)" : " - "),
           (c_scanned ? "<cpg2> 0x20030 " : c_copied ? "<cpg> 0x10070" : " - "),
           " - ",
           " - ",
            // (G')
           (g_scanned ? "<vg> (header) " : g_copied ? "<vg> (header)" : " - "),
           " - ",
           " - ",
           " - ",
          ];
    return [addr1, val1, addr2, val2, addr3, val3];
}
function make_graph_in_memory(options) {
    var original = options.original;
    var marking  = options.marking;
    var marked = options.marked;
    var swept  = options.swept;
    var free_list = options.free_list;
    var conservative_r2 = options.conservative_r2;
    var avail = options.avail;
    var rf = make_regfile("RF");
    var addrval = make_memory_addr_val(options);
    var addr1 = addrval[0];
    var val1 = addrval[1];
    var addr2 = addrval[2];
    var val2 = addrval[3];
    var addr3 = addrval[4];
    var val3 = addrval[5];
    var a_copied = options.a_copied;
    var b_copied = options.b_copied;
    var c_copied = options.c_copied;
    var g_copied = options.g_copied;
    var a_scanned = options.a_scanned;
    var b_scanned = options.b_scanned;
    var c_scanned = options.c_scanned;
    var g_scanned = options.g_scanned;
    var highlight_bpc2 = options.highlight_bpc2;
    var highlight_rc2 = options.highlight_rc2;
    var highlight_cfwd = options.highlight_cfwd;
    rf.label = "<id>RF | { { <r0>r0 | <r1>r1 | <r2>r2 | <r3>r3 } |" +
        " { <r0v>"+(a_copied?"0x20000":"0x10010")+
        " | <r1v>"+(b_copied?"0x20010":"0x10030")+
        " | <r2v>"+(conservative_r2?"0x10000":"-")+
        " | <r3v>"+(c_copied?"0x20020":"0x10040")+
        " } }";
    rf.pos = "0,500!";
    var from_space = options.from_space;
    var two_space = options.two_space;
    var two_space_content = !two_space ? "" : [
        'mem3 [shape="record",',
        'pos="-180,500!",',
        'label=\"'+make_memory_label(16,
                function (i) { return addr3[i]; },
                function (i, addr) { return val3[i]; })+'\",',
        '];',
        (!from_space ? "" : a_copied ? 'mem1:afwd:w -> mem3:va:e [style="dashed"];' : ""),
        (!from_space ? "" : b_copied ? 'mem1:bfwd:w -> mem3:vb:e [style="dashed"];' : ""),
        (!from_space ? "" : c_copied ? 'mem2:cfwd:w -> mem3:vc:e ['+(highlight_cfwd ? 'penwidth="3.0",' : '')+'style="dashed"];' : ""),
        (!from_space ? "" : g_copied ? 'mem2:gfwd:w -> mem3:vg:e [style="dashed"];' : ""),
        (b_scanned ? 'mem3:bpc2:e -> hidden_bc2 ['+(highlight_bpc2 ? 'penwidth="3.0",' : '')+'arrowhead="none"];' : b_copied ? 'mem3:bpc:e -> hidden_rc [arrowhead="none"];' : ""),
        (b_scanned ? 'hidden_bc2 -> mem3:vc:e' + (highlight_bpc2 ? '[penwidth="3.0"]':';') : ""),
        (c_scanned ? 'mem3:cpg2:e -> hidden_cg2 [arrowhead="none"];' : c_copied ? 'mem3:cpg:e -> mem2:ng:w;' : ""),
        (c_scanned ? 'hidden_cg2 -> mem3:vg:e;' : ""),
        (avail ? 'avail[pos="-90,375!"]; ' : ''),
        ((avail && avail.trim() != "") ? 'avail -> ' + avail + ';': ''),
    ].join('\n');
    var from_space_content = [
        'mem1 [shape="record",',
        !from_space ? 'style="invis",' : "",
        'pos="120,500!",',
        'label=\"'+make_memory_label(16,
            function (i) { return addr1[i]; },
            function (i, addr) { return val1[i]; })+'\",',
        '];',
        'hidden_ra  [ pos="-50,550!", shape="point", label="", width=0 ];',
        'hidden_rb  [ pos="-50,450!", shape="point", label="", width=0 ];',
        'hidden_rc  [ pos="-30,660!", shape="point", label="", width=0 ];',
        'hidden_da  [ pos="200,590!", shape="point", label="", width=0 ];',
        'hidden_de  [ pos="200,540!", shape="point", label="", width=0 ];',
        'hidden_bc  [ pos="220,590!", shape="point", label="", width=0 ];',
        'hidden_bc2  [ pos="-100,510!", shape="point", label="", width=0 ];',
        'hidden_cg  [ pos="375,590!", shape="point", label="", width=0 ];',
        'hidden_cg2  [ pos="-100,430!", shape="point", label="", width=0 ];',
        'hidden_fe1 [ pos="375,350!", shape="point", label="", width=0 ];',
        'hidden_fe2 [ pos="25,350!", shape="point", label="", width=0 ];',
        'hidden_yf [ pos="375,500!", shape="point", label="", width=0 ];',
        'hidden_fz [ pos="375,450!", shape="point", label="", width=0 ];',
        free_list ? 'free_list [ pos="0,620!", shape="rectangle", label="free-list" ];' : '',
        'mem2 [shape="record",',
        !from_space ? 'style="invis",' : "",
        'pos="300,500!",',
        'label=\"'+make_memory_label(16,
            function (i) { return addr2[i]; },
            function (i, addr) { return val2[i]; })+'\",',
        '];',
    ].join('\n');

    var graph_in_memory = ['digraph { node [fontsize=8]; ',
        'bgcolor="transparent";',
        'layout="neato"; inputscale=72;',
        // 'overlap="false";',
        // 'node [ pin=true ];',
        'rankdir="LR";',
        'nodesep=1.2;',
        // 'rank="same";',
        'splines="curved";',
        // 'node [font = "10px Monospace"];',
        render_node(rf),
        from_space_content,
        // !marking ? 'RF:r0:w -> hidden_ra [arrowhead="none"];' : 'RF:r0:w -> hidden_ra [arrowhead="none",penwidth=3.0];',
        // !marking ? 'hidden_ra -> mem1:na:w;' : 'hidden_ra -> mem1:na:w [label="1", penwidth=3.0];',
        a_copied ? 'RF:r0:w -> mem3:va:e;' : !marking ? 'RF:r0v:e -> mem1:na:w;' : 'RF:r0v:e -> mem1:na:w [label="1", penwidth=3.0];',
        b_copied ? 'RF:r1:w -> mem3:vb:e;' : !marking ? 'RF:r1:w -> hidden_rb [arrowhead="none"];' : 'RF:r1:w -> hidden_rb [arrowhead="none",penwidth=3.0];',
        b_copied ? "" : !marking ? 'hidden_rb -> mem1:nb:w;' : 'hidden_rb -> mem1:nb:w [label="2", penwidth=3.0,penwidth=3.0];',
        c_copied ? 'RF:r3:w -> mem3:vc:e'+(highlight_rc2 ? "[penwidth=3.0]" : "") + ';' : !marking ? 'RF:r3:w -> hidden_rc [arrowhead="none"];' : 'RF:r3:w -> hidden_rc [arrowhead="none",penwidth=3.0];',
        conservative_r2 ? 'RF:r2v:e -> mem1:nd:w [penwidth=3.0];' : '',
        b_scanned ? '' : !marking ? 'hidden_rc -> mem2:nc:w;' : 'hidden_rc -> mem2:nc:w [label="5", penwidth=3.0];',
        two_space ? '' : original ? 'mem1:dpa:e -> hidden_da [arrowhead="none"];' : '',
        two_space ? '' : original ? 'hidden_da -> mem1:va:e;' : '',
        two_space ? '' : original ? 'mem1:dpe:e -> hidden_de [arrowhead="none"];' : '',
        two_space ? '' : original ? 'hidden_de -> mem1:ve:e;' : '',
        two_space ? '' : original ? 'mem1:epf:e -> mem2:nf:w;' : '',
        b_copied ? '' : !marking ? 'mem1:bpc:e -> hidden_bc [arrowhead="none"];' :
                 'mem1:bpc:e -> hidden_bc [arrowhead="none", label="3", penwidth=3.0];',
        b_copied ? '' : !marking ? 'hidden_bc -> mem2:nc:w;' : 'hidden_bc -> mem2:nc:w [penwidth=3.0];',
        c_copied ? '' : !marking ? 'mem2:cpg:e -> hidden_cg [arrowhead="none"];' :
                 'mem2:cpg:e -> hidden_cg [arrowhead="none", label="4", penwidth=3.0];',
        c_copied ? '' : !marking ? 'hidden_cg -> mem2:vg:e;' : 'hidden_cg -> mem2:vg:e [penwidth=3.0];',
        two_space ? '' : original ? 'mem2:fpe:e -> hidden_fe1 [arrowhead="none"];' : '',
        two_space ? '' : original ? 'hidden_fe1 -> hidden_fe2 [arrowhead="none"];' : '',
        two_space ? '' : original ? 'hidden_fe2 -> mem1:ne:w' : '',
        free_list ? 'free_list -> mem1:nd:w [style="dashed",penwidth=3.0]' : '',
        free_list ? 'mem1:f0:e -> hidden_de [style="dashed",penwidth=3.0, arrowhead="none"]' : '',
        free_list ? 'hidden_de -> mem1:ve:e [style="dashed",penwidth=3.0]' : '',
        free_list ? 'mem1:f1:e -> mem2:ny:w [style="dashed",penwidth=3.0]' : '',
        free_list ? 'mem2:f2:e -> hidden_yf [style="dashed",penwidth=3.0, arrowhead="none"]' : '',
        free_list ? 'hidden_yf -> mem2:vf:e [style="dashed",penwidth=3.0]' : '',
        two_space_content,
        '}'].join('\n');

    return graph_in_memory;
}
var graph_in_memory = make_graph_in_memory({from_space:true,original:true});
post_graph("target_anchor4", graph_in_memory, {no_dims:true});
</script>


<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
Regarding the &ldquo;(header)&rdquo; words in the diagram:
Garbage collectors often require that the
GC-managed memory be formatted in a way such that the collector can
&ldquo;parse&rdquo; it when doing a scan over its address space.
<br></br>
As part of this &ldquo;parsing&rdquo;, the GC needs to be able to derive the size
of each object it looks at.
<br></br>
The address-space could be
partitioned into size classes.
Or if objects in a
block are to be variable-sized, the size could be recorded in object
headers (which are often needed anyway to store things like mark bits or other data).
<br></br>
Clever representation techniques exist that avoid using
header words for small objects (like pairs) without requiring size-class
partitioning; but I digress.
</span></p>

<p>In these pictures, there is no difference between an arrow pointing to
the left- verus right-side of a memory cell; so the occurrence of the
pointer to A (<code>0x10010</code>) in <code>r0</code> is no different than the occurrence
of that same value in memory cell <code>0x10004</code> (the first non-header word
of <code>D</code>), even though the arc for the former is pointing at the left
side of the first memory cell of <code>A</code>, and the arc for the latter is
pointing at the right side of that memory cell.</p>

<a name="Mark-Sweep.Collection"></a>
<h3>Mark-Sweep Collection</h3>

<p>A Mark-Sweep collector works by first doing a traversal of the
reachable memory, <em>marking</em> each object it finds (e.g. by setting a
bit reserved in the object header, or in separate mark bitmap if there
is no such bit reserved). This traversal requires some amount of extra
memory in reserve to track remaining work for the trace (e.g. a &ldquo;mark
stack&rdquo; of objects we are in the midst of traversing, and/or a queue of
objects scheduled for future traversal).</p>

<a name="The..Mark..phase"></a>
<h4>The &ldquo;Mark&rdquo; phase</h4>

<p>Here is a sketch of the traversals that the garbage collector
makes in order to mark each reachable object.</p>

<p id="target_anchor5" class="fullwidth"></p>


<script>
var graph_in_memory = make_graph_in_memory({from_space:true,marking:true, marked:true});
post_graph("target_anchor5", graph_in_memory, {no_dims: true});
</script>


<p>As reflected in the diagram above, each object that the GC reaches has
its mark bit set to &ldquo;marked&rdquo; in its header word.</p>

<p>The numbers on the arcs above are meant to correspond to a
hypothetical traversal order as the GC marks the memory; particular
tracing strategies may yield different orders. (No matter what, we
will not trace object &ldquo;G&rdquo; until after we have seen &ldquo;C&rdquo; via some
route.)</p>

<p>Also, I have left the memory for the mark-stack out of the picture; in
this case the mark-stack would not grow very large, but in general one
must anticipate the mark-stack growing as large as the longest path
through the reachable object graph. (The longest path in this case is
three objects long.)</p>

<a name="The..Sweep..phase"></a>
<h4>The &ldquo;Sweep&rdquo; phase</h4>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
As previously mentioned, the GC much be able to &ldquo;parse&rdquo; the memory when
scanning the address space.
<br></br>
In the case of the Mark-Sweep collector, in addition to having to be able
to derive the size of each object, we also need the mark bit for each object
to be located at predictable location.
</span>
A Mark-Sweep collector does not move objects, so it must resort to
metadata such as a free-list to track reclaimed memory.  So, after the
marking is finished, the GC then <em>sweeps</em> over the memory: it walks
over the GC-managed address space
and builds up a free-list of blocks that were not marked during the traversal.</p>

<p id="target_anchor6" class="fullwidth"></p>


<script>
var graph_in_memory = make_graph_in_memory({from_space:true,marked:true, swept: true, free_list: true});
post_graph("target_anchor6", graph_in_memory, {no_dims:true});
</script>


<p>(The arcs that make up the free-list above are dashed, to distinguish
them from the &ldquo;real&rdquo; references that make up the object graph. In the
above scheme, the pointer to the next element in the free list is held
in the second word of each free block.<label for='&lsquo;free-list-next&rsquo;' class='margin-toggle'> &#8853;</label><input type='checkbox' id='&lsquo;free-list-next&rsquo;' class='margin-toggle'/><span class='marginnote'>&lsquo;Putting </span>)</p>

<p>With that, the GC is done; the mutator (i.e. main program) is now free
to take blocks off of the free-list to satisfy memory requests.</p>

<a name="L.span.id..conservative-gc..Conservative.Collection..span."></a>
<h3><span id="conservative-gc">Conservative Collection</span></h3>

<p>A conservative collector is a particular kind of Mark-Sweep collector
where it is not provided enough information to know whether one or
more words of reachable data that it encounters should be interpreted
as a reference or not. Such a collector is forced to assume
(conservatively) that if the encountered datum is an allocated address
on the GC-managed heap, then that could be its purpose from the
perspective of the mutator, and therefore that datum must be treated
as a reference to memory.</p>

<p>In the diagrams above, I said that <code>-</code> denotes some value that the
GC knows is not a memory reference. In a conservative collector
without any type information, the only kind of value that can be
interpreted that way is one that lies outside the addreses space of
the GC-heap.</p>

<p>So for example, if we had the same picture as above, but the register
<code>r2</code> happen to hold an integer with value <code>0x10000</code>, and the
conservative collector is not told &ldquo;<code>r2</code> holds a non-reference at this
point in the execution&rdquo;, then this diagram would result:</p>

<p id="target_anchor_conservative_gc" class="fullwidth"></p>


<script>
var graph_in_memory = make_graph_in_memory({from_space:true,original:true,conservative_r2:true});
post_graph("target_anchor_conservative_gc", graph_in_memory, {no_dims:true});
</script>


<p>That is, even though in the program itself, the value <code>0x10000</code> is not
meant to be interpreted as a memory address, <code>D</code> (and <code>E</code> and <code>F</code>) are
all conservatively classified as live objects.</p>

<a name="Copying.Collection"></a>
<h3>Copying Collection</h3>

<p>A Copying collector moves objects from one location to another as part
of its tracing process, and updates the references in reachable
objects as it goes.</p>

<p>I will first illustrate this using our low-level memory graph,
but I will not draw the edges for the dead objects anymore,
as they add significant clutter to the picture.</p>

<a name="The.Reserved..To-space."></a>
<h4>The Reserved &ldquo;To-space&rdquo;</h4>

<p>First, we need to have some reserved memory to target as we copy
objects.  I have put this target memory (the so-called &ldquo;to-space&rdquo;) on
the left-hand side of the picture; the nearby &ldquo;avail&rdquo; circle is a
local variable in the GC that indicates the starting address that we
can use to copy objects into; so it starts off at the first address,
<code>0x20000</code>.</p>

<p id="target_anchor7" class="fullwidth"></p>


<script>
var graph_in_memory = make_graph_in_memory({from_space:true,original:true, two_space:true, avail: "mem3:na"});
post_graph("target_anchor7", graph_in_memory, {no_dims:true});
</script>


<a name="Copying.from.the.Roots"></a>
<h4>Copying from the Roots</h4>

<p>First we walk over the roots (in our simplified model, the registers),
and copy over all of the objects we see. So the below results after
we scan just the first two registers, copying the objects <code>A</code> and <code>B</code>
into new locations, respectively labelled <code>A'</code> and <code>B'</code>, and updating
<code>avail</code> accordingly.</p>

<p><a id="memory_post_copy_a_and_b"><p id="target_anchor8a" class="fullwidth"></p></a></p>

<script>
var graph_in_memory = make_graph_in_memory({from_space:true,original:true, two_space:true,
    a_copied:true, b_copied:true, avail: "mem3:nc"});
post_graph("target_anchor8a", graph_in_memory, {no_dims:true});
</script>


<p>Note that as we copy objects from the source memory
(the so-called &ldquo;from-space&rdquo;), we must maintain a map from the
original object to its newly allocated copy. In this model,
this is accomplished by imperatively overwriting the original object
with <code>fwd</code> header marking it as &ldquo;forwarded&rdquo; as well as a &ldquo;forwarding
pointer&rdquo; (the dashed arcs) that points to the new location.</p>

<p>The copies themselves just get the original memory contents, so they
may have pointers to the old objects in the source memory (such as the
<code>B' -&gt; C</code> arc in the picture). Those will get fixed up later.</p>

<p>We still need to scan the rest of the registers, which copies <code>C</code> as
shown below.</p>

<p id="target_anchor8b" class="fullwidth"></p>


<script>
var graph_in_memory = make_graph_in_memory({from_space:true,original:true, two_space:true,
    highlight_rc2: true, highlight_cfwd: true,
    a_copied:true, b_copied:true, c_copied:true, avail: "mem3:ng"});
post_graph("target_anchor8b", graph_in_memory, {no_dims:true});
</script>


<a name="Scan.the..To-space."></a>
<h4>Scan the &ldquo;To-space&rdquo;</h4>

<p>Now that we have finished scanning the roots, we start the fixup
process of scanning over the &ldquo;to-space.&rdquo; Every time we encounter a
pointer into the &ldquo;from-space&rdquo;, there are two cases to consider: Either
it is an already copied object (in which case there will be a
forwarding pointer installed), or it is an object that is not yet
copied.</p>

<p>If its a forwarded object, then we fixup our reference so that it
points to the new copy in the &ldquo;to-space&rdquo;. We see this when the fixup
scan is scanning over <code>B'</code> and sees the <code>B' -&gt; C</code> reference, which it
then rewrites to a <code>B' -&gt; C'</code> reference, highlighted below.</p>

<p id="target_anchor9" class="fullwidth"></p>


<script>
var graph_in_memory = make_graph_in_memory({from_space:true,original:true, two_space:true,
    highlight_bpc2:true,
    a_copied:true, b_copied:true, c_copied:true,
    a_scanned:true, b_scanned:true, avail: "mem3:ng"
    });
post_graph("target_anchor9", graph_in_memory, {no_dims:true});
</script>


<p>The fixup scan is not yet complete; the next object it encounters,
<code>C'</code>, illustrates the other case of a reference to an object (<code>G</code>
here) that has not yet been copied. In this case, it just copies it,
in the same manner that we did when we were scanning the roots. (This
adds the forwarded object to the set of objects enqueued for fixup
scanning.)</p>

<p id="target_anchor10" class="fullwidth"></p>


<script>
var graph_in_memory = make_graph_in_memory({from_space:true,original:true, two_space:true,
    a_copied:true, b_copied:true, c_copied:true, g_copied:true,
    a_scanned:true, b_scanned:true, c_scanned:true, avail: "mem3:lastg:s",
    });
post_graph("target_anchor10", graph_in_memory, {no_dims:true});
</script>


<a name="Reclaim.the..From-space."></a>
<h4>Reclaim the &ldquo;From-space&rdquo;</h4>

<p>Eventually the fixup scan will finish processing all of the &ldquo;to-space&rdquo;
(since there are only a finite number of objects that could be
enqueued). At this point, there will be no more reachable objects in
any part of the from-space, and thus those memory blocks can be
reclaimed in their entirety.</p>

<p id="target_anchor11" class="fullwidth"></p>


<script>
var graph_in_memory = make_graph_in_memory({two_space:true,
    a_copied:true, b_copied:true, c_copied:true, g_copied:true,
    a_scanned:true, b_scanned:true, c_scanned:true, g_scanned:true, avail: "mem3:lastg:s"
    });
post_graph("target_anchor11", graph_in_memory, {no_dims:true});
</script>


<p>Woo, done!</p>

<a name="A.Spectrum.of.Collectors"></a>
<h3>A Spectrum of Collectors</h3>

<p>The mark-sweep and copying collection methods illustrated above
actually form two extreme points on a spectrum of implementation
techhniques.</p>

<p>In practice, many collectors are neither entirely mark-sweep nor
copying, but rather employ a hybrid strategy, where some memory
regions are reclaimed via a copying-collection, while others are
managed via a mark-sweep method. For example, some generational
collectors work by promoting objects from a young space into an older
space via copying collection, but then the last space (with the eldest
objects) can be managed via mark-sweep.</p>

<p>As another example of a hybrid strategy, there exist conservative
collectors (such as &ldquo;mostly copying&rdquo; collectors) where exact type
information is known for the heap-allocated objects, but the types are
not known for the roots (i.e. the registers and values embedded in the
stack). In such systems, it is not safe to move objects that are
referenced via conservatively-scanned words. Such objects are &ldquo;pinned&rdquo;
in place (which means that it cannot be moved by the collector) for
the duration of this collection, and thus space in their memory blocks
can only be reclaimed with via a mark-sweep collection.  However,
objects reachable solely via precisely-scanned words <em>can</em> be moved,
and memory blocks made up solely of such objects can be reclaimed via
a copying-collection strategy.</p>

<a name="L.span.id..pinning-support..Pinning.Support..span."></a>
<h3><span id="pinning-support">Pinning Support</span></h3>

<p>In our discussion to follow, rather than attempt to characterize a
collector as &ldquo;mark-sweep&rdquo; or &ldquo;copying&rdquo;, it will be more useful to
distinguish collectors in terms of whether or not they support
&ldquo;pinning&rdquo;. In a language runtime that supports pinning, a mutator
(i.e. the main program linked with the collector coroutine) can tag
any live object as &ldquo;pinned&rdquo;.</p>

<p>(In the example of &ldquo;mostly copying&rdquo; above, such pinning is
accomplished by putting a reference into a conservatively-scanned
root. However, some language runtimes provide first class support for
pinning; for example, the Microsoft CLR once offerred a
<a href="https://msdn.microsoft.com/en-us/library/1dz8byfh.aspx"><code>pin_ptr</code></a> smart-pointer for Managed C++ that would prevent
a referenced object from moving.)</p>

<p>In other words, in a runtime with pinning, the mutator dictates which
objects can be managed via copying collection. If the runtime does not
support pinning, then it is the <em>collector</em> that dictates which
objects are managed via copying; the mutator cannot rely on the
collector allowing arbitrary objects to be pinned.</p>

<a name="Simplifying.our.diagrams"></a>
<h3>Simplifying our diagrams</h3>

<p>While I am sure it was fun to decode the above renderings of memory
banks, now that we have seen how collectors work at a low-level, I am
going to revert to the earlier high-level object notation.  It should
be easier for you to read, and (just as important) for me to write.</p>

<p id="target_anchor12"></p>


<script>
var gc_struct = simple_gc_structure();
var rf = gc_struct[0];
var d = gc_struct[1];

var a = rf.r0.target;
var b = rf.r1.target;
var c = rf.r3.target;

a_and_b = [a,b];
a_and_b.is_subgraph = true;
a_and_b.id = "cluster_a_and_b";
a_and_b.rank = "same";
a_and_b.style = "invis";

var gc_heap = [];
gc_heap.push(a_and_b);
for_each_reachable([c,d], function (o) { if (o !== rf) { gc_heap.push(o); } })

gc_heap.is_subgraph = true;
gc_heap.style = "invis";
gc_heap.id = "cluster_gc_heap";
var content = render_objects([rf, a_and_b, gc_heap, d]);
post_graph("target_anchor12", digraph(content, {rankdir:"LR"}), {no_dims:true});
</script>


<p>To show a copying collector&rsquo;s intermediate state in a high-level
picture, I will show newly copied objects with prime marks (and, if
possible, in a separately delineated to-space), and a dashed-line for
forwarding pointers.</p>

<p>Here is an example of this style of rendering, using the earlier
example at <a href="#memory_post_copy_a_and_b">the point where</a> a copying
collector had scanned just registers <code>r0</code> and <code>r1</code> (but had not yet
copied <code>C</code> from register <code>r3</code>), highlighting the copied objects and
the newly written references (including the dashed forwarding
pointers).</p>

<p id="target_anchor_simplified_copying"></p>


<script>
var rf = make_regfile("RF");
// rf.label = "{" + rf.label + "}";
var a = { id: "A" };
var b = { id: "B" };
var c = { id: "C" };
var d = { id: "D" };
var e = { id: "E" };
var f = { id: "F" };
var g = { id: "G" };
var a2 = { id: "A2", label: "A'", penwidth: "3.0" };
var b2 = { id: "B2", label: "B'", penwidth: "3.0" };
b.f0 = c;
c.f0 = g;
d.f0 = a;
d.f1 = e;
e.f0 = f;
f.f0 = e;
b2.f0 = c;
a.fwd = highlight(dashed_edge(a2));
b.fwd = highlight(dashed_edge(b2));
rf.link(0, a2, {penwidth: "3.0"});
rf.link(1, b2, {penwidth: "3.0"});
rf.link(3, c);

var a_and_b = [a, b];
a_and_b.is_subgraph = true;
a_and_b.rank="same";
var gc_heap1 = [a_and_b, c, d, e, f, g];
gc_heap1.is_subgraph = true;
gc_heap1.label = "from space";
gc_heap1.id = "cluster_gc_heap1";
var gc_heap2 = [a2, b2];
gc_heap2.is_subgraph = true;
gc_heap2.id = "cluster_gc_heap2";
gc_heap2.label = "to space";
gc_heap2.rank = "same";
gc_heaps = [gc_heap1, gc_heap2];
gc_heaps.is_subgraph = true;
// gc_heaps.id = "cluster_all_gc_heaps";
// gc_heaps.rankdir = "TD";
var objects = [rf, gc_heaps];
post_objects("target_anchor_simplified_copying", objects, {rankdir:"LR",no_dims:true});
</script>


<p>(This rendering is arguably just as clear (or unclear) as our earlier
<a href="#memory_post_copy_a_and_b">memory diagram</a> was, apart from some
annoying edge-crossings due to the graphviz layout engine.)</p>

<a name="Conclusion"></a>
<h2>Conclusion</h2>

<p>Well, I don&rsquo;t know if you learned anything about GC from this post.
I certainly learned a lot about techniques for wrestling with
graphviz.  :)</p>

<p>There will be a followup post soon-ish that will bring Rust into the
picture, discussing what GC and Rust integration even <em>means</em>, and
the host of problems that crop up.</p>
]]></content>
  </entry>
  
</feed>
