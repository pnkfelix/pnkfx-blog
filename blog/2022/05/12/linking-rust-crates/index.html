
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Linking Rust Crates, Part 1 - The {pnk}f(eli)x Blog</title>
  <meta name="author" content="Felix S. Klock II">

  
  <meta name="description" content="Working on the Rust compiler, one topic that I come across from time to time is
&ldquo;what is supposed to happen when we use these particular &hellip;">
  

  <script src="https://unpkg.com/mermaid@8.9.3/dist/mermaid.min.js"></script>
<script>
  $(document).ready(function () {
      mermaid.initialize({
          startOnLoad:true,
          theme: "default",
      });
      window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid'));
  });
</script>


  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://blog.pnkfx.org/blog/2022/05/12/linking-rust-crates/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="The {pnk}f(eli)x Blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<!-- mermaid support as documented at http://insightfultroll.com/blog/2021/03/30/using-mermaid-with-jekyll/ -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>mermaid.initialize({startOnLoad:true});</script>

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">The {pnk}f(eli)x Blog</a></h1>
  
    <h2>The informal ramblings of an ex-pat PL enthusiast</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:blog.pnkfx.org" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Linking Rust Crates, Part 1</h1>
    
    
      <p class="meta">
        








  


<time datetime="2022-05-12T01:50:00-04:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>Working on the Rust compiler, one topic that I come across from time to time is
&ldquo;what is <em>supposed</em> to happen when we use these particular features of my
tools?&rdquo; More specifically, Rust has various metaphorical knobs that allow
fine-grained control of the object code generated by the compiler, several of
which are related to the process of linking that code to other object code.</p>

<p>From <a href="https://doc.rust-lang.org/reference/linkage.html">Linkage</a> chapter of the Rust Reference, we can see there are seven
kinds of crates: <code>bin</code>, <code>lib</code>, <code>dylib</code>, <code>staticlib</code>, <code>cdylib</code>, <code>rlib</code>, and <code>proc-macro</code>.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
I had originally intended to cover all seven, but the time got late and the post got long
and I decided that <code>proc-macro</code> can be dealt with another day.
</span></p>

<p>What this post is going to do is walk through the first six of the crate types
listed above and demonstrate: how to build an example of such a crate, how to
link to it, and how to run with that linked crate.</p>

<!-- more -->


<p>In later posts, I will explore the various attributes and command-line flags
that can influence the linking step. But right now, I want to establish the
foundation for that later discussion.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
Some phenomena require mixing multiple crate types in order to observe corner
cases that are worth addressing. I am leaving that for a future post as well.
</span></p>

<p>These initial examples are as simple as possible. We will want to actually
demonstrate each case running. Since most crate types are not executable, that
means we will need multiple crates in almost all of our examples.</p>

<p>Also, I will not be using Cargo in any of my examples. I will try to note points
where things I am doing are deviating from what you would normally do if you
were using Cargo (such as my use of <code>extern crate</code> in these examples), and
hopefully a later post will explore the status quo of how Cargo handles various
linkage scenarios. But, I am taking baby steps here; lets focus on <code>rustc</code> alone
for now.</p>

<p>At a very high level, we will be looking at object file structures that
look something like this:</p>

<div class="mermaid">
graph LR
SbSource[simple-bin.rs]
SbObj["simple-bin (exec)"]
SbSource --> SbCompile((rustc))
SbCompile -- generates --> SbObj
</div>


<p>That is: Given some input like <code>simple-bin.rs</code>, you can feed into <code>rustc</code> and
get an executable as its output.</p>

<p>The actual code for a case like the above is trivial:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="c1">// simple-bin.rs</span>
</span><span class='line'><span class="err">#</span><span class="o">!</span><span class="p">[</span><span class="n">crate_type</span><span class="o">=</span><span class="s">&quot;bin&quot;</span><span class="p">]</span> <span class="c1">// (&quot;bin&quot; is the default; other examples vary here.)</span>
</span><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Running main from {}&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">!</span><span class="p">());</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>With that code in place, you can compile and run the program. (In practice
 developers would usally do this via <code>cargo run</code>.)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>% rustc --out-dir out/bins/ps/dsb simple-bin.rs
</span><span class='line'>% ls out/bins/ps/dsb
</span><span class='line'>simple-bin
</span><span class='line'>% out/bins/ps/dsb/simple-bin
</span><span class='line'>Running main from simple-bin.rs
</span><span class='line'>%
</span></code></pre></td></tr></table></div></figure>


<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
I am using a bespoke directory naming convention unique to this blog post.
For example,  in <code>--out-dir</code> in this invocation: All output goes under <code>out</code>.
Executable binaries go under <code>out/bin</code>. If static linkage was preferred during the build, then it goes under <code>out/bin/ps</code> (for &ldquo;prefer static&rdquo;); if dynamic linkage was preferred, then under <code>out/bin/pd</code> (for &ldquo;prefer dynamic&rdquo;); the post explains this &ldquo;preference&rdquo; further down, with the discussion of <code>-Cprefer-dynamic</code>. Finally, I added a directory named via a unique key for each test (here, <code>dsb</code>, for &ldquo;demo-simple-bin&rdquo;), so that the <code>ls</code> invocations are tidy.
</span>
In these examples, I will be overriding the default output directory so that each example
will have its own direcrory. This forces the examples to specify precisely where it is
getting its libraries from; it is a good way to double-check one&rsquo;s understanding of what
is actually happening under-the-hood.</p>

<a name="Simple.linkage.of.a..code.lib..code..crate"></a>
<h2>Simple linkage of a <code>lib</code> crate</h2>

<p>Of course, since our subject of interest is linking, we will want to look at
examples that involve library crates. Here is perhaps the simplest intance of
that:</p>

<div class="mermaid">
graph TD
SlSource[simple-lib.rs]
SlObj[libsimple_lib.rlib]
SlSource --> SlCompile((rustc))
SlCompile --generates --> SlObj
DemoSlCompile -.finds file.-> SlObj
DemoSlSource[demo-simple-lib.rs]
DemoSlObj[demo-simple-lib.obj]
DemoSlSource --> DemoSlCompile((rustc))
SlObj --> link
DemoSlCompile -- generates --> DemoSlObj
subgraph "implicit &nbsp;&nbsp; link-step"
DemoSlObj --> link
link((link))
end
link -- generates --> DemoSlBin["demo-simple-lib (exec)"]
</div>


<p>What is the advantage of separating your code like this, into separate libraries
that are subsequently linked? One reason to do this is to identify which code is
under active development, and focus on its development separately from the
overall product. So, if <code>simple-lib.rs</code> were under development, we could focus
just on that, and not have our tools spend time processing <code>demo-simple-lib.rs</code>.
Or vice-versa: If <code>demo-simple-lib.rs</code> were under development, then we could
focus on that, and our tools would process, at most, the <code>libsimple_lib.rlib</code>
library produced by running <code>rustc</code> on <code>simple-lib.rs</code>.</p>

<p>Here are the code and commands that correspond to the picture above
for compiling <code>demo-simple-lib</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="c1">// simple-lib.rs</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// generate a library (what kind? The &quot;default&quot; for this platform)</span>
</span><span class='line'><span class="err">#</span><span class="o">!</span><span class="p">[</span><span class="n">crate_type</span><span class="o">=</span><span class="s">&quot;lib&quot;</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Here&#39;s the function we&#39;ll provide to our clients.</span>
</span><span class='line'><span class="k">pub</span> <span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Running main from {}&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">!</span><span class="p">());</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="c1">// demo-simple-lib.rs</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// link to library built from simple-lib.rs</span>
</span><span class='line'><span class="k">extern</span> <span class="n">crate</span> <span class="n">simple_lib</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// call function it exports</span>
</span><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span> <span class="n">simple_lib</span><span class="o">::</span><span class="n">main</span><span class="p">();</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>We have omitted <code>#![crate_type="bin]"</code> from <code>demo-simple-lib.rs</code> because that is
the default crate type.</p>

<p>(In practice, most modern Rust code does not use <code>extern crate</code>; instead, people
let Cargo handle injecting compiler options that achieve a similar effect. For now,
we will use <code>extern crate</code> in our initial examples, so that the Rust code itself
indicates its dependence on a separate library.)</p>

<p>With the above two files in place, we can compile each of them
and run the resulting binary.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>% rustc --out-dir out/ps/sl simple-lib.rs
</span><span class='line'>% ls out/ps/sl
</span><span class='line'>libsimple_lib.rlib
</span><span class='line'>% rustc --out-dir out/bins/ps/dsl demo-simple-lib.rs -Lout/ps/sl
</span><span class='line'>% ls out/bins/ps/dsl
</span><span class='line'>demo-simple-lib
</span><span class='line'>% out/bins/ps/dsl/demo-simple-lib
</span><span class='line'>Running main from simple-lib.rs
</span><span class='line'>%
</span></code></pre></td></tr></table></div></figure>


<p>The first <code>rustc</code> invocation, compiling <code>simple-lib.rs</code>, is much like our <code>simple-bin.rs</code> example.
The second <code>rustc</code> invocation, compiling <code>demo-simple-lib.rs</code>, has something new: it is
passing the option <code>-Lout/sl</code>, which tells the compiler &ldquo;if you need to resolve any external crates,
you should add <code>out/sl</code> to the list of paths you will search for them.&rdquo;</p>

<a name="Who.is.using.that.library."></a>
<h2>Who is using that library?</h2>

<p>Consider this diagram:</p>

<div class="mermaid">
graph TD
SlObj[libsimple_lib.rlib]
DemoSlCompile -.finds file.-> SlObj
DemoSlSource[demo-simple-lib.rs]
DemoSlObj[demo-simple-lib.obj]
DemoSlSource --> DemoSlCompile((rustc))
SlObj --> link
DemoSlCompile -- generates --> DemoSlObj
subgraph "implicit &nbsp;&nbsp; link-step"
DemoSlObj --> link
link((link))
end
</div>


<p>Here is an important question you should ask yourself: is <code>libsimple_lib.rlib</code>
actually used by the linker? Or is it solely used as input to <code>rustc</code> (i.e.,
potentially used in the generation of <code>demo-simple-lib.obj</code> itself). Or is it
used by both <code>rustc</code> <em>and</em> the linker?</p>

<p>We can test this question directly, with some slight tweaks to our commands.</p>

<a name="Proving.the.link.step.s.dependence.on.the.library"></a>
<h3>Proving the link step&rsquo;s dependence on the library</h3>

<p>First, we can test whether its used by the linker at all by separating the link
invocation from the rest of the compiler steps, and then modifying it and
running it on its own.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>% mkdir -p out/sl out/bins/ps/dsl2step
</span><span class='line'>% rustc --out-dir out/ps/sl simple-lib.rs
</span><span class='line'>% ls out/ps/sl
</span><span class='line'>libsimple_lib.rlib
</span><span class='line'>% <span class="nv">LINKER_COMMAND</span><span class="o">=</span><span class="k">$(</span>rustc --out-dir out/bins/ps/dsl2step demo-simple-lib.rs -Lout/ps/sl -Csave-temps --print<span class="o">=</span>link-args -Ccodegen-units<span class="o">=</span>1<span class="k">)</span>
</span><span class='line'>% ls out/bins/ps/dsl2step
</span><span class='line'>demo-simple-lib                                                demo-simple-lib.demo_simple_lib.66aa33f3-cgu.0.rcgu.o
</span><span class='line'>demo-simple-lib.demo_simple_lib.66aa33f3-cgu.0.rcgu.bc         demo-simple-lib.hlsxcd1s0pxo20a.rcgu.bc
</span><span class='line'>demo-simple-lib.demo_simple_lib.66aa33f3-cgu.0.rcgu.no-opt.bc  demo-simple-lib.hlsxcd1s0pxo20a.rcgu.o
</span><span class='line'>% ./out/bins/ps/dsl2step/demo-simple-lib
</span><span class='line'>Running main from simple-lib.rs
</span><span class='line'>% rm ./out/bins/ps/dsl2step/demo-simple-lib
</span><span class='line'>% <span class="nb">eval</span> <span class="nv">$LINKER_COMMAND</span>
</span><span class='line'>% ./out/bins/ps/dsl2step/demo-simple-lib
</span><span class='line'>Running main from simple-lib.rs
</span><span class='line'>%
</span></code></pre></td></tr></table></div></figure>


<p>The significance of the above sequence: It runs <code>rustc -Csave-temps --print=link-args</code> which will preserve the generated object files and also print out the linker invocation it runs.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
In practice when doing these kinds of experiments, you should not blindly use <code>eval</code>  in the manner I have shown here,
but instead echo the linker command to the screen and confirm that it is something you trust running.
</span>
We can run the generated binary, delete the binary, and then re-run that linker
command ourselves (<code>eval $LINKER_COMMAND</code>), and re-run the binary again. This
confirms that this linker invocation does indeed generate that binary.</p>

<p>With that in place, one way we could exercise the linker&rsquo;s use of the file: we
could just delete <code>libsimple_lib.rlib</code>, and run the original linker invocation:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>% <span class="nb">eval</span> <span class="nv">$LINKER_COMMAND</span>
</span><span class='line'>% rm out/ps/sl/libsimple_lib.rlib
</span><span class='line'>% ls out/ps/sl/
</span><span class='line'>% <span class="nb">eval</span> <span class="nv">$LINKER_COMMAND</span>
</span><span class='line'>/usr/bin/ld: cannot find /media/pnkfelix/Rust/Linking/out/ps/sl/libsimple_lib.rlib: No such file or directory
</span><span class='line'>collect2: error: ld returned <span class="m">1</span> <span class="nb">exit </span>status
</span></code></pre></td></tr></table></div></figure>


<p>Another slightly more complicated way we could expose the dependence of our
object code on that file: We can remove the reference to <code>libsimple_lib.rlib</code>
from the linker invocation, and run the resulting new linker invocation:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>% <span class="nv">NEW_COMMAND</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">&quot;$LINKER_COMMAND&quot;</span> <span class="p">|</span> sed -e <span class="s1">&#39;s@&quot;-Wl,-Bstatic&quot; .*/libsimple_lib.rlib&quot;@@&#39;</span><span class="k">)</span>
</span><span class='line'>% <span class="nb">eval</span> <span class="nv">$NEW_COMMAND</span>
</span><span class='line'>/usr/bin/ld: out/bins/ps/dsl2step/demo-simple-lib.demo_simple_lib.66aa33f3-cgu.0.rcgu.o: in <span class="k">function</span> <span class="sb">`</span>demo_simple_lib::main<span class="s1">&#39;:</span>
</span><span class='line'><span class="s1">demo_simple_lib.66aa33f3-cgu.0:(.text._ZN15demo_simple_lib4main17h9794b393d760d697E+0x3): undefined reference to `simple_lib::main&#39;</span>
</span><span class='line'>collect2: error: ld returned <span class="m">1</span> <span class="nb">exit </span>status
</span></code></pre></td></tr></table></div></figure>


<p>This gives you an idea of the kinds of nasty error messages you have to deal
with when you start playing games with your build artifacts: The linker is
rightfully complaining that the generated object code for
<code>demo_simple_lib::main</code> has some reference to <code>simple_lib::main</code> (indeed,the
very definition of the former is just a single invocation of the latter), and
yet that reference cannot be satisfied. (It is up to the user to read that
message and infer that the core problem is that the linker is no longer
receiving the path to <code>libsimple_lib.rlib</code> as one of its command line
arguments.)</p>

<a name="Proving.the.compiler.s.dependence.on.the.library"></a>
<h3>Proving the compiler&rsquo;s dependence on the library</h3>

<p>The previous section established that the linker needs the <code>.rlib</code> file in
place. But, maybe that&rsquo;s only necessary for the link step alone, and <code>rustc</code>
itself doesn&rsquo;t need the actual file?</p>

<p>We can test this theory too, in a similar form of direct experimentation
on the build artifacts.</p>

<p>First, lets try removing the file (same as illustrated in the previous section)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>% rm -f out/ps/sl/libsimple_lib.rlib
</span><span class='line'>% ls out/ps/sl
</span><span class='line'>% rustc --out-dir out/bins/ps/dsl demo-simple-lib.rs -Lout/ps/sl
</span><span class='line'>error<span class="o">[</span>E0463<span class="o">]</span>: can<span class="s1">&#39;t find crate for `simple_lib`</span>
</span><span class='line'><span class="s1"> --&gt; demo-simple-lib.rs:1:1</span>
</span><span class='line'><span class="s1">  |</span>
</span><span class='line'><span class="s1">1 | extern crate simple_lib;</span>
</span><span class='line'><span class="s1">  | ^^^^^^^^^^^^^^^^^^^^^^^^ can&#39;</span>t find crate
</span><span class='line'>
</span><span class='line'>error: aborting due to previous error
</span><span class='line'>
</span><span class='line'>For more information about this error, try <span class="sb">`</span>rustc --explain E0463<span class="sb">`</span>.
</span><span class='line'>%
</span></code></pre></td></tr></table></div></figure>


<p>This shows that the compiler is <em>definitely</em> using the file <code>libsimple_lib.rlib</code>
as part of its compilation of <code>demo-simple-lib.rs</code>.</p>

<p>If we try to force the compiler to make forward progress by giving it a dummy file,
it will still complain:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="o">%</span> <span class="n">touch</span> <span class="n">out</span><span class="o">/</span><span class="n">ps</span><span class="o">/</span><span class="n">sl</span><span class="o">/</span><span class="n">libsimple_lib</span><span class="p">.</span><span class="n">rlib</span>
</span><span class='line'><span class="o">%</span> <span class="n">ls</span> <span class="o">-</span><span class="n">s</span> <span class="n">out</span><span class="o">/</span><span class="n">ps</span><span class="o">/</span><span class="n">sl</span><span class="o">/</span>
</span><span class='line'><span class="n">total</span> <span class="mi">0</span>
</span><span class='line'><span class="mi">0</span> <span class="n">libsimple_lib</span><span class="p">.</span><span class="n">rlib</span>
</span><span class='line'><span class="o">%</span> <span class="n">rustc</span> <span class="o">--</span><span class="n">out</span><span class="o">-</span><span class="n">dir</span> <span class="n">out</span><span class="o">/</span><span class="n">bins</span><span class="o">/</span><span class="n">ps</span><span class="o">/</span><span class="n">dsl</span> <span class="n">demo</span><span class="o">-</span><span class="n">simple</span><span class="o">-</span><span class="n">lib</span><span class="p">.</span><span class="n">rs</span> <span class="o">-</span><span class="n">Lout</span><span class="o">/</span><span class="n">ps</span><span class="o">/</span><span class="n">sl</span>
</span><span class='line'><span class="n">error</span><span class="p">[</span><span class="n">E0786</span><span class="p">]</span><span class="o">:</span> <span class="n">found</span> <span class="n">invalid</span> <span class="n">metadata</span> <span class="n">files</span> <span class="k">for</span> <span class="n">crate</span> <span class="err">`</span><span class="n">simple_lib</span><span class="err">`</span>
</span><span class='line'> <span class="o">--&gt;</span> <span class="n">demo</span><span class="o">-</span><span class="n">simple</span><span class="o">-</span><span class="n">lib</span><span class="p">.</span><span class="n">rs</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">1</span>
</span><span class='line'>  <span class="o">|</span>
</span><span class='line'><span class="mi">1</span> <span class="o">|</span> <span class="k">extern</span> <span class="n">crate</span> <span class="n">simple_lib</span><span class="p">;</span>
</span><span class='line'>  <span class="o">|</span> <span class="o">^^^^^^^^^^^^^^^^^^^^^^^^</span>
</span><span class='line'>  <span class="o">|</span>
</span><span class='line'>  <span class="o">=</span> <span class="n">note</span><span class="o">:</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">mmap</span> <span class="n">file</span> <span class="err">&#39;</span><span class="o">/</span><span class="n">media</span><span class="o">/</span><span class="n">pnkfelix</span><span class="o">/</span><span class="n">Rust</span><span class="o">/</span><span class="n">Linking</span><span class="o">/</span><span class="n">out</span><span class="o">/</span><span class="n">ps</span><span class="o">/</span><span class="n">sl</span><span class="o">/</span><span class="n">libsimple_lib</span><span class="p">.</span><span class="n">rlib</span><span class="err">&#39;</span><span class="o">:</span> <span class="n">memory</span> <span class="n">map</span> <span class="n">must</span> <span class="n">have</span> <span class="n">a</span> <span class="n">non</span><span class="o">-</span><span class="n">zero</span> <span class="n">length</span>
</span><span class='line'>
</span><span class='line'><span class="n">error</span><span class="o">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">error</span>
</span><span class='line'>
</span><span class='line'><span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">this</span> <span class="n">error</span><span class="p">,</span> <span class="n">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0786</span><span class="err">`</span><span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>Upon reflection, this all makes perfect sense: As part of compiling
<code>demo-simple-lib.rs</code>, the compiler is going to reference external metadata (i.e.
the function signatures and type definitions from the <code>simple-lib</code> crate).</p>

<p>So, we have walked through some of the issues that arise when linking crates
together. The <code>demo-simple-lib</code> example demostrated Rust&rsquo;s <code>lib</code> crate type,
which is specified as a compiler-defined choice from one of the flavors of
libraries that Rust supports.</p>

<p>At the time of this blog post, Rust&rsquo;s <code>lib</code> crate type maps to <code>rlib</code>, at least
on my machine. We will talk more about <code>rlib</code> further down; but for now, you can
just keep in mind the points made above for <code>simple-lib</code>: the compiler itself
will read the metadata stored in <code>rlib</code> crates, <em>and</em> the linker also extracts
definitions from <code>rlib</code> crates as well.</p>

<p>We will now step through other supported crate types, and provide
a similar demonstration of how they operate.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
Re-reading the overall post now, I am thinking that I should have put <code>dylib</code> at
the end, due to the number of rabbit holes it opens up. Maybe I will edit the
post in the future and do that rearrangement, so that people can see the &ldquo;easy
cases&rdquo; first.
</span></p>

<a name="Dynamic.Libraries:..code.dylib..code."></a>
<h2>Dynamic Libraries: <code>dylib</code></h2>

<p>The next crate type listed in the Rust reference is <code>dylib</code>.</p>

<div class="mermaid">
graph TD
SlSource[simple-dylib.rs]
SlObj[libsimple_dylib.so]
SlSource --> SlCompile((rustc))
SlCompile --generates --> SlObj
DemoSlCompile -.finds file.-> SlObj
DemoSlSource[demo-simple-dylib.rs]
DemoSlObj[demo-simple-dylib.obj]
DemoSlSource --> DemoSlCompile((rustc))
SlObj --> link
DemoSlCompile -- generates --> DemoSlObj
subgraph "implicit &nbsp;&nbsp; link-step"
DemoSlObj --> link
link((link))
end
link -- generates --> DemoSlBin["demo-simple-dylib (exec)"]
SlObj -. "dynamically loaded by" .- DemoSlBin
</div>


<p>This is a similar picture to the <a href="#Simple.linkage.of-a..lib..crate">one presented above</a>
for <code>lib</code>. In fact, if you look at the two pictures side-by-side, most of the
differences can be attributed to uniform renaming &hellip; except for one: There is
now an extra arc in the diagram, connecting the <code>demo-simple-dylib</code> executable
directly to the <code>libsimple_dylib.so</code> library file.</p>

<p>This is because a <code>dylib</code> crate is a dynamic library; it is meant to be loaded
<em>dynamically</em>, when the program is executed. There are a couple different
reasons one might want this: Perhaps the program is meant to support a &ldquo;plug-in&rdquo;
architecture, where one can get load up new behaviors by swapping in a different
dynamic library. Another common reason is to reduce executable binary sizes: if
many programs depend on the same external crate, then it might be more efficient
to have them all share the same <code>dylib</code>.</p>

<p><em>Note: The <code>dylib</code> format is not guaranteed to remain stable between different versions of the Rust compiler.
Therefore, if you use the <code>dylib</code> format, you need to ensure that all crates
that are sharing the same <code>dylib</code> and the <code>dylib</code> itself are all built
with the same version of the Rust compiler.</em></p>

<p>Here are the code and commands that correspond to the picture above
for compiling `demo-simple-dylib".</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="c1">// simple-dylib.rs</span>
</span><span class='line'><span class="err">#</span><span class="o">!</span><span class="p">[</span><span class="n">crate_type</span><span class="o">=</span><span class="s">&quot;dylib&quot;</span><span class="p">]</span>
</span><span class='line'><span class="k">pub</span> <span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Running main from {}&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">!</span><span class="p">());</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="c1">// demo-simple-dylib</span>
</span><span class='line'><span class="k">extern</span> <span class="n">crate</span> <span class="n">simple_dylib</span><span class="p">;</span>
</span><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span> <span class="n">simple_dylib</span><span class="o">::</span><span class="n">main</span><span class="p">();</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>With the above two files in place, we can compile each of them
and run the resulting binary.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>% rustc --out-dir out/pd/sd -C prefer-dynamic simple-dylib.rs
</span><span class='line'>% ls out/pd/sd
</span><span class='line'>libsimple_dylib.so
</span><span class='line'>% rustc --out-dir out/bins/ps/dsd demo-simple-dylib.rs -Lout/pd/sd
</span><span class='line'>% ls out/bins/ps/dsd
</span><span class='line'>demo-simple-dylib
</span><span class='line'>% <span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span>out/pd/sd:<span class="k">$(</span>rustc --print<span class="o">=</span>sysroot<span class="k">)</span>/lib out/bins/ps/dsd/demo-simple-dylib
</span></code></pre></td></tr></table></div></figure>


<p>You might have noticed that our <code>demo-simple-dylib</code> code is very similar to the
<code>demo-simple-lib</code> code; the only effective change to the source is the
difference in <code>crate_type</code> for <code>simple-dylib.rs</code>. On the other hand, the commands to
compile these inputs and run the executable have had some pretty severe changes
applied to them. Let us explore why those changes were necessary.</p>

<a name="Adapting.command.lines.to.meet.needs.of.crate.type"></a>
<h3>Adapting command lines to meet needs of crate type</h3>

<p>If we tried to reuse the <code>demo-simple-lib</code> sequence of steps to compile these
files and run the presumably generated executable, we hit some roadblocks.</p>

<a name="Why.was.-Cprefer-dynamic.added"></a>
<h4>Why was -Cprefer-dynamic added</h4>

<p>First, if we tried to compile <code>simple-dylib.rs</code> using the same command that was
used for <code>simple-lib.rs</code>, it <em>seems</em> to work at first:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>% mkdir -p out/ps/sd
</span><span class='line'>% rustc --out-dir out/ps/sd simple-dylib.rs
</span><span class='line'>% ls out/ps/sd
</span><span class='line'>libsimple_dylib.so
</span><span class='line'>%
</span></code></pre></td></tr></table></div></figure>


<p>The problem arises when we try to <em>use</em> that generated dylib that was compiled; that
step causes the following error output:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="sb">```</span>sh
</span><span class='line'>% rustc --out-dir out/bins/ps/dsd demo-simple-dylib.rs -Lout/ps/sd
</span><span class='line'>error: cannot satisfy dependencies so <span class="sb">`</span>std<span class="sb">`</span> only shows up once
</span><span class='line'>  <span class="p">|</span>
</span><span class='line'>  <span class="o">=</span> <span class="nb">help</span>: having upstream crates all available in one format will likely make this go away
</span><span class='line'>
</span><span class='line'>error: cannot satisfy dependencies so <span class="sb">`</span>core<span class="sb">`</span> only shows up once
</span><span class='line'>  <span class="p">|</span>
</span><span class='line'>  <span class="o">=</span> <span class="nb">help</span>: having upstream crates all available in one format will likely make this go away
</span><span class='line'><span class="o">[</span>...<span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>and so on, for all of the upstram crates <code>std</code>, <code>core</code>, <code>compiler_builtins</code>,
<code>rustc_std_workspace_core</code>, <code>alloc</code>, <code>libc</code>, <code>unwind</code>, <code>cfg_if</code>, <code>hashbrown</code>,
<code>rustc_std_workspace_alloc</code>, <code>std_detect</code>, <code>rustc_demangle</code>, <code>addr2line</code>, <code>gimli</code>,
<code>object</code>, <code>memchr</code>, <code>miniz_oxide</code>, <code>adler</code>, and <code>panic_unwind</code>.</p>

<p>Understanding why this happens requires we take a step back.</p>

<p>The compiler needs to decide, in the absence of explicit indication from the
programmer, how each dependency should be incorporated into the executable
binary being generated. Namely, should a given dependency be &ldquo;statically linked&rdquo;
into the output object (which effectively means that anything the object needs
will be copied into the output from the referenced library), or should the given
dependency be &ldquo;dynamically linked&rdquo; (which means the executable carries a
dependence on the dynamic library, that will need to be resolved at runtime).
This is a non-trivlal decision, because Rust allows individual crates to
opt-into supporting multiple distinct crate types: a single crate can say &ldquo;I can
be used as an <code>rlib</code> or a <code>dylib</code>; I will let my downstream client decide which
object file they want to pull in for their needs.&rdquo;</p>

<p>But if no one tells the compiler what choice to make, the Rust compiler applies
a simple-minded tactic for guessing what options would be best, and currently,
that tactic is heavily influenced by the presence or absence of
<code>-C prefer-dynamic</code>.</p>

<p>When <code>simple-dylib.rs</code> was compiled <em>without</em> <code>-C prefer-dynamic</code>, the compiler
interpreted the absence of that flag as a signal that the compiler should
attempt to link all dependencies of <code>simple-dylib.rs</code> statically.</p>

<p>Furthermore, the compiler manages to succeed at this static linkage of those
dependencies, but in doing so, it has it impossible to link the resulting
statically-linked crate into <code>demo-simple-dylib.rs</code>.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
A reasonable person might note here: &ldquo;Why is the linkage of <code>std</code> from  <code>demo-simple-dylib</code> treated as its own distinct thing? In other words, why doesn&rsquo;t the compiler just let <code>simple-dylib</code>, which has already statically-linked in those crates, provide them to <code>demo-simple-dylib</code>? And you wouldn&rsquo;t be alone in thinking this: Alex Crichton, who is responsible for the basic logic in use here, made the same suggestion in <a href="https://github.com/rust-lang/rust/issues/34909">rust-lang/rust#34909</a>. I plan to explore this question more in a future blog post.
</span>
The <code>demo-simple-dylib</code> crate <em>also</em> wants to link to all the same upstream
crates, and the compiler rejects this, saying it is not legal for both the <code>simple-dylib</code> and the <code>demo-simple-dylib</code> crates to
have duplicate copies of those dependencies.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
The semantics described here dates from
<a href="https://github.com/rust-lang/rfcs/blob/master/text/0404-change-prefer-dynamic.md">RFC 404</a>,
which was introduced in 2014 before Rust had even hit 1.0 status. That RFC itself
refers to the comments in the code as the documentation; those comments have moved as
the compiler has gone through various refactorings, but the most recent version can
be found here in
<a href="https://github.com/rust-lang/rust/blob/a7d6768e3b60209d4195c822ea3247482909b604/compiler/rustc_metadata/src/dependency_format.rs">rustc_metadata::dependency_format</a>
</span></p>

<p>In the absence of <code>-Cprefer-dynamic</code> and <code>--extern</code> flags (and also absent any
constraints forcing everything to be statically linked), the default logic of
the compiler when trying to decide which upstream crate types to use is as
follows:</p>

<ol>
<li><p>First try to statically link all of the upstream dependencies via their
<code>.rlib</code> libraries. If that succeeds, we are done.</p></li>
<li><p>If static linking failed, then either linking in general is impossible, or at
least one dependency will have to be a dynamic library. Since at least one
dependency has to be dynamic, the compiler, as a simple-minded tactic, tries to
satisfy as many upstream dependencies as possible via their <code>dylib</code> object
files.</p></li>
</ol>


<p>However, if one <em>does</em> provide <code>-Cprefer-dynamic</code>, then that tells the compiler
to not attempt the static link step, and instead to prefer to use <code>dylib</code>
whenever possible for its upstream dependencies. And <em>that</em> is the fix we need here:
we need <code>simple-lib.dylib</code> to prefer the <code>dylib</code> version of <code>std</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>% rustc --out-dir out/pd/sd -C prefer-dynamic simple-dylib.rs
</span></code></pre></td></tr></table></div></figure>


<p>Once that is in place, everything else follows suit.</p>

<p>First, consider how <code>demo-simple-dylib.rs</code> is built.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>% rustc --out-dir out/bins/ps/dsd demo-simple-dylib.rs -Lout/pd/sd
</span></code></pre></td></tr></table></div></figure>


<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
Note that this story here is simple in part because <code>simple-dylib.rs</code>
was only compiled to one crate type. If we had generated both <code>dylib</code>
and <code>rlib</code> crates for it, <em>then</em> the presence/absence of <code>-Cprefer-dynamic</code>
would become significant for building <code>demo-simple-dylib</code>.
</span></p>

<p>Once we have established that the <code>simple-dylib</code> crate is only
available as a <code>dylib</code>, then it does not matter whether we pass
<code>-Cprefer-dynamic</code> or not when building <code>demo-simple-dylib</code>: if we leave it off,
then all that happens is the compiler will first explore trying to statically
link all of the dependencies. Once it determines it cannot (due to
<code>simple-dylib</code>), it will go back to trying to use dynamic libraries for as much
as possible, and thus it will resolve both <code>simple-dylib</code> <em>and</em> <code>std</code> to dynamic
libraries.</p>

<p>Next, we consider the way that <code>demo-simple-dylib</code> needs to be invoked:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>% <span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span>out/pd/sd:<span class="k">$(</span>rustc --print<span class="o">=</span>sysroot<span class="k">)</span>/lib out/bins/ps/dsd/demo-simple-dylib
</span></code></pre></td></tr></table></div></figure>


<p>The main point of interest here is that we had to add some entries to the
<code>LD_LIBRARY_PATH</code>: when the program runs, it needs to satisfy its upstream dylib
dependencies, which we just finished establishing are <code>simple-dylib</code> (in
<code>out/pd/sd</code>) and <code>std</code> (which we map to a directory by asking <code>rustc</code> itself
where those support files all live by running <code>rustc --print=sysroot</code>).</p>

<a name="Rust.libraries:..code.rlib..code."></a>
<h2>Rust libraries: <code>rlib</code></h2>

<p>Phew, that was exhausting.</p>

<p>Lets try to go through an easier case next: the Rust library type, <code>rlib</code>.</p>

<p>This is not necessarily a simple case, but it is an obvious one to deal with,
because we&rsquo;ve been discussing it this whole time; we just did not say that we
were.</p>

<p>Specifically: the <code>demo-simple-lib</code> example covered Rust&rsquo;s <code>lib</code> crate type,
which is specified as a compiler-defined choice from one of the flavors of
libraries that Rust supports. At the time of this blog post, Rust&rsquo;s <code>lib</code> crate
type maps to <code>rlib</code>, at least on my machine.</p>

<p>So, the usage patterns and issues we described up above for <code>lib</code> all apply to <code>rlib</code>.</p>

<p>For completeness, here is a diagram showing how <code>rlib</code> is used; it will look
very familiar.</p>

<div class="mermaid">
graph TD
SlSource[simple-rlib.rs]
SlObj[libsimple_rlib.rlib]
SlSource --> SlCompile((rustc))
SlCompile --generates --> SlObj
DemoSlCompile -.finds file.-> SlObj
DemoSlSource[demo-simple-rlib.rs]
DemoSlObj[demo-simple-rlib.obj]
DemoSlSource --> DemoSlCompile((rustc))
SlObj --> link
DemoSlCompile -- generates --> DemoSlObj
subgraph "implicit &nbsp;&nbsp; link-step"
DemoSlObj --> link
link((link))
end
link -- generates --> DemoSlBin["demo-simple-rlib (exec)"]
</div>


<p>Likewise, here is the source code for the files listed in the diagram.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="c1">// simple-rlib.rs</span>
</span><span class='line'><span class="err">#</span><span class="o">!</span><span class="p">[</span><span class="n">crate_type</span><span class="o">=</span><span class="s">&quot;rlib&quot;</span><span class="p">]</span>
</span><span class='line'><span class="k">pub</span> <span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Running main from {}&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">!</span><span class="p">());</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="c1">// demo-simple-rlib.rs</span>
</span><span class='line'><span class="k">extern</span> <span class="n">crate</span> <span class="n">simple_rlib</span><span class="p">;</span>
</span><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span> <span class="n">simple_rlib</span><span class="o">::</span><span class="n">main</span><span class="p">();</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Finally, the command invocations that implement the diagram above.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>% rustc --out-dir out/ps/sr simple-rlib.rs
</span><span class='line'>% ls out/ps/sr
</span><span class='line'>libsimple_rlib.rlib
</span><span class='line'>% rustc --out-dir out/bins/ps/dsr demo-simple-rlib.rs -Lout/ps/sr
</span><span class='line'>% ls out/bins/ps/dsr
</span><span class='line'>demo-simple-rlib
</span><span class='line'>% out/bins/ps/dsr/demo-simple-rlib
</span><span class='line'>Running main from simple-rlib.rs
</span><span class='line'>%
</span></code></pre></td></tr></table></div></figure>


<p>But, there are no surprises here.</p>

<a name="Static.libraries.for.non.Rust.code:..code.staticlib..code."></a>
<h2>Static libraries for non Rust code: <code>staticlib</code></h2>

<p>If you want to call Rust from another language, you can do that by compiling
your Rust code into a static library, and then linking to that static library
from your foreign program.</p>

<p>Now, for purposes of demonstration in this example, I am using Rust to implement
<code>demo-simple-staticlib</code>; but, crucially, I <strong>didn&rsquo;t have to</strong>. It could have
been written in C, or I could have used Java and JNI to interface with it. (Or
<code>simple-staticlib</code> could have been a Python extension, <em>et cetera</em>.)</p>

<p>Here&rsquo;s what our linkage picture looks like for <code>staticlib</code>:</p>

<div class="mermaid">
graph TD
SlSource[simple-staticlib.rs]
SlObj[libsimple_staticlib.a]
SlSource --> SlCompile((rustc))
SlCompile --generates --> SlObj
%% DemoSlCompile -.finds file.-> SlObj
DemoSlSource[demo-simple-staticlib.rs]
DemoSlObj[demo-simple-staticlib.obj]
DemoSlSource --> DemoSlCompile((rustc))
SlObj --> link
DemoSlCompile -- generates --> DemoSlObj
subgraph "implicit &nbsp;&nbsp; link-step"
DemoSlObj --> link
link((link))
end
link -- generates --> DemoSlBin["demo-simple-staticlib (exec)"]
</div>


<p>If we compare this against our picture for <code>rlib</code>, the main difference
now is that there is no longer an arc from <code>rustc</code> to <code>libsimple_staticlib.a</code>.
This is actually a pretty big difference!</p>

<ol>
<li><p>The generated archive file, <code>libsimple_staticlib.a</code>, is <em>not</em> a Rust crate.
It does not have the metadata the Rust compiler would need to intepret it as
a crate. Instead, it is just another library archive, like the others
typically used in a C project.</p></li>
<li><p>When compiling <code>demo-simple-staticlib.rs</code>, we will have to pass flags to the
compiler that tell it to link to the static library. The compiler will no
longer magically figure this out for us.</p></li>
<li><p>Since <code>libsimple_staticlib.a</code> is not a Rust crate, we have to provide
explicit declarations in <code>demo-simple-staticlib.rs</code> for the functions it
provides.</p></li>
</ol>


<p>The differences above can arguably be summed up in: It is like you are
programming in C, in terms of having to deal with keeping function signatures
consistent and juggling linker flags. If you have experience with that, none of
this should seem surprising.</p>

<p>That said, here is the source code for the files in the diagram.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="c1">// simple-staticlib.rs</span>
</span><span class='line'><span class="err">#</span><span class="o">!</span><span class="p">[</span><span class="n">crate_type</span><span class="o">=</span><span class="s">&quot;staticlib&quot;</span><span class="p">]</span>
</span><span class='line'><span class="cp">#[no_mangle]</span>
</span><span class='line'><span class="k">pub</span> <span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="k">fn</span> <span class="n">staticlib_main</span><span class="p">()</span> <span class="p">{</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Running staticlib_main from {}&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">!</span><span class="p">());</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span> <span class="k">fn</span> <span class="n">staticlib_main</span><span class="p">();</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">unsafe</span> <span class="p">{</span> <span class="n">staticlib_main</span><span class="p">();</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And here are the command invocations that complete the diagram above.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>% rustc --out-dir out/ps/ss simple-staticlib.rs
</span><span class='line'>% ls out/ps/ss
</span><span class='line'>libsimple_staticlib.a
</span><span class='line'>% rustc --out-dir out/bins/ps/dss demo-simple-staticlib.rs -Lout/ps/ss -lsimple_staticlib
</span><span class='line'>% ls out/bins/ps/dss
</span><span class='line'>demo-simple-staticlib
</span><span class='line'>% out/bins/ps/dss/demo-simple-staticlib
</span><span class='line'>Running staticlib_main from simple-staticlib.rs
</span><span class='line'>%
</span></code></pre></td></tr></table></div></figure>


<a name="Dynamic.libraries.for.non.Rust.code:..code.cdylib..code."></a>
<h2>Dynamic libraries for non Rust code: <code>cdylib</code></h2>

<p>Conceptually so far we have covered three cells in the following 2x2 matrix,
and <code>cdylib</code> will finish the table.</p>

<table>
<thead>
<tr>
<th>            </th>
<th> Linked from Rust  </th>
<th> Linked from Non-Rust</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Static</strong>  </td>
<td>   rlib            </td>
<td>    staticlib</td>
</tr>
<tr>
<td><strong>Dynamic</strong> </td>
<td>  dylib            </td>
<td>   cdylib</td>
</tr>
</tbody>
</table>


<p>The diagram for using <code>cdylib</code> should have elements that remind you of both the table
for <code>dylib</code> and the table for <code>staticlib</code>.</p>

<div class="mermaid">
graph TD
SlSource[simple-cdylib.rs]
SlObj[libsimple_cdylib.so]
SlSource --> SlCompile((rustc))
SlCompile --generates --> SlObj
%% DemoSlCompile -.finds file.-> SlObj
DemoSlSource[demo-simple-cdylib.rs]
DemoSlObj[demo-simple-cdylib.obj]
DemoSlSource --> DemoSlCompile((rustc))
SlObj --> link
DemoSlCompile -- generates --> DemoSlObj
subgraph "implicit &nbsp;&nbsp; link-step"
DemoSlObj --> link
link((link))
end
link -- generates --> DemoSlBin["demo-simple-cdylib (exec)"]
SlObj -. "dynamically loaded by" .- DemoSlBin
</div>


<p>Namely, here we see:</p>

<ol>
<li><p>Much like <code>demo-simple-staticlib</code>, compiling <code>demo-simple-cdylib.rs</code>
does not attempt to extract metadata from the <code>simple-cdylib.so</code> or even
treat it as a Rust crate; instead, one must provide the right linker flags to
the compiler, and the right <code>extern</code> function signatures in the source code
for <code>demo-simple-cdylib.rs</code>.</p></li>
<li><p>Much like <code>demo-simple-dylib</code>, the execution of <code>demo-simple-cdylib</code> will
itself load the shared library <code>demo-simple-cdylib.so</code> and link to its code
dynamically.</p></li>
</ol>


<p>The source code for this demostration is just like that of <code>staticlib</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="c1">// simple-cdylib.rs</span>
</span><span class='line'><span class="err">#</span><span class="o">!</span><span class="p">[</span><span class="n">crate_type</span><span class="o">=</span><span class="s">&quot;cdylib&quot;</span><span class="p">]</span>
</span><span class='line'><span class="cp">#[no_mangle]</span>
</span><span class='line'><span class="k">pub</span> <span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="k">fn</span> <span class="n">cdylib_main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Running cdylib_main from {}&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">!</span><span class="p">());</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="c1">// demo-simple-cdylib.rs</span>
</span><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span> <span class="k">fn</span> <span class="n">cdylib_main</span><span class="p">();</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">unsafe</span> <span class="p">{</span> <span class="n">cdylib_main</span><span class="p">();</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The command sequence here is interesting: we are no longer forced to use <code>-C prefer-dynamic</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>% rustc --out-dir out/ps/sc simple-cdylib.rs
</span><span class='line'>% ls out/ps/sc
</span><span class='line'>libsimple_cdylib.so
</span><span class='line'>% rustc --out-dir out/bins/ps/dsc demo-simple-cdylib.rs -Lout/ps/sc -lsimple_cdylib
</span><span class='line'>% ls out/bins/ps/dsc
</span><span class='line'>demo-simple-cdylib
</span><span class='line'>% <span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span>out/ps/sc out/bins/ps/dsc/demo-simple-cdylib
</span><span class='line'>Running cdylib_main from simple-cdylib.rs
</span></code></pre></td></tr></table></div></figure>


<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
This hypothesis is one of many items that I want to follow up on in a future post.
</span>
I believe this is because we end up treating the two components
(<code>simple-cdylib.so</code> and <code>demo-simple-dylib</code>) as completely divorced entities:
thus, they each get <em>their own copy</em> of the functions they use from the Rust standard library statically
linked into them.</p>

<a name="Conclusion"></a>
<h2>Conclusion</h2>

<p>That was quite a romp!</p>

<p>And yet, we have not even gotten to some of the hairier stuff, like:</p>

<ul>
<li>mixing distinct upstream crate types into the same project,</li>
<li>having multiple crate-types for the same crate available,</li>
<li>using <code>--extern</code> to specify which crate type should be used for a given crate type,</li>
<li>mixing crates built with and without <code>-Cprefer-dynamic</code> (how to get it to work today, and how should it work in ideal world?), or</li>
<li>varying whether the program will statically or dynamically link to the platforms C runtime.</li>
</ul>


<p>Furthermore, I did not really dig into what static linking <em>means</em>, especially
when it comes to crate types like <code>rlib</code>, which explicitly <em>do not have</em>
link-time dependencies. I want to elaborate on that too, preferably by demonstrating
how to use <code>objdump</code> to learn things about the generated code.</p>

<p>So, lots of material for future posts.</p>

<p>(And also, lots of opportunities to try to clean up the presentation of this
post.)</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Felix S. Klock II</span></span>

      








  


<time datetime="2022-05-12T01:50:00-04:00" pubdate data-updated="true"></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/linkers/'>linkers</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://blog.pnkfx.org/blog/2022/05/12/linking-rust-crates/" data-via="pnkfelix" data-counturl="http://blog.pnkfx.org/blog/2022/05/12/linking-rust-crates/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2022/05/10/visuals-redux-getting-mermaid-going/" title="Previous Post: Visuals redux: Getting mermaid going">&laquo; Visuals redux: Getting mermaid going</a>
      
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2022/05/12/linking-rust-crates/">Linking Rust Crates, Part 1</a>
      </li>
    
      <li class="post">
        <a href="/blog/2022/05/10/visuals-redux-getting-mermaid-going/">Visuals redux: Getting mermaid going</a>
      </li>
    
      <li class="post">
        <a href="/blog/2022/02/09/what-is-rusts-hole-purpose/">What is Rust's Hole Purpose?</a>
      </li>
    
      <li class="post">
        <a href="/blog/2022/01/10/why-i-use-a-debugger/">Why I use a debugger</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/05/03/road-to-turbowish-part-3-design/">Road to TurboWish part 3: Design</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/pnkfelix">@pnkfelix</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'pnkfelix',
            count: 4,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>



  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2022 - Felix S. Klock II -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'pnkfx-blog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
