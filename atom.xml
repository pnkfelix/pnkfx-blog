<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[The {pnk}f(eli)x Blog]]></title>
  <link href="http://blog.pnkfx.org/atom.xml" rel="self"/>
  <link href="http://blog.pnkfx.org/"/>
  <updated>2016-01-01T09:31:16+01:00</updated>
  <id>http://blog.pnkfx.org/</id>
  <author>
    <name><![CDATA[Felix S. Klock II]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GC and Rust Part 2: The Roots of the Problem]]></title>
    <link href="http://blog.pnkfx.org/blog/2016/01/01/gc-and-rust-part-2-roots-of-the-problem/"/>
    <updated>2016-01-01T00:00:00+01:00</updated>
    <id>http://blog.pnkfx.org/blog/2016/01/01/gc-and-rust-part-2-roots-of-the-problem</id>
    <content type="html"><![CDATA[<p>This is the second in a series of posts will discuss why garbage
collection is hard, especially for Rust, and brainstorm about
solutions to the problems we face.</p>

<p>The <a href="http://blog.pnkfx.org/blog/2015/11/10/gc-and-rust-part-1-specing-the-problem/">previous post</a> wrote down some criteria for integration.
Now I want to delve into why satisfying those criteria is hard,
at least in Rust as it stands today.</p>

<!-- more -->




<script>
// See https://github.com/imathis/octopress/issues/424
$(document).ready(function(){
    $('body').addClass('collapse-sidebar');
});
</script>


<p>(The body of this post makes heavy use of client-side rendering,
because of author idiosyncrasies.  You may need to wait a moment while
the supporting Javascript loads.)</p>

<script src="http://blog.pnkfx.org/javascripts/viz.js" charset="utf-8"></script>


<script src="http://blog.pnkfx.org/javascripts/js_to_dot.js" charset="utf-8"></script>


<script src="http://blog.pnkfx.org/javascripts/gc_rendering.js" charset="utf-8"></script>


<a name="Simplifying.Assumptions"></a>
<h2>Simplifying Assumptions</h2>

<p>Let us make some assumptions, so that we can focus on why
this problem is still hard even <em>after</em> being somewhat simplified.</p>

<p>As previously discussed in <a href="http://blog.pnkfx.org/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work/#how-gc-works">the proloque</a>, one can think of the
main program and the GC as <em>coroutines</em>. We will continue with that
mind set.</p>

<p>Let us assume (for now) that the main program will not be running
concurrently with the GC;<label for='no-concurrent-mutation' class='margin-toggle sidenote-number'></label><input type='checkbox' id='no-concurrent-mutation' class='margin-toggle'/><span class='sidenote'>This is certainly a significant assumption; in practice, to enforce this we would probably need to employ some sort of rendezvous protocol with gc-safepoints on every thread that might hold roots for a given GC Heap. (Of course, one might also satisfy this by directly adopting the coroutine model and also disallowing sharing of references into any one GC heap across multiple threads.) </span> or more specifically, the main program
thread(s) will not read or write any GC roots nor GC Heap-allocated
objects concurrently with the GC thread.</p>

<p>In addition, let us assume that in the context of the GC coroutine, no
mutator roots are live values in CPU registers;<label for='no-register-roots' class='margin-toggle sidenote-number'></label><input type='checkbox' id='no-register-roots' class='margin-toggle'/><span class='sidenote'>This assumption is mostly a convenience for the text below, so that instead of saying &ldquo;in live callee-save registers or on the stack&rdquo;, I can just say &ldquo;on the stack.&rdquo; Also, in practice, I do not know if many GCs actually handle this in a more &ldquo;clever&rdquo; fashion than just forcing such values to live on the stack during a root scan (though certainly <em>some</em> do support roots in registers). </span>
 in other words, all mutator register values that the GC might care about
will have been saved somewhere in a mutator stack frame
(and will be reloaded from those saved stack slots
before subsequent use by the mutator).</p>

<p>Again, these assumptions are <em>not</em> meant to be interpreted as specific
requirements of Rust&rsquo;s final solution for GC; instead, they describe a
simplified version of &ldquo;the GC integration problem&rdquo; that
I claim is <em>still</em> hard to solve for Rust in general.</p>

<p>Throughout most of this post, I will be discussing various data
structures to support GC activity. When providing concrete examples of
the runtime state, the goal will usually be to represent something analogous
to the following
fragment of an object graph (or some small variant thereof).</p>

<p id="running_example_graph"></p>




<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var rust_heap = { rankdir:"LR", id: "cluster_rust_heap", label: "Rust Heap", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };

var o = object_record("O: StructZ", "<f0> field z (root)");
o.id = "O";
var x = object_record("X1", "...");
var y = object_record("Y", "...");
var x2 = object_record("X2", "...");
x.style = "rounded";
y.style = "rounded";
x2.style = "rounded";

var local_x = { id: "local_x", label: "local x: Gc&lt;X&gt; (root)", shape: "record" };
var local_y = object_record("StructY", "<f0> field y (root)");
var local_o = { id: "local_o", label: "local o = Box(O)", shape: "record" };

stack[1] = local_x;
stack[2] = local_y;
stack[3] = local_o;
local_x.ref = edge_from_to_ports(":e", ":id:nw", x);
local_y.ref = edge_from_to_ports(":f0", ":id", y);
local_o.box = edge_to_port(":id", o);

o.f0 = edge_from_to_ports(":f0", ":id:w", x);
rust_heap[0] = o;

gc_heap[2] = x;
gc_heap[3] = y;
gc_heap[4] = x2;

var objects = [stack, gc_heap, rust_heap];

stack.rank = "same";

post_objects("running_example_graph", objects, { rankdir:"LR", nodesep:0.2, no_dims: true, with_code: false });
</script>


<p>Instances of structured data are
shown with a label<label for='labels-for-presentation' class='margin-toggle sidenote-number'></label><input type='checkbox' id='labels-for-presentation' class='margin-toggle'/><span class='sidenote'>These labels are often a presentation artifact: they do not necessarily denote a header word in the memory itself. </span>
(<code>StructY</code>, <code>O: StructZ</code>, <code>X</code>, <code>Y</code>) that identifies the data and usually includes its type.</p>

<p>Often I will omit the type of a local variable or member (such as with
<code>o</code>, <code>y</code>, and <code>z</code> above). If I want to specify the type, I will do so via
type-ascription
syntax (e.g. <code>x: Gc&lt;X&gt;</code> above), and if I want to specify the particular
value given to a variable, I will use assignment syntax (e.g. <code>o = Box(O)</code> above).
(Note that the assigned value should always be redundant, since there
should also be an arrow linking to the assigned value in these diagrams.)</p>

<p>Values of type <code>Gc&lt;T&gt;</code> hold references to objects allocated on the GC Heap.
Every object on the GC Heap will have a label that is derived from the
type <code>T</code> and, if necessary, a numeric suffix to disambiguate between
multiple instances of <code>T</code> on the GC Heap.</p>

<p>I have denoted the <em>contents</em> of the objects on the GC Heap by
ellipses, because I am focusing in this post
solely on problems related to finding the roots;
the contents of the objects referenced by the roots, and the remaining
transitively reachable objects beyond them, are not important to us today.</p>

<p>Objects allocated on the Rust Heap will tend to be boxes owned by
values of type <code>Box&lt;T&gt;</code>; they will have an identifying label and the
type of the contents (e.g. <code>O: StructZ</code> above).</p>

<p>I will tend to present examples of structured data with trivial
structs that have one field; e.g. <code>StructY</code> has a single field <code>y</code>,
and likewise <code>StructZ</code> has just the field <code>z</code>. (Of course in real
programs there will be structs and arrays with multiple members, but single field
structs simplifies the diagrams here.)</p>

<a name="Rust.complicates.Root.Identification"></a>
<h2>Rust complicates Root Identification</h2>

<p>At some point, probably in response to a memory allocation request,
the GC is going to initiate a collection.</p>

<p>That requires traversing the root set of the main program, since those
roots will be the kernel that the GC uses to identify the reachable
objects.</p>

<p>What are the options for traversing the root-set?</p>

<a name="Do.we.need.to.solve.this.problem."></a>
<h3>Do we need to solve this problem?</h3>

<p>One approach is to &ldquo;define away the problem&rdquo;; one version of this I
<a href="#Interoperation.with.a..black.box..GC">previously described</a> is to
hide the root-set itself inside the black-box abstraction
that we are interoperating with, and expose only handles that
point to the roots.</p>

<p id="target_anchor_black_box_gc_1" class="fullwidth"></p>


<p>The key principle in this picture is that the GC is meant to be
completely isolated from the state of the main program; when it does a
collection, the GC just starts from the root-set hidden within the
<code>handles</code> in the GC-heap. It does not inspect any state in the boxes
labelled &ldquo;Stack&rdquo; nor &ldquo;Rust Heap.&rdquo;</p>

<p>But a big problem with this, that I failed to stress in my earlier
post, is that you now need to <em>manage</em> the hidden-root set stored in
the <code>handles</code> array.</p>

<p>In particular, in the above picture, every entry in <code>handles</code> maps to
exactly one <code>Handle</code> value on the &ldquo;Stack&rdquo; or &ldquo;Rust Heap.&rdquo; This leads
to some troubling questions.</p>

<ul>
<li><p>What happens when you clone the box referenced by the local variable <code>o</code>: does that need to create a new entry in the hidden <code>handles</code> array?</p></li>
<li><p>How about if you instead dropped <code>o</code> &ndash; does that clear the <code>handles</code> entry at index 2?</p>

<ul>
<li><p>If not, when/how will the root set be updated appropriately?</p></li>
<li><p>If so, are previously cleared entries reused? If so, how do you determine whether an entry is available for reuse &ndash; do you keep a mark-bit on each handle?</p></li>
</ul>
</li>
<li><p>This handle array maintenance sounds expensive, maybe
we should instead periodically scan the stack to look for pointers to handles &hellip;</p></li>
</ul>


<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
Just to be clear: the joke here is that we are basically
suggesting layering our own semi-automated memory management system
on top of a third-party automated memory management system. We should be striving to
<em>reduce</em> our problems to smaller subproblems, not <em>reproducing</em> them.
</span>
&hellip; maybe we should rethink our overall approach here.</p>

<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var rust_heap = { rankdir:"LR", id: "cluster_rust_heap", label: "Rust Heap", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };
var handles = object_record("handles", "<h2> Y | <h1> X | <h3> X");

var c = object_record("C", "<f0> Gc(X) | <f1> Box(O)");
c.style = "rounded";
var o = object_record("O: StructZ", "<f0> field z = Handle(2)");
o.id = "O";
var x = object_record("X", "...");
var y = object_record("Y", "...");
x.style = "rounded";
y.style = "rounded";
var local_x = { id: "local_x", label: "local x = Handle(1)", shape: "record" };
var local_y = { id: "local_y", label: "StructY | <f0> field y = Handle(0)", shape: "record" };
var local_o = { id: "local_o", label: "local o = Box(O)", shape: "record" };

o.f0 = edge_from_to_ports(":f0", ":h3", handles);

c.f0 = edge_from_to_ports(":f0", ":id", x);
c.f1 = edge_from_to_ports(":f1", ":id", o);

stack[1] = local_x;
stack[2] = local_y;
stack[3] = local_o;

rust_heap[0] = o;
gc_heap[0] = handles;
handles.x1 = edge_from_to_ports(":h1", ":id", x);
handles.y2 = edge_from_to_ports(":h2", ":id", y);
handles.x3 = edge_from_to_ports(":h3", ":id:sw", x);
local_x.handle = edge_to_port(":h1", handles);
local_y.handle = edge_from_to_ports(":f0", ":h2", handles);
local_o.box = edge_to_port(":id", o);
gc_heap[2] = x;
gc_heap[3] = y;

var objects = [stack, gc_heap, rust_heap];
post_objects("target_anchor_black_box_gc_1", objects, { rankdir:"LR", nodesep:0.2, no_dims: true });
</script>


<a name="Scanning.the.Mutator.State"></a>
<h3>Scanning the Mutator State</h3>

<p>So let&rsquo;s assume we are <em>not</em> dealing with a complete black box;
instead, the main program (aka &ldquo;the mutator&rdquo;) and the GC are going
to collaborate in some more fundamental way.</p>

<p>In other words, let&rsquo;s assume that roots are allowed to leak outside of
the GC Heap and into the mutator; no more black-box.</p>

<p>Once we have roots floating around under the control of the mutator,
we need to talk about identifying those roots by inspecting/querying the mutator
state.</p>

<p>Some relevant issues to consider on this topic:</p>

<ul>
<li><p>Are all roots <em>precisely</em> identified as roots?</p></li>
<li><p>Where can the roots reside in the mutator? (Frames on the stack? Boxes on the Rust Heap?)</p></li>
<li><p>How is the GC informed about the location of the roots in the mutator?</p></li>
<li><p>How does the mutator itself access the roots?</p></li>
<li><p>What information might the mutator maintain on the behalf of the GC?</p></li>
<li><p>Might a given root&rsquo;s value (i.e. the address of the referenced
object on the GC Heap) be changed by the GC during the collection
(in other words, does the GC rule out <a href="http://blog.pnkfx.org/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work/#pinning-support">pinning</a>)?</p></li>
</ul>


<p>Let&rsquo;s explore some of the problems associated with these
questions, especially how it relates to Rust.</p>

<a name="Are.roots.precisely.identified."></a>
<h2>Are roots precisely identified?</h2>

<p>The roots are somewhere in mutator-managed memory.
The GC will need to know the values held in those roots,
and possibly will need to update those values if the referenced
objects are moved in memory.</p>

<p>There are two basic options for root scanning: conservative or precise.</p>

<p>A <em>conservative</em> scan is needed when some of the values
might hold an actual root, but might also hold a false-positive.</p>

<p>This arises when, for example, there is not enough type information
available<label for='avail-types' class='margin-toggle sidenote-number'></label><input type='checkbox' id='avail-types' class='margin-toggle'/><span class='sidenote'>&ldquo;Not available&rdquo; can mean that that the information is absent; but it can also mean that it is <em>untrusted</em>. I discuss this further below. </span>
to know that a scanned word is meant to be interpreted by the mutator as an object
reference.</p>

<p>If there are any conservatively-scanned roots, the GC needs to
validate their values (e.g. by checking if it lies within one of the
ranges of addresses used for the objects allocated on the GC Heap),
and trace any object potentially referenced by such values.</p>

<p>An earlier discussion on &ldquo;<a href="http://blog.pnkfx.org/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work/#pinning-support">pinning</a>&rdquo; established that any object
referenced by a conservatively scanned root
cannot be moved by the GC.
Therefore, integrating with a GC that does not support object pinning
(such as a fully-copying collector)
will require we scan the roots precisely, not conservatively.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
One problem with ensuring that a word on the stack is precisely identified
is that it requires close cooperation with the compiler backend.
E.g. if the backend (LLVM in the case of <code>rustc</code>) is permitted to reuse a stack
slot for two values of different types (and disjoint extents) then
we need to take care that the GC knows whether the current value in that slot
is or is not a GC reference.
(LLVM is a very expressive backend, so it provides mechanisms to account for this scenario, but it is not automatic.)
</span>
A given word in memory can be <em>precisely</em> scanned
if we ensure that the root&rsquo;s location in memory is
unambiguously interpreted by the mutator as an object reference.
I will say that such a root can be
&ldquo;unambiguously classified&rdquo; only if such assurance is established.</p>

<p>Often the ability to classify a root unambiguously is derived from
static types, runtime type information, and global system invariants.</p>

<p>Where the roots might reside influences the design space for
unambiguous classification quite a bit.
For example, if all roots are members of heap-allocated objects, then
the allocator might embed a type-tag in the header of such an object,
or segregate objects into disjoint regions of memory based on that
type.</p>

<p>Therefore, we will explore the question of where roots reside next.</p>

<a name="Where.are.the.roots."></a>
<h2>Where are the roots?</h2>

<p>There are two components to the question &ldquo;where are the roots?&rdquo;:</p>

<ul>
<li><p>Where can roots <em>possibly</em> reside?</p></li>
<li><p>Where do the roots <em>actually</em> reside?</p></li>
</ul>


<p>The first bullet is a question about the system as a whole; it is a
question that we must answer as designers.</p>

<p>The second bullet is about encoding how the GC will look up the memory
addresses of the roots (potentially with the mutator&rsquo;s help) every
time it wants to initiate a root scan.</p>

<p>The two parts interact with each other, so we will address them both
somewhat simultaneously.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
This list is leaving out some other options,
such as <em>completely unconstrained</em>, where roots might live in memory
unknown to the both the GC and Rust runtime (I do not see a way this first option could work without
requiring programmers to instrument foreign code with calls to root registration
and deregistration functions),
or keeping the roots solely on a <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.5570">shadow stack</a>
with structure isomorphic to the actual stack, but not vulnerable
to disruption due to compiler code transformations (I am omitting
this second option since it is known to carry a significant performance penalty).
</span></p>

<p>Consider these options for locations where roots can reside:</p>

<ol>
<li><p><em>Constrained To Boxed Values</em>:
 Solely found embedded in boxed values on the Rust Heap.</p></li>
<li><p><em>Constrained To Stack</em>:
 Stored solely on the program stack, and</p></li>
<li><p><em>Rust-Managed But Otherwise Unconstrained</em>:
 Stored either on the stack or embedded in boxed values on Rust Heap.</p></li>
</ol>


<a name="Roots.Constrained.To.Boxed.Values..Option.1."></a>
<h3>Roots Constrained To Boxed Values (Option 1)</h3>

<p>If roots are <em>solely</em> stored in members of boxed values, then we might
store runtime-type metadata in an allocator-injected header.</p>

<p>This option is seductive: Adding a header via the runtime system&rsquo;s
<code>#[allocator]</code> crate could sidestep a significant amount of compiler
integration (maybe even all of it).</p>

<p>There are some interesting ideas to explore from that starting point,
such as collecting all such boxed values together in a linked list
whose head is known to the GC (and thus the answer to &ldquo;how does the
GC scan the roots?&rdquo; is just &ldquo;it walks the list&rdquo;<label for='list-maintenance' class='margin-toggle sidenote-number'></label><input type='checkbox' id='list-maintenance' class='margin-toggle'/><span class='sidenote'>Do not be fooled; it would not be that easy. In particular, properly maintaining such a list could complicate the interface between the mutator and the values holding the roots. </span>).</p>

<p>However,
constraining roots to solely live in members of boxed
values may not be feasible in Rust as it stands today.
For example, one is always free to move the instance of <code>T</code> out of a
<code>Box&lt;T&gt;</code>, deallocating the backing storage but moving the <code>T</code> into
another location, such as a stack-allocated local variable.</p>

<p>Let&rsquo;s look at the remaining two
approaches.</p>

<a name="Roots.Constrained.To.Stack..Option.2."></a>
<h3>Roots Constrained To Stack (Option 2)</h3>

<p>If roots can be stored directly on the stack (i.e. options 2 or 3 above),
then when the GC initiates a root scan, it will need to find those
roots.</p>

<p>This search of the stack can be guided by
&ldquo;stack maps&rdquo;:<label for='stack maps' class='margin-toggle sidenote-number'></label><input type='checkbox' id='stack maps' class='margin-toggle'/><span class='sidenote'>For details, see <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.56.1641">Compiler Support for Garbage Collection in a Statically Typed Language</a>, Diwan Moss and Hudson (1992). </span>
compiler-generated metadata providing a mapping from a
code address<label for='code-address' class='margin-toggle sidenote-number'></label><input type='checkbox' id='code-address' class='margin-toggle'/><span class='sidenote'>This mapping need not have an entry for <em>every</em> address from the program instruction stream; we can make do with just the addresses of <em>call-sites</em> into runtime routines that could cause a GC. </span>
to the set of stack slots<label for='stack-map-slot' class='margin-toggle sidenote-number'></label><input type='checkbox' id='stack-map-slot' class='margin-toggle'/><span class='sidenote'>More specifically, the offset in a stack frame of a slot, and any relevant type information needed by the GC the compiler opted to include. </span>
that hold values of interest.</p>

<p>However, restricting the roots to live solely on the stack may be
problematic for much the same reason that plagues the earlier idea of
restricting roots to boxed values: in Rust today, one is always free
to move instances of <code>T</code> from a stack-local slot into a member of a
boxed value.</p>

<p>In some circumstances, we might be able to counteract these
&ldquo;freedom of movement&rdquo; issues in a backwards-compatible manner with a compiler
plugin (lint) that analyzes the source and trys to flag any code might move a root
into an illegal location. (<a href="https://servo.org/">Servo</a> already uses <a href="https://blog.mozilla.org/research/2014/08/26/javascript-servos-only-garbage-collector/#custom-static-analysis">a lint like this</a>
for its integration with the Spidermonkey GC.)</p>

<p>Or, if we are willing to extend the language itself,
we might add marker trait <code>Immobile</code> that indicates
that values of such type <em>cannot</em> be
moved.<label for='hunh-moved' class='margin-toggle sidenote-number'></label><input type='checkbox' id='hunh-moved' class='margin-toggle'/><span class='sidenote'>Proper integration of <code>trait Immobile</code> would probably require a way type for type parameters to opt-out of the capability to be moved, e.g. via a <code>T: ?Moved</code> anti-bound, analogous to the <code>?Sized</code> anti-bound.<br></br>Yes, I just made up the term &ldquo;anti-bound.&rdquo; </span></p>

<p>But either of those options are just ways of enforcing a restriction,
and it will outlaw certain kinds of program composition.<label for='vec-composition' class='margin-toggle sidenote-number'></label><input type='checkbox' id='vec-composition' class='margin-toggle'/><span class='sidenote'>An easy example of this: If you want to be able to put a root as part of the element type in a <code>Vec&lt;T&gt;</code>, then that <code>T</code> has to be able to be moved (since expanding the capacity of a vec will require moving its contents from one backing buffer to another). </span></p>

<p>In practice, we simply may be better off lifting such restrictions
entirely. So, let us now consider our remaining option:
allowing roots to be embedded in values on the stack or boxed on the Rust Heap.</p>

<a name="Roots.are.Rust-Managed..But.Otherwise.Unconstrained..Option.3."></a>
<h2>Roots are Rust-Managed, But Otherwise Unconstrained (Option 3)</h2>

<p>Now we come to what is probably the most realistic option for Rust/GC integration:
allowing roots to reside anywhere that the Rust compiler or runtime knows about.</p>

<p>Arguably, I might well have <em>started</em> this discussion with this
approach, since it is by definition the most general of the three, and
thus if we <em>do</em> have a solution for it, then why not jump to it?</p>

<p>The reason I left it for last is that I suspect any design we adopt
for GC integration in Rust 1.x is going to require a hybrid of the
approaches described in the prior two sections (allocator-injected
metadata <em>and</em> stack maps), and therefore I wanted to outline them in
isolation, before I started mixing them together.</p>

<a name="GC:..Where.are.the.roots....Mutator:......"></a>
<h2>GC: &ldquo;Where are the roots?&rdquo;, Mutator: &ldquo;&hellip;&rdquo;</h2>

<p>If we assume that roots can be embedded in values either on the stack
or in boxes on the Rust Heap, then how will the GC find the roots when
it needs to scan them?</p>

<p>The support for the GC&rsquo;s root scanning capability can be seen as having three parts:</p>

<ol>
<li><p>What work does the GC itself do, on the fly, to determine the roots
when it needs them,</p></li>
<li><p>What work does the mutator do (if any) as it executes the
program<label for='mutator-work' class='margin-toggle sidenote-number'></label><input type='checkbox' id='mutator-work' class='margin-toggle'/><span class='sidenote'>&ldquo;Mutator work&rdquo; here includes code hidden in library functions the mutator calls, such as <code>#[allocator]</code> subroutines, or code automatically injected by the compiler, such read- or write-barriers. </span>
to support a potential root scan by the GC in a future, and,</p></li>
<li><p>What meta-data must be gathered and emitted by the compiler
to support root-scanning?</p></li>
</ol>


<p>One idea for enabling easy GC root traversal was mentioned earlier:
why not collect the roots together in a linked list structure?
Towards this goal, we might
consider maintaining an intrusive
 links forming a list of all roots.</p>

<p id="intrusive_list_of_roots"></p>




<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var rust_heap = { rankdir:"LR", id: "cluster_rust_heap", label: "Rust Heap", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };

var o = object_record("O: StructZ", "<f0> field z (root) | <next> next_root = null");
o.id = "O";
var x = object_record("X", "...");
var y = object_record("Y", "...");
x.style = "rounded";
y.style = "rounded";

var local_x = object_record("local_x", "<f0> (root) | <next> next_root");
var local_y = object_record("StructY", "<f0> field y (root) | <next> next_root");
var local_o = { id: "local_o", label: "local o = Box(O)", shape: "record" };

stack[1] = local_x;
stack[2] = local_y;
stack[3] = local_o;

local_x.ref = edge_from_to_ports(":f0", ":id", x);
local_y.ref = edge_from_to_ports(":f0", ":id", y);
local_o.box = edge_to_port(":id", o);

o.f0 = edge_from_to_ports(":f0", ":id:sw", x);
rust_heap[0] = o;

gc_heap[2] = x;
gc_heap[3] = y;

root_head = object_record("roots", "<next> next_root");
var anonymous_xy = {id: "anonymous_xy", style:"invis", shape: "point"};

// gc_heap[0] = root_head;

root_head.next = edge_from_to_ports(":next", ":f0", local_x);
local_x.next = edge_from_to_ports(":next", ":f0", anonymous_xy);
local_x.next.arrowhead = "none";

anonymous_xy.ref = edge_to_port(":f0:w", local_y);
local_y.next = edge_from_to_ports(":next", ":f0", o);

// anonymous_yx.ref.constraint = "false";
// anonymous_yx.ref.arrowhead = "none";

stack.rank = "same";

// root_head.presentation = invisible_edge(anonymous_yx);
// local_y.presentation = invisible_edge(local_x);
// local_x.presentation = invisible_edge(anonymous_xy);
// stack[4] = anonymous_yx;

var objects = [stack, gc_heap, rust_heap, root_head];
post_objects("intrusive_list_of_roots", objects, { rankdir:"LR", nodesep:0.2, no_dims: true, with_code: false });
</script>


<p>This is an <em>intrusive</em> list because the pointers in the list are
pointing into the interiors of objects. This allows traversing the
list to be completely uniform (from the viewpoint of the GC,
it looks like nothing more than a linked list of pairs).
In this scenario, the GC does essentially <em>zero</em> work on-the-fly
to find the locations of the roots;
maintaining the list would become the reponsibility of the mutator as
it creates and moves values with embedded roots.</p>

<p>However, Rust today does not have good support for intrusive data structures (<a href="https://github.com/rust-lang/rfcs/issues/417">RFC Issue 417</a>).
The already-mentioned capability to move values freely, as well as the
capability to swap a pre-existing <code>T</code> with the value held beind a
<code>&amp;mut T</code> reference, are among the reasons that intrusive structures
are difficult today, since it changes the addresses associated
with objects, and thus requires updating of the interior links.</p>

<p>So, what other options do we have?</p>

<p>Having the GC traverse the memory of the call-stack, even with the assistance of a stack map
to provide precise type information, will not give us the locations of all the roots,
since some are located on the Rust Heap. A stack map cannot hold the addresses of the blocks
of memory dynamically allocated for a box on the heap.</p>

<p>However, the stack map <em>can</em> hold the type information for the local
variables, and that sounds promising: If we record that a local
variable <code>o</code> has type <code>Box&lt;Struct&gt;</code>, then treat the contents of the
box on the heap as owned by the stack, so that when we encounter <code>o</code>
during the stack scan, we can recursively scan the memory of the box,
using the type <code>Struct</code> to inform the scan about how to treat each of
the embedded members.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
I have slightly modified the running example to show two instances
of the local <code>x</code> on the call-stack in separate frames, each corresponding
to a distinct (recursive) invocation of the function <code>fn f</code>.
<br></br>
This is just to bring home the point that the stack map info encodes
static information about the frame for a function (at a particular call-site),
and thus recursive invocations of the same function can potentially
reuse the same entry in the stack map.
</span></p>

<p id="stack_map_boxes"></p>




<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var rust_heap = { rankdir:"LR", id: "cluster_rust_heap", label: "Rust Heap", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };

var frame0 = { id: "cluster_frame0", label: "frame0: fn f()", is_subgraph: true };
var frame1 = { id: "cluster_frame1", label: "frame1: fn g()", is_subgraph: true };
var frame2 = { id: "cluster_frame2", label: "frame2: fn h()", is_subgraph: true };
var frame3 = { id: "cluster_frame3", label: "frame3: fn f()", is_subgraph: true };

var o = object_record("O: StructZ", "<f0> field z (root) = Gc(X1)");
o.id = "O";
var x  = object_record("X1", "...");
var x2 = object_record("X2", "...");
var y = object_record("Y", "...");
x.style = "rounded";
x2.style = "rounded";
y.style = "rounded";

var local_x = { id: "local_x1", label: "local x (root) = Gc(X1)", shape: "record" };
var local_x2 = { id: "local_x2", label: "local x (root) = Gc(X2)", shape: "record" };

var local_y = object_record("StructY", "<f0> field y (root) = Gc(Y)");
var local_o = { id: "local_o", label: "local o = Box(O)", shape: "record" };

frame0[0] = local_x;
frame1[0] = local_y;
frame2[0] = local_o;
frame3[0] = local_x2;

// frame3[0].ref = { is_edge: true, target: frame2[0], ltail: frame3.id, lhead: frame2.id, constraint: false };
// frame2[0].ref = { is_edge: true, target: frame1[0], ltail: frame2.id, lhead: frame1.id, constraint: false };
// frame1[0].ref = { is_edge: true, target: frame0[0], ltail: frame1.id, lhead: frame0.id, constraint: false };

stack[0] = frame0;
stack[1] = frame1;
stack[2] = frame2;
stack[3] = frame3;

local_x.ref = edge_to_port(":id:nw", x);
local_x2.ref = edge_to_port(":id:sw", x2);
local_y.ref = edge_from_to_ports(":f0", ":id", y);
local_o.box = edge_to_port(":id", o);

o.f0 = edge_from_to_ports(":f0", ":id:w", x);
rust_heap[0] = o;

gc_heap[2] = x;
gc_heap[3] = y;
gc_heap[4] = x2;

var objects = [stack, gc_heap, rust_heap];

stack.rank = "same";

post_objects("stack_map_boxes", objects, { rankdir:"LR", nodesep:0.2, compound: true, no_dims: true, with_code: false });
</script>


<p>The principle is that when control shifts to the GC coroutine,
it walks through the stack backtrace, consulting the stack
map for each callsite.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>stack_map_info for callsite 0x0010_ABBA in fn f:
</span><span class='line'>  local x:
</span><span class='line'>    offset: [...]
</span><span class='line'>    type: Gc&lt;X&gt;
</span><span class='line'>
</span><span class='line'>stack_map_info for callsite 0x0020_BACA in fn g:
</span><span class='line'>  local _:
</span><span class='line'>    offset: [...]
</span><span class='line'>    type: StructY
</span><span class='line'>
</span><span class='line'>stack_map_info for callsite 0x0030_C0C0 in fn h:
</span><span class='line'>  local o:
</span><span class='line'>    offset: [...]
</span><span class='line'>    type: Box&lt;StructZ&gt;</span></code></pre></td></tr></table></div></figure>


<p>From the stack map, it finds the offsets of relevant local variables
within that stack frame, and the type information for those locals, so
that it knows when it needs to dereference an pointer to inspect a
block on the Rust Heap (such as the <code>Box(O)</code> in our running example).</p>

<p>The GC will need separate meta-data describing the layout of each
type, with the offset and type of each field of interest:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>type_map_info for type StructY:
</span><span class='line'>  field y:
</span><span class='line'>    offset: [...]
</span><span class='line'>    type: Gc&lt;Y&gt;
</span><span class='line'>
</span><span class='line'>type_map_info for type Box&lt;StructZ&gt;:
</span><span class='line'>  field 0:
</span><span class='line'>    offset: [...]
</span><span class='line'>    type: StructZ
</span><span class='line'>
</span><span class='line'>type_map_info for type StructZ:
</span><span class='line'>  field z:
</span><span class='line'>    offset: [...]
</span><span class='line'>    type: Gc&lt;X&gt;</span></code></pre></td></tr></table></div></figure>


<p>The boxed objects may themselves own other root-holding objects on the Rust Heap,
like so:</p>

<p id="nested_stack_map_boxes" class="fullwidth"></p>




<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var rust_heap = { rankdir:"LR", id: "cluster_rust_heap", label: "Rust Heap", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };

var frame0 = { id: "cluster_frame0", label: "frame0: fn f()", is_subgraph: true };
var frame1 = { id: "cluster_frame1", label: "frame1: fn g()", is_subgraph: true };
var frame2 = { id: "cluster_frame2", label: "frame2: fn h()", is_subgraph: true };
var frame3 = { id: "cluster_frame3", label: "frame3: fn f()", is_subgraph: true };

var o = object_record("O: StructB", "<f0> field b (root) = Box(Z)");
o.id = "O";
var b = object_record("Z: StructZ", "<f0> field z (root) = Gc(X1)");
b.id = "B";
var x  = object_record("X1", "...");
var x2 = object_record("X2", "...");
var y = object_record("Y", "...");
x.style = "rounded";
x2.style = "rounded";
y.style = "rounded";

var local_x = { id: "local_x1", label: "local x (root) = Gc(X1)", shape: "record" };
var local_x2 = { id: "local_x2", label: "local x (root) = Gc(X2)", shape: "record" };

var local_y = object_record("StructY", "<f0> field y (root) = Gc(Y)");
var local_o = { id: "local_o", label: "local o = Box(O)", shape: "record" };

frame0[0] = local_x;
frame1[0] = local_y;
frame2[0] = local_o;
frame3[0] = local_x2;

// frame3[0].ref = { is_edge: true, target: frame2[0], ltail: frame3.id, lhead: frame2.id, constraint: false };
// frame2[0].ref = { is_edge: true, target: frame1[0], ltail: frame2.id, lhead: frame1.id, constraint: false };
// frame1[0].ref = { is_edge: true, target: frame0[0], ltail: frame1.id, lhead: frame0.id, constraint: false };

stack[0] = frame0;
stack[1] = frame1;
stack[2] = frame2;
stack[3] = frame3;

local_x.ref = edge_to_port(":id:w", x);
local_x2.ref = edge_to_port(":id:sw", x2);
local_y.ref = edge_from_to_ports(":f0", ":id", y);
local_o.box = edge_to_port(":id", o);

o.f0 = edge_from_to_ports(":f0", ":id:w", b);
b.f0 = edge_from_to_ports(":f0", ":id:nw", x);
rust_heap[0] = o;
rust_heap[1] = b;

gc_heap[2] = x;
gc_heap[3] = y;
gc_heap[4] = x2;

var objects = [stack, gc_heap, rust_heap];

stack.rank = "same";

post_objects("nested_stack_map_boxes", objects, { rankdir:"LR", nodesep:0.2, compound: true, no_dims: true, with_code: false });
</script>


<p>To find all the roots starting from the stack
in the presence of such ownership chains
(which may go through other types like <code>Vec</code>),
the GC will need to recursively traverse the boxes,
or otherwise enqueue them onto a worklist structure.
In principle, if we can prove that certain types never
transitively own roots, then the GC should be able to skip traversing
boxed data for such types.</p>

<p>Using the stack map and type map data to find all roots transitively
owned by the stack is a promising approach. What is the catch, if any?</p>

<a name="Unsafe.Pointers"></a>
<h2>Unsafe Pointers</h2>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
The <code>from_raw</code> method that converts a <code>*mut T</code> to <code>Box&lt;T&gt;</code>
is unsafe, but <code>into_raw</code> is a safe method. Safe code
can always convert a <code>Box&lt;T&gt;</code> to a <code>*mut T</code>, and clients
expect it to also be reasonable to round-trip via <code>from_raw</code>.
</span>
What should we do about unsafe pointers <code>*mut T</code> and <code>*const T</code>.
For example, it is not uncommon for library code to convert
boxed data <code>Box&lt;T&gt;</code> to a <code>*mut T</code> or vice versa;
that is an ownership transfer.</p>

<p>I used <code>local o = Box(O)</code> above (where <code>o: Box&lt;StructB&gt;</code>),
but it is entirely possible that <code>o</code> has type <code>*mut StructB</code>.</p>

<p>Here are some options for how to handle unsafe pointers:</p>

<ul>
<li><p>Skip unsafe pointers during root scanning.</p>

<p>This seems almost certain to cause unsound behavior; as noted above,
transmuting <code>Box&lt;T&gt;</code> to <code>*mut T</code> is an ownership transfer, and if
<code>T</code> holds a root, then later code might access it. This means that
the roots owned by <code>T</code> need to be scanned, to keep their associated
objects on the GC Heap alive.</p></li>
<li><p>Punt the question: if a program uses GC, any use of unsafe pointers
(as local variables or as members of structures) needs some sort of
attribute or annotation that tells the GC how to interpret the value
held in the unsafe pointer.</p>

<p>This would be quite difficult to put into practice. <a href="http://blog.pnkfx.org/blog/2015/11/10/gc-and-rust-part-1-specing-the-problem/">Part 1</a>
included a <a href="http://blog.pnkfx.org/blog/2015/11/10/gc-and-rust-part-1-specing-the-problem/#modularity">&ldquo;Modularity&rdquo; goal</a>:</p>

<blockquote><p>A Rust program that uses GC should be able to link to a crate
whose source code was authored without knowledge of GC.</p></blockquote>

<p>Requiring annotations on
every use of unsafe pointers means sacrificing this goal.</p></li>
<li><p>Treat unsafe pointers as potential root owners: Traverse them
and use their type as the basis for the scan.</p>

<p>This seems like the most reasonable option. But, can the types
of unsafe pointers be trusted?</p></li>
</ul>


<a name="Is.the.meta-data.trustworthy."></a>
<h2>Is the meta-data trustworthy?</h2>

<p>We assumed the existence of stack and type maps.
But where do they come from?</p>

<p>These maps need to be generated by the <code>rustc</code> compiler; after all,
they rely on low-level details of the generated code, such as the
offsets of fields within types, the offsets of local variables in a
stack frame, or the addresses of function call-sites.</p>

<p>The <code>rustc</code> compiler, in turn, is going to generate the information
based on the source code text. So far, so good.</p>

<p>Here&rsquo;s the rub: we assumed that the stack map will tell us the types
we need for all local variables of interest for all frames on the call
stack.</p>

<p>But in practice, a value can be <em>cast</em> to a different type.</p>

<p>In particular, in today&rsquo;s Rust 1.x, it is considered <em>safe</em> to cast
between <code>*mut T</code> and <code>*mut U</code> for any <code>T</code> and <code>U</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Box</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="s">&quot;peanut butter&quot;</span><span class="p">);</span> <span class="c1">// (imagine if this held rooted data)</span>
</span><span class='line'>    <span class="kd">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Box</span><span class="o">::</span><span class="n">into_raw</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">pb</span> <span class="o">=</span> <span class="n">p</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">String</span><span class="p">;</span> <span class="c1">// bogus type, but safe</span>
</span><span class='line'>    <span class="n">p</span> <span class="o">=</span> <span class="n">Box</span><span class="o">::</span><span class="n">into_raw</span><span class="p">(</span><span class="n">Box</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="s">&quot;jelly&quot;</span><span class="p">));</span>
</span><span class='line'>    <span class="c1">// this is where a potential GC would be worrisome</span>
</span><span class='line'>    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;p: {:?} p2: {:?}&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">pb</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// (just demonstrating recovery of original value via unsafe code)</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">pb</span> <span class="o">=</span> <span class="n">pb</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="o">&amp;</span><span class="n">&#39;static</span> <span class="kt">str</span><span class="p">;</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">recover</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="n">Box</span><span class="o">::</span><span class="n">from_raw</span><span class="p">(</span><span class="n">pb</span><span class="p">)</span> <span class="p">};</span>
</span><span class='line'>    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;recovered: {:?}&quot;</span><span class="p">,</span> <span class="n">recover</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is a real problem, in terms of the goals we have set up for ourselves.
100% modular GC requires that we be able to link with code that does things
like the above with the owners of its roots, and that includes when the roots
are indirectly held in boxes on the Rust Heap.</p>

<p>We may be able to add constraints on the <code>Gc&lt;T&gt;</code> type to prevent such things
from occurring when the types are apparent (e.g. when one is working with a
local variable of type <code>Gc&lt;T&gt;</code>). But in general, the types will
not be apparent to the code performing the cast; in particular,
we would still need to address type-parametric code that performs
such casts of unsafe pointers.</p>

<a name="Solutions"></a>
<h2>Solutions</h2>

<p>What can we do about these problems?</p>

<p>One obvious response to the untrustworthy meta-data problem would be to change the language and make casts from <code>*T</code> to <code>*U</code>
<em>unsafe</em>.<label for='unsafe-casts' class='margin-toggle sidenote-number'></label><input type='checkbox' id='unsafe-casts' class='margin-toggle'/><span class='sidenote'>Indeed, we may make such casts unsafe anyway; nmatsakis has said during informal conversation that he is not sure why we classified such casts as safe in the first place. </span>
 This would deal with the problem at a surface level, in the sense that
we would be able to at least allow a program using GC to link to a
GC-oblivious crate if the latter crate did not use any <code>unsafe</code>
blocks.
But it would not be terribly satisfactory; we want Rust&rsquo;s
solution for GC to be able to link to as many crates as possible, and
ruling out all code that does any cast of an unsafe pointer seems quite limiting.</p>

<p>We could also revise the set of goals, e.g. scale back our ambitions
with respect to compositionality, and return to ideas like having the
roots constrained to stack, as <a href="#Roots.Constrained.To.Stack..Option.2.">discussed above</a>.</p>

<p>An alternative solution I have been considering is to try to adopt a
hybrid approach for root scanning: use stack maps for the local
variables, but also have the allocator inject tracing meta-data onto
the objects allocated on the Rust Heap, and do a kind of conservative
scanning, but <em>solely</em> for finding roots embeded in objects on the
Rust Heap. This way, unsafe casts might become irrelevant: when
encountering <em>any</em> native pointer (e.g. <code>*mut u8</code>), we would ignore
the referenced type and instead look up whether it is an object on the
Rust Heap, and if so, extract the allocator-injected tracing
information.</p>

<p>I plan to dive more deeply into discussing solutions in a follow-up post.
This post is already quite long, but more importantly, I want to get some
concrete data first on the overheads imposed by the metadata injected during
allocation in state of the art conservative GC&rsquo;s like <a href="http://www.hboehm.info/gc/">BDW</a>.</p>

<hr />

<p>Oh, and finally (but completely unrelated): Happy 2016 to all the hackers out there!
Hope that you copied over all your live objects from 2015!</p>

<script>
// ## References
//
// * [On LLVM’s GC Infrastructure][on-llvms-gc]
//
// * [Compiler Support for Garbage Collection in a Statically Typed Language][diwan-moss-hudson]
</script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Surfaces and Signatures: Component Privacy versus Dependence]]></title>
    <link href="http://blog.pnkfx.org/blog/2015/12/19/signatures-and-surfaces-thoughts-on-privacy-versus-dependency/"/>
    <updated>2015-12-19T22:30:00+01:00</updated>
    <id>http://blog.pnkfx.org/blog/2015/12/19/signatures-and-surfaces-thoughts-on-privacy-versus-dependency</id>
    <content type="html"><![CDATA[<p>I have had some thoughts on what <em>privacy</em> is used for in programming
languages, and how it differs from the notion of <em>dependence</em> between
modules (or at least compilation units) in a language like Rust.
And I thought I should share.</p>

<!-- more -->


<p>I have been working on an
RFC<label for='arr-eff-what' class='margin-toggle sidenote-number'></label><input type='checkbox' id='arr-eff-what' class='margin-toggle'/><span class='sidenote'><a href="https://github.com/rust-lang/rfcs/">Request For Comment</a>: A document used to propose significant changes to the Rust language or standard library. </span>
meant to increase the expressiveness of Rust&rsquo;s privacy construct
(the <code>pub</code> modifier), and in the process hopefully simplify the mental
model for what privacy means there.</p>

<p>However, I kept finding myself diving into regressions in my draft RFC
document: idealized hypothetical semantics for privacy, and
discussions of what motivates different aspects of that semantics.</p>

<p>Eventually I realized that such text was going to really bog down the
RFC itself (which is meant to describe a relatively simple language
change);
so I decided it was time for a blog
post<label for='gc-posts' class='margin-toggle sidenote-number'></label><input type='checkbox' id='gc-posts' class='margin-toggle'/><span class='sidenote'>Yes, I know that I also am overdue for the next chapter in my <a href="http://blog.pnkfx.org/blog/categories/gc/">GC blog post series</a>; it is coming. </span>,
if for no other reason than to provide a place for me to cut-and-paste
all those digressions.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
Bugs including:
&ldquo;Trait re-exports fail due to privacy of containing module&rdquo; (<a href="https://github.com/rust-lang/rust/issues/18241">#18241</a>),
&ldquo;Rules governing references to private types in public APIs not enforced in impls&rdquo; (<a href="https://github.com/rust-lang/rust/issues/28325">#28325</a>)
&ldquo;Type alias can be used to bypass privacy check&rdquo; (<a href="https://github.com/rust-lang/rust/issues/28450">#28450</a>),
&ldquo;Private trait&rsquo;s methods reachable through a public supertrait&rdquo; (<a href="https://github.com/rust-lang/rust/issues/28514">#28514</a>),
&ldquo;Non-exported type in exported type signature does not error&rdquo; (<a href="https://github.com/rust-lang/rust/issues/29668">#29668</a>),
</span>
There are a number of bugs that have been filed against the privacy
checking in Rust; some are simply implementation issues, but the
comment threads in the issues make it clear that in some cases,
different people have very different mental models about how privacy
interacts with aliases (e.g. <code>type</code> declarations) and re-exports.</p>

<p>The existing privacy rules in Rust try to enforce two things:</p>

<ol>
<li><p>When an item references a path, all of the names on that path need to
be visible (in terms of privacy) in the referencing context, and,</p></li>
<li><p>Private items should not be exposed in the surface of public API&rsquo;s.</p></li>
</ol>


<p>One might reasonably ask: What do I mean by &ldquo;visible&rdquo;, or &ldquo;surface&rdquo;?</p>

<p>For Rust today, &ldquo;visible&rdquo; means &ldquo;either (1.) public, via <code>pub</code>, (2.)
defined in the current module, or (3.) defined in a parent of the
current module.&rdquo;</p>

<p>But &ldquo;surface&rdquo; is a bit more subtle, and before we discuss it, I want
to talk a bit about the purpose of &ldquo;visibility&rdquo; in the first place.</p>

<a name="Digression:.a.dependence.need.not.be.visible"></a>
<h2>Digression: a dependence need not be visible</h2>

<p>In a hypothetical idealized programming language (<em>not</em> Rust), and
under a particularly extreme reading of the term &ldquo;private&rdquo;, changes to
definitions that are private to one module would have no effect on the
validity of pre-existing uses from other modules. Another way of
looking at this: changes to private definitions in one compilation
unit would not require other compilation units to be recompiled, and
will not cause programs that previously type-checked to stop
type-checking.</p>

<p>One form of this ideal is the following:</p>

<script src="http://blog.pnkfx.org/javascripts/viz.js" charset="utf-8"></script>


<div id="extreme_private_calls"></div>


<script>
    var dot_source = 'digraph { rankdir="LR"; bgcolor="transparent"; node [shape="rect"]; subgraph cluster_1 { fn_a [label="pub fn a()"]; label="unit1"; } subgraph cluster_2 { fn_b [label="pub fn b()"]; fn_c [label="fn c()"]; fn_b -> fn_c [label="calls"]; label="unit2"; } fn_a -> fn_b [label="calls"]; }';
    var elem = document.getElementById("extreme_private_calls");
    elem.innerHTML = Viz(dot_source, "svg");
</script>


<p>In this picture, one can see that the <code>fn c()</code> is a private component
of &ldquo;unit2&rdquo;: it may just be an implementation detail of the body of
<code>pub fn b()</code>, that the author of &ldquo;unit2&rdquo; can revise at will or
eliminate entirely, without requiring any changes to &ldquo;unit1&rdquo;
downstream.</p>

<p>A problem arises when one sees other kinds of composition, at least in
language like Rust, where values are directly embedded into their
containers.  For example, instead of function calls, imagine type
definitions:</p>

<script src="http://blog.pnkfx.org/javascripts/viz.js" charset="utf-8"></script>


<div id="extreme_private_types"></div>


<script>
    var dot_source = 'digraph { rankdir="LR"; bgcolor="transparent"; node [shape="rect"]; subgraph cluster_1 { struct_a [label="pub struct A { \\l    b: unit2::B \\l}\\l"]; label="unit1"; } subgraph cluster_2 { struct_b [label="pub struct B { \\l    c: C \\l}\\l"]; struct_c [label="struct C {\\l    x: i32,\\l    y: i32\\l}\\l"]; label="unit2"; } struct_a -> struct_b [label="uses"]; struct_b -> struct_c[label="uses", constraint=false] }';
    var elem = document.getElementById("extreme_private_types");
    elem.innerHTML = Viz(dot_source, "svg");
</script>


<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
In many other languages (e.g. Java, ML, Scheme), such
changes do not require recompiling the downstream crate, because
the members of structural types are just <em>references</em> to other heap-allocated
values, rather than being directly embedded in the allocated structure.
</span>
In this situation, even though the <code>struct C</code> is not publicly
accessible outside of &ldquo;unit2&rdquo;, changes to <code>struct C</code> will still
require the downstream &ldquo;unit1&rdquo; to be recompiled (because the contents
of <code>struct A</code>, and thus its size in bytes, may have changed along with
<code>struct C</code>).</p>

<p>So, what does it <em>mean</em> that <code>C</code> is &ldquo;private&rdquo;, if there is still a
dependence from the contents of &ldquo;unit1&rdquo; on the supposedly private
definition of <code>struct C</code>?</p>

<p>My answer to this is to distinguish between <em>visibility</em> versus <em>dependency</em>.</p>

<p>In the above picture, <code>struct A</code> in &ldquo;unit1&rdquo; has a dependence on the
definition of <code>struct C</code> in &ldquo;unit2&rdquo;. But <code>struct C</code> remains
<em>invisible</em> to <code>struct A</code>, in the sense that one cannot actually write
a direct reference to that type in the context of &ldquo;unit1.&rdquo;</p>

<a name="What.is.visibility.for."></a>
<h2>What is visibility for?</h2>

<p>Some basic definitions: An item is just as it is declared in the Rust
<a href="https://doc.rust-lang.org/reference.html#items">reference manual</a>: a component of a crate, located at a fixed path
(potentially at the &ldquo;outermost&rdquo; anonymous module) within the module
tree of the crate.</p>

<p>Every item can be thought of as having some hidden implementation
component(s) along with an exposed surface API.</p>

<p>So, for example, in:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">pub</span> <span class="k">fn</span> <span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Output</span> <span class="p">{</span> <span class="n">Body</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>the surface of <code>fn foo</code> includes <code>Input</code> and <code>Output</code>, while the <code>Body</code> is
hidden.</p>

<p>What I would like is to establish the following
invariant<label for='inv' class='margin-toggle'> &#8853;</label><input type='checkbox' id='inv' class='margin-toggle'/><span class='marginnote'>Yes, this is basically a rephrasing of the second of the previously-stated pair of goals of the existing privacy rules. </span>
for the language: if an item <code>I</code> is accessible in context <code>C</code>, then the
surface for <code>I</code> does not expose anything that is inaccessible to <code>C</code>.</p>

<a name="Intuition.behind.what..surface..means"></a>
<h2>Intuition behind what &ldquo;surface&rdquo; means</h2>

<p>I am taking care to distinguish between the phrase &ldquo;exposed surface
API&rdquo; (more simply put, &ldquo;surface API&rdquo; or just &ldquo;surface&rdquo;), versus the
more common unqualified phrase &ldquo;API&rdquo;, because some items have
components that I argue are part of the item&rsquo;s programming interface,
but are not part of the publicly exposed surface of the item (further
discussed in a <a href="#Why.is.a..surface..not.the.same.as.a.signature.">later section</a>).</p>

<p>The inutition behind the term &ldquo;surface&rdquo; is this:
The exposed surface of an item is all of the
components<label for='surface-components' class='margin-toggle'> &#8853;</label><input type='checkbox' id='surface-components' class='margin-toggle'/><span class='marginnote'>&ldquo;components&rdquo; means: types, methods, paths &hellip; perhaps its easiest to just say &ldquo;names.&rdquo; </span>
 that the client operation&rsquo;s context must be able to reference to in order to use this
item legally.</p>

<p>There are two halves to this, that are roughly analogous to the output
and input types of a function: ensuring that local reasoning holds,
and ensuring an interface is actually usable.</p>

<a name="Restricting.output.surface.enables.local.reasoning"></a>
<h3>Restricting output surface enables local reasoning</h3>

<p>A function&rsquo;s return type is part of its exposed surface, because if
a module has decided that a type <code>T</code> should be inaccessible in some
outer context <code>C</code>, then we do not want a value of that type to flow
into <code>C</code> while still having the type
<code>T</code>.<label for='boxes' class='margin-toggle'> &#8853;</label><input type='checkbox' id='boxes' class='margin-toggle'/><span class='marginnote'>Of course if the type of the value is hidden, e.g. a <code>Box&lt;PrivateType&gt;</code> behind a <code>Box&lt;PublicTrait&gt;</code>, then that is fine as always. </span></p>

<p>In other words, we wish to reject such code in order to enable
module authors to employ <em>local reasoning</em> about all possible
locations in the source code that the operations on instances of
<code>T</code> could be invoked.</p>

<p>This <em>is</em> a soundness criteria: People need to be able to employ
this kind of reasoning.</p>

<a name="Restricting.input.surface.catches.API.mistakes"></a>
<h3>Restricting input surface catches API mistakes</h3>

<p>A function&rsquo;s input types are part of its exposed surface, because
without access to such types, the function is not callable.</p>

<p>In other words, we wish to reject such code in order to catch bugs
where a crate is <em>accidentally providing</em> a function without realizing
that it cannot actually be used in the contexts that the author wants
it available in.</p>

<p>This is not a soundness criteria; it is just a language usability one.<label for='prioritizing-halves' class='margin-toggle'> &#8853;</label><input type='checkbox' id='prioritizing-halves' class='margin-toggle'/><span class='marginnote'>In the long run, I suspect that the local reasoning enabled by restricting the output surface is going to be more important than the benefits of restricting the input surface. I am not aware of any case where we actually need to <emph>choose</emph> between the two; I am more speaking of where we should direct our attention. </span></p>

<a name="Why.is.a..surface..not.the.same.as.a.signature."></a>
<h2>Why is a &ldquo;surface&rdquo; not the same as a signature?</h2>

<p>Intuitively, one might ask: &ldquo;well, this is easy: the <em>signature</em> of
<code>fn foo</code> is <code>fn (Input) -&gt; Output</code>; does that not suffice as the
description of the <em>surface</em> of <code>fn foo</code>?&rdquo;</p>

<p>I am distinguishing the above notion of &ldquo;surface&rdquo; from the idea of a
&ldquo;signature&rdquo;, for the following reason: To my mind, the signature
(e.g. of a type or a function) contains all of the meta-data needed to
check (in the current crate or in other crates) whether a item is
being used properly. Such a signature may include references to names
that are not actually accessible in the current context. Compare this
to the <em>surface</em>, which is the subset of the names of the signature
that <em>must</em> be accessible in any context where the item is itself
accessible.</p>

<p>One example of where this kind of thinking can be applied is
<code>where</code> clauses. A where-clause can reference things that are not
accessible outside of the module of the function.  I would consider
such a <code>where</code> clause to still be part of the function&rsquo;s signature
(e.g., I would expect the compiler to reject my attempt to call the
function if I violate the encoded constraint), but I do not
necessarily consider the types or traits within that where clause part
of the surface API, since there are hidden parts to the constraint
that I do not have access to in my calling module.</p>

<p>Here is a concrete example that runs in Rust 1.5:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kn">mod</span> <span class="n">a</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">S</span><span class="p">(</span><span class="o">&amp;</span><span class="n">&#39;static</span> <span class="kt">str</span><span class="p">);</span>                 <span class="c1">// private struct type S</span>
</span><span class='line'>    <span class="k">pub</span> <span class="k">trait</span> <span class="n">Trait</span> <span class="p">{</span> <span class="k">fn</span> <span class="n">compute</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">i32</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="p">(</span><span class="kt">i32</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">fn</span> <span class="n">compute</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">i32</span> <span class="p">{</span> <span class="bp">self</span><span class="p">.</span><span class="mi">0</span> <span class="o">+</span> <span class="p">((</span><span class="bp">self</span><span class="p">.</span><span class="mi">1</span><span class="p">).</span><span class="mf">0.</span><span class="n">len</span><span class="p">()</span> <span class="k">as</span> <span class="kt">i32</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">pub</span> <span class="k">fn</span> <span class="n">foo</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">i32</span>
</span><span class='line'>        <span class="n">where</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span><span class="o">:</span> <span class="n">Trait</span> <span class="c1">// where clause refers to private type S</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">S</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">)).</span><span class="n">compute</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span> <span class="n">a</span><span class="o">::</span><span class="n">foo</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>There are other examples that we may want to support in the future.
For example, Rust (version 1.5) considers bounding a type parameter
directly via a private trait to be illegal, but we might reasonably
revise the rules to say that while such a bound is part of the
signature, it need not be part of the <em>surface</em>.</p>

<p>(A very similar construction is allowed in Rust 1.5: A <code>pub</code> trait
can have a private <em>parent</em> trait, which allows us to encode the
latter construction anyway: the surface area of a function does not
include the parent traits of bounds on its type parameters.)</p>

<p>That&rsquo;s a lot of text to read. Here is the kind of code I am talking
about:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kn">mod</span> <span class="n">a</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">S</span><span class="p">(</span><span class="n">String</span><span class="p">);</span>                      <span class="c1">// private type</span>
</span><span class='line'>    <span class="k">trait</span> <span class="n">Trait</span> <span class="p">{</span> <span class="k">fn</span> <span class="n">make_s</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">S</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// private trait</span>
</span><span class='line'>    <span class="k">pub</span> <span class="k">trait</span> <span class="n">SubT</span><span class="o">:</span> <span class="n">Trait</span> <span class="p">{</span> <span class="p">}</span>              <span class="c1">// public trait to placate rustc</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">pub</span> <span class="k">fn</span> <span class="n">foo</span><span class="o">&lt;</span><span class="n">X</span><span class="o">:</span><span class="n">SubT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">X</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// public fn that external code *can* use.</span>
</span><span class='line'>        <span class="kd">let</span> <span class="n">s</span><span class="o">:</span> <span class="n">S</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">make_s</span><span class="p">();</span>
</span><span class='line'>        <span class="n">s</span><span class="p">.</span><span class="n">do_stuff</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Impl trait for both () and i32, so clients can call `foo` on () or i32.</span>
</span><span class='line'>    <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="p">()</span> <span class="p">{</span> <span class="k">fn</span> <span class="n">make_s</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">S</span> <span class="p">{</span> <span class="n">S</span><span class="p">(</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;():()&quot;</span><span class="p">))</span> <span class="p">}</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="kt">i32</span> <span class="p">{</span> <span class="k">fn</span> <span class="n">make_s</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">S</span> <span class="p">{</span> <span class="n">S</span><span class="p">(</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}:i32&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span> <span class="p">}</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">impl</span> <span class="n">SubT</span> <span class="k">for</span> <span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>    <span class="k">impl</span> <span class="n">SubT</span> <span class="k">for</span> <span class="kt">i32</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">impl</span> <span class="n">S</span> <span class="p">{</span> <span class="k">fn</span> <span class="n">do_stuff</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span> <span class="p">{</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;stuff with {}&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span> <span class="p">}</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">a</span><span class="o">::</span><span class="n">foo</span><span class="p">(());</span>
</span><span class='line'>    <span class="n">a</span><span class="o">::</span><span class="n">foo</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>In short: the term &ldquo;surface API&rdquo; here is <em>not</em> synonymous with the
term &ldquo;signature&rdquo;.</p>

<p>Assuming that you believe me that this new term, &ldquo;surface API&rdquo;, is
actually warranted, you might now ask: &ldquo;How does one determine the
surface API of an item?&rdquo; That is one of those questions that may sound
trivial at first, but it is actually a bit subtle.</p>

<p>Let us explore.</p>

<a name="Some.items.can.change.their.surface.based.on.context"></a>
<h3>Some items can change their surface based on context</h3>

<p>For some items, such as <code>fn</code> definitions, the surface API is the same
regardless of the context of where the item is used; for example, if a
function is visible to you, then its surface API is simply its
argument and return types, regardless of from where the function is
referenced.</p>

<p>However, the previous rule does not generally hold for most items; in
general, the exposed surface of a given item is dependent on the
context where that item is referenced.</p>

<p>The main examples of this are:</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
All of these bullets are phrased as &ldquo;can be hidden&rdquo;, i.e.,
the visibility may be restricted. However, in Rust today,
one can write: <code>mod a{struct X{pub y: i32}}</code>
I may want to generalize the statements here. (Then again, I
am not clear whether there is any way to actually <em>use</em> the
<code>y</code> field that has been exposed in this way.)
</span></p>

<ul>
<li><p><code>struct</code> fields can be hidden in a <code>struct</code>,</p></li>
<li><p>inherent methods can be hidden relative to the type they are attached to, and</p></li>
<li><p>items can be hidden in a <code>mod</code>.</p></li>
</ul>


<p>In all cases where a surface component can be hidden in this
context-dependent fashion, there is an associated <code>pub</code>-modifier
present on the definition of that component.</p>

<p>As an example of how the surface of a <code>struct</code> is context dependent,
the following is legal:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kn">mod</span> <span class="n">a</span> <span class="p">{</span>
</span><span class='line'>    <span class="cp">#[derive(Default)]</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">Priv</span><span class="p">(</span><span class="kt">i32</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">pub</span> <span class="kn">mod</span> <span class="n">b</span> <span class="p">{</span>
</span><span class='line'>        <span class="cp">#[derive(Default)]</span>
</span><span class='line'>        <span class="k">pub</span> <span class="k">struct</span> <span class="n">F</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">pub</span>    <span class="n">x</span><span class="o">:</span> <span class="kt">i32</span><span class="p">,</span>
</span><span class='line'>                   <span class="n">y</span><span class="o">:</span> <span class="o">::</span><span class="n">a</span><span class="o">::</span><span class="n">Priv</span><span class="p">,</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// ... accesses to F.{x,y} ...</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">// ... accesses to F.x ...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kn">mod</span> <span class="n">k</span> <span class="p">{</span>
</span><span class='line'>  <span class="kn">use</span> <span class="n">a</span><span class="o">::</span><span class="n">b</span><span class="o">::</span><span class="n">F</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// ... accesses to F and F.x ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Within <code>mod b</code>, the surface API of <code>F</code> includes both the fields <code>x</code>
and <code>y</code>, which means that the use of the type <code>Priv</code> is okay, since
that is accessible from the context of <code>mod b</code>.</p>

<p>Elsewhere, such as within <code>mod k</code>, the surface API of <code>F</code> is just the
field <code>x</code>. But this is again okay, because the type of <code>x: i32</code> is
visible everywhere.</p>

<a name="Aliases.and.translucency"></a>
<h3>Aliases and translucency</h3>

<p>Some items, such as <code>type</code> aliases, <code>const</code> definitions, or rebinding
imports a la <code>use &lt;path&gt; as &lt;ident&gt;</code>, can act to introduce named aliases
to an item.</p>

<p>In such cases, the alias itself has its own associated visibility:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kn">mod</span> <span class="n">a</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">pub</span> <span class="k">struct</span> <span class="n">S</span><span class="p">(</span><span class="n">String</span><span class="p">);</span> <span class="c1">// public type</span>
</span><span class='line'>    <span class="k">type</span> <span class="n">Alias1</span> <span class="o">=</span> <span class="n">S</span><span class="p">;</span>      <span class="c1">// private alias to the type</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">pub</span> <span class="kn">use</span> <span class="n">a</span><span class="o">::</span><span class="n">S</span> <span class="k">as</span> <span class="n">Alias2</span><span class="p">;</span>   <span class="c1">// public alias to the type</span>
</span></code></pre></td></tr></table></div></figure>


<p>The surface of simple aliases is also simple: the surface of an
alias
is just the paths referenced on its right-hand side.</p>

<p>As a small additional wrinkle, type aliases can be type-parametric. In
general, the exposed surface of a type alias are the bounds on its
type parameters, plus the paths referenced on its left-hand side.</p>

<p>So, for example, according to the rules today:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kn">mod</span> <span class="n">bad_aliases</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">Private1</span><span class="p">(</span><span class="n">String</span><span class="p">);</span> <span class="c1">// private type</span>
</span><span class='line'>    <span class="k">pub</span> <span class="k">type</span> <span class="n">PubAlias1</span> <span class="o">=</span> <span class="n">Private1</span><span class="p">;</span> <span class="c1">// ERROR: private type exposed in pub surface</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">trait</span> <span class="n">PrivateTrait</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">pub</span> <span class="k">type</span> <span class="n">PubAlias2</span><span class="o">&lt;</span><span class="n">X</span><span class="o">:</span><span class="n">PrivateTrait</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">i32</span><span class="p">;</span> <span class="c1">// ERROR: private trait exposed in pub surface</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The more interesting issue is how <em>other</em> surface APIs are influenced
when they reference an alias.</p>

<p>For example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kn">mod</span> <span class="n">a</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">pub</span> <span class="k">struct</span> <span class="n">S</span><span class="p">(</span><span class="n">String</span><span class="p">);</span> <span class="c1">// public type</span>
</span><span class='line'>    <span class="k">type</span> <span class="n">Alias1</span> <span class="o">=</span> <span class="n">S</span><span class="p">;</span>      <span class="c1">// private alias to the type</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">pub</span> <span class="k">fn</span> <span class="n">twice</span><span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="n">Alias1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span> <span class="n">s</span><span class="p">.</span><span class="mi">0</span> <span class="p">}</span>
</span><span class='line'>    <span class="c1">//              ~~~~~~</span>
</span><span class='line'>    <span class="c1">//                 |</span>
</span><span class='line'>    <span class="c1">// Should a `pub fn` be able to reference a private alias,</span>
</span><span class='line'>    <span class="c1">// if it points to a suitably public type (like `S` here)?</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">pub</span> <span class="kn">use</span> <span class="n">a</span><span class="o">::</span><span class="n">S</span> <span class="k">as</span> <span class="n">Alias2</span><span class="p">;</span>   <span class="c1">// public alias to the type</span>
</span></code></pre></td></tr></table></div></figure>


<p>Should it be legal for us to publicly export <code>fn twice</code> from <code>mod a</code>,
even though it&rsquo;s signature references a private type alias?</p>

<p>The language team recently <a href="https://github.com/rust-lang/rust/pull/29973#issuecomment-165723770">debated</a> this topic, because
it was suggested that allowing this would <a href="https://github.com/rust-lang/rust/pull/29973#issuecomment-158686899">reduce breakage</a>
from a pull request.</p>

<p>The conclusion for now was to continue to disallow the reference to
the private alias in the signature of a public function.</p>

<p>However, there are similar cases that <em>are</em> allowed today (also
discussed on that same PR), mainly involving references to <code>const</code> paths
from types in such signatures.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kn">mod</span> <span class="n">a</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">const</span> <span class="n">LEN</span><span class="o">:</span> <span class="n">usize</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span><span class='line'>    <span class="k">pub</span> <span class="k">fn</span> <span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="p">[</span><span class="kt">i32</span><span class="p">;</span> <span class="n">LEN</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">i32</span> <span class="p">{</span> <span class="n">a</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">i</span><span class="o">|*</span><span class="n">i</span><span class="p">).</span><span class="n">max</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'>    <span class="c1">//                  ~~~</span>
</span><span class='line'>    <span class="c1">//                   |</span>
</span><span class='line'>    <span class="c1">// A reference to a private const in a public signature</span>
</span><span class='line'>    <span class="c1">// is legal in Rust today.</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span> <span class="n">a</span><span class="o">::</span><span class="n">max</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>I have not made up my mind as to which option would be better here.
We may decide to leave things as they are, or loosen the rules for
type aliases (so that they act more like <code>const</code> in the latter code),
or we may tighten the rules for references to <code>const</code> (so that one
would have to make <code>LEN</code> in the above code <code>pub</code>).</p>

<p>Regardless of what path we take, I think it makes sense today for the
language specification to at least identify a high-level abstraction
here, rather than dealing with each alias-creating form like <code>type</code> or
<code>const</code> or <code>use</code> individually in an ad-hoc manner.</p>

<p>Namely, I want to pin down the idea of a <em>translucent name</em>. Such a
name is not part of the API surface where it occurs; instead, an
occurrence adds the surface of the alias statement itself to the API
surface.</p>

<p>So, as another artifical example, if we were to change the language so
that <code>type</code> aliases were <em>translucent</em> when determining the exposed
surface of an API, then we might have the following:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kn">mod</span> <span class="n">a</span> <span class="p">{</span> <span class="c1">// (not legal Rust today)</span>
</span><span class='line'>    <span class="k">pub</span> <span class="k">struct</span> <span class="n">S</span><span class="p">(</span><span class="n">String</span><span class="p">);</span> <span class="c1">// public type</span>
</span><span class='line'>    <span class="k">pub</span> <span class="k">trait</span> <span class="n">Bound</span> <span class="p">{</span> <span class="k">type</span> <span class="n">X</span><span class="p">;</span> <span class="k">fn</span> <span class="n">trait_method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="o">::</span><span class="n">X</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">impl</span> <span class="n">Bound</span> <span class="k">for</span> <span class="n">String</span> <span class="p">{</span> <span class="k">type</span> <span class="n">X</span> <span class="o">=</span> <span class="n">String</span><span class="p">;</span> <span class="k">fn</span> <span class="n">trait_method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span> <span class="bp">self</span><span class="p">.</span><span class="n">clone</span><span class="p">()</span> <span class="p">}</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">impl</span> <span class="n">Bound</span> <span class="k">for</span> <span class="n">S</span> <span class="p">{</span> <span class="k">type</span> <span class="n">X</span> <span class="o">=</span> <span class="n">String</span><span class="p">;</span> <span class="k">fn</span> <span class="n">trait_method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span> <span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">clone</span><span class="p">()</span> <span class="p">}</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">type</span> <span class="n">Alias</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span> <span class="n">Bound</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="o">::</span><span class="n">X</span><span class="p">,</span> <span class="n">S</span><span class="p">);</span> <span class="c1">// private Alias, with surface = {Bound, S}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">pub</span> <span class="k">fn</span> <span class="n">free_fun</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span> <span class="n">Bound</span><span class="o">&lt;</span><span class="n">X</span><span class="o">=</span><span class="n">String</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="n">Alias</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span>
</span><span class='line'>    <span class="c1">//                 ~~~~~   ~~~~~~      ~~~~~        ~~~~~~</span>
</span><span class='line'>    <span class="c1">//  free_fun has     |       |           |            |</span>
</span><span class='line'>    <span class="c1">//     surface = { Bound, String, surface(Alias), String }</span>
</span><span class='line'>    <span class="c1">//             = { Bound, String,    Bound, S   , String }</span>
</span><span class='line'>    <span class="c1">//             = { Bound, S, String }</span>
</span><span class='line'>    <span class="c1">//</span>
</span><span class='line'>    <span class="c1">// which is compatible with `free_fn` being `pub`, because</span>
</span><span class='line'>    <span class="c1">// `Bound`, `S`, and `String` are all `pub`.</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}{}&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="mf">0.</span><span class="n">trait_method</span><span class="p">(),</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="mi">1</span><span class="p">).</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note 1: Even though <code>Alias</code> is type-parameteric over <code>T</code>, that
parameter would not be considered part of its surface. Anyone using
the alias would have to have access to whatever type they plugged in
there, of course.</p>

<p>Note 2: Type parameter bounds not enforced on type aliases in Rust yet.</p>

<p>This computation and questions here would become a little more
interesting if we had restricted visibility access modifiers on
associated items in traits. However, we do not have to consider it:
All associated items are implicitly <code>pub</code>, and so we do not need to
worry about whether the <code>X</code> in a projection like <code>T::X</code> is visible.
All that matters is whether the trait <code>Bound</code> itself is visible (which
is already reflected in the surfaces where <code>Bound</code> is used).</p>

<a name="Conclusion"></a>
<h2>Conclusion</h2>

<p>Okay, that was of a bit of a meandering tour through some
of the issues I have been thinking about.</p>

<p>The big ideas I want to stress are these:</p>

<ul>
<li><p>The &ldquo;surface&rdquo; of an item can be different from the &ldquo;signature&rdquo; of
that item.</p></li>
<li><p>Restricting the components in a surface of an item according to the
visibility of that item (1.) enables local reasoning and (2.)
catches API mistakes.</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fixing Octopress Table Rendering]]></title>
    <link href="http://blog.pnkfx.org/blog/2015/12/18/fixing-octopress-table-rendering/"/>
    <updated>2015-12-18T22:00:00+01:00</updated>
    <id>http://blog.pnkfx.org/blog/2015/12/18/fixing-octopress-table-rendering</id>
    <content type="html"><![CDATA[<p>Learn how I hacked the SCSS for my blog to get tables to look right,
without breaking everything else (I hope).</p>

<!-- more -->


<p>Here is a sample table.</p>

<table>
<thead>
<tr>
<th>key </th>
<th> value1 </th>
<th> value2</th>
</tr>
</thead>
<tbody>
<tr>
<td>a   </td>
<td> apple  </td>
<td> aardvark</td>
</tr>
<tr>
<td>b   </td>
<td> banana </td>
<td> bonobo</td>
</tr>
<tr>
<td>c   </td>
<td> clementine </td>
<td> cat</td>
</tr>
</tbody>
</table>


<p>It is written in my blog source via this source text:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>key | value1 | value2
</span><span class='line'>----|--------|----------
</span><span class='line'>a   | apple  | aardvark
</span><span class='line'>b   | banana | bonobo
</span><span class='line'>c   | clementine | cat</span></code></pre></td></tr></table></div></figure>


<p>The default octopress presentation of such a table just smushes the
text into a grid, but does not render the division of the header,
rows, columns, nor cells in any way (no borders, no colors, et
cetera).</p>

<p>After hearing a colleague complain about how bad that default
presentation looked compared to what Github does with such tables, I
decided to try to figure out how to fix it.</p>

<p>First, I opened up gist.github.com and put my table into a gist there
(with a <code>.md</code>) extension, so I could see what github does to render
such tables.</p>

<p>By hitting &ldquo;Inpsect Element&rdquo; and looking at the
cascading style sheet (CSS) settings for the <code>table</code>, <code>tr</code>, <code>th</code>, and
<code>td</code> elements,<label for='settings' class='margin-toggle'> &#8853;</label><input type='checkbox' id='settings' class='margin-toggle'/><span class='marginnote'>Namely, the <code>border</code>, <code>padding</code>, <code>font-weight</code>, <code>background-color</code>, and <code>margin-bottom</code> settings. </span>
I identified the things that needed to change.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
The one trick I <em>will</em> note, since its a pretty cute hack on the
part of CSS, is the way it uses the <code>:nth-child</code> selector to
differentiate the even rows from the odd rows when deciding on the
background color.
</span>
You can see the specific changes, with comments, in the <code>.scss</code>
file transcribed below; I will not describe the effect of each one
here.</p>

<p>My usual tactic when doing this sort of interactive exploration of CSS
is to toggle each such setting on and off in the reference document
(the rendered gist, in this case), to see the effect of the setting on
the overall document, and then manually enter the setting into a
similarly inspected element in the target document where I am trying
to recreate the effect.</p>

<p>To limit the effect of the styling to just the tables that appear in a
blog post, I made sure that each CSS customization was prefixed by
<code>.entry-content</code>; I had determined via inspection that each block
entry is surrounded by a <code>&lt;div class="entry-content"&gt;</code>.</p>

<p>So, I added the customizations to my <code>sass/custom/_styles.scss</code>,
regenerated my site, and looked at the result. It was quite promising,
except for one big problem: I had changed the formatting for <em>all</em>
tables, including the ones that are used to render code snippets!</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
I will admit that I do not actually know the semantics of an
&ldquo;inherit&rdquo; setting. I assume it means something like &ldquo;inherit the
value from your parent element, based on the context of where you
appear in the document.&rdquo;
</span>
So I further revised the CSS so that, when you are in the context of a
<code>class="code"</code> underneath a <code>class="entry-content"</code>, <em>then</em> you should
just inherit the setting, rather than using the values specified here.</p>

<p>Anyway, <em>that</em> seemed to work great!</p>

<p>So here&rsquo;s my customized <code>_better_tables.scss</code> file (which is
imported into the aformentioned <code>_styles.scss</code> file via
<code>@import "better_tables";</code>)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='scss'><span class='line'><span class="c1">// make the text for the header row bold and centered.</span>
</span><span class='line'><span class="c1">// (I have not been able to figure out where jekyll/octopress are overriding</span>
</span><span class='line'><span class="c1">//  the text-align and setting it to `left`)</span>
</span><span class='line'><span class="nc">.entry-content</span> <span class="nt">th</span> <span class="p">{</span> <span class="na">font-weight</span><span class="o">:</span> <span class="no">bold</span><span class="p">;</span> <span class="na">text-align</span><span class="o">:</span> <span class="no">center</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// typography for p/blockquote/ul/ol puts a 1.5em margin below those elements,</span>
</span><span class='line'><span class="c1">// so do the same for our tables ...</span>
</span><span class='line'><span class="nc">.entry-content</span> <span class="nt">table</span> <span class="p">{</span> <span class="na">margin-bottom</span><span class="o">:</span> <span class="mi">1</span><span class="mf">.5</span><span class="kt">em</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// ... but undo that for tables for pygments-generated code</span>
</span><span class='line'><span class="nc">.entry-content</span> <span class="nc">.code</span> <span class="nt">table</span> <span class="p">{</span> <span class="na">margin-bottom</span><span class="o">:</span> <span class="no">inherit</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">// add a border around each cell and padding around its content ...</span>
</span><span class='line'><span class="nc">.entry-content</span> <span class="nt">th</span><span class="o">,</span> <span class="nc">.entry-content</span> <span class="nt">td</span> <span class="p">{</span>
</span><span class='line'>  <span class="na">border</span><span class="o">:</span> <span class="mi">1</span><span class="kt">px</span> <span class="no">solid</span> <span class="mh">#ddd</span><span class="p">;</span>
</span><span class='line'>  <span class="na">padding</span><span class="o">:</span> <span class="mi">6</span><span class="kt">px</span> <span class="mi">13</span><span class="kt">px</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// ... but undo that for tables for pygments-generated code</span>
</span><span class='line'><span class="nc">.entry-content</span> <span class="nc">.code</span> <span class="nt">th</span><span class="o">,</span> <span class="nc">.entry-content</span> <span class="nc">.code</span> <span class="nt">td</span> <span class="p">{</span>
</span><span class='line'>  <span class="na">border</span><span class="o">:</span> <span class="no">inherit</span><span class="p">;</span> <span class="na">padding</span><span class="o">:</span> <span class="no">inherit</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">// zebra-stripe the rows (N.B. `nth-child(2n)` works too) ...</span>
</span><span class='line'><span class="nc">.entry-content</span> <span class="nt">tr</span>                 <span class="p">{</span> <span class="na">background-color</span><span class="o">:</span> <span class="mh">#FFFFFF</span> <span class="p">}</span>
</span><span class='line'><span class="nc">.entry-content</span> <span class="nt">tr</span><span class="nd">:nth-child</span><span class="o">(</span><span class="nt">even</span><span class="o">)</span> <span class="p">{</span> <span class="na">background-color</span><span class="o">:</span> <span class="mh">#F8F8F8</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// ... but undo that for tables for pygments-generated code</span>
</span><span class='line'><span class="nc">.entry-content</span> <span class="nc">.code</span> <span class="nt">tr</span>                 <span class="p">{</span> <span class="na">background-color</span><span class="o">:</span> <span class="no">inherit</span> <span class="p">}</span>
</span><span class='line'><span class="nc">.entry-content</span> <span class="nc">.code</span> <span class="nt">tr</span><span class="nd">:nth-child</span><span class="o">(</span><span class="nt">even</span><span class="o">)</span> <span class="p">{</span> <span class="na">background-color</span><span class="o">:</span> <span class="no">inherit</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cherry-picking from the shoulders of giants]]></title>
    <link href="http://blog.pnkfx.org/blog/2015/11/27/cherrypicking-tuftes-of-hair/"/>
    <updated>2015-11-27T14:00:00+01:00</updated>
    <id>http://blog.pnkfx.org/blog/2015/11/27/cherrypicking-tuftes-of-hair</id>
    <content type="html"><![CDATA[<p>This post: I describe some changes to my blog&rsquo;s presentation
format, and how I hacked them in by cherry-picking from the shoulders
of giants.</p>

<!-- more -->


<p>I&rsquo;m a big fan of Edward Tufte&rsquo;s work on presentation of
information. He mostly focuses on graphical presentations, especially
of statistical data. But really one can learn much from his overall
presentation style, e.g. from how he formats his text.</p>

<p>Of course I am not the first person to recognize this. :)</p>

<p>Lots of people have been adapting Tufte&rsquo;s style to formats compatible
with standard electronic authoring environments.</p>

<ul>
<li><p><a href="https://tufte-latex.github.io/tufte-latex/">tufte-latex</a> is pretty cool, if you&rsquo;re working in the realm of
LaTeX. (For example, <a href="http://www.mpi-sws.org/~turon/turon-thesis.pdf">aturon&rsquo;s thesis</a>
uses this style.)</p></li>
<li><p><a href="https://edwardtufte.github.io/tufte-css/">tufte-css</a> is pretty cool, if you&rsquo;re working in the realm of
writing HTML and want to just plug in a style sheet and go.</p></li>
</ul>


<p>(I&rsquo;m sure the hardcore Tufte fans in the audience are now saying &ldquo;How
can you claim to want to emulate Tufte&rsquo;s work in a post that uses a
bulleted list!?!&rdquo; I think there remains a time and place for a
bulleted list; this digression continues <a href="#on-bulleted-lists">below</a>.)</p>

<ul>
<li><p>What if you&rsquo;re trying to work with a blog system like
Octopress?</p>

<p>Well, you&rsquo;re actually in luck; other people have already done the
work of adapting the style rules in <a href="https://edwardtufte.github.io/tufte-css/">tufte-css</a> to Jekyll (the
infrastructure that Octopress is built upon), yielding
<a href="http://clayh53.github.io/tufte-jekyll/articles/15/tufte-style-jekyll-blog">tufte-jekyll</a>.</p></li>
</ul>


<p>After skimming over the presentation over at <a href="http://clayh53.github.io/tufte-jekyll/articles/15/tufte-style-jekyll-blog">tufte-jekyll</a> and
suffering with recurrent Octopress issues, I briefly considered
<span style="white-space: nowrap"><code>rm -rf</code>&lsquo;ing</span> Octopress from my blog system and adopting Jekyll directly.
(Which isn&rsquo;t as big a deal as it sounds, since Octopress is built on
top of Jekyll and so in principle I would get to reuse much of my
previous customizations.)</p>

<p>But the reality is that I do not really want to spend that much time on this;
having a presentation that matches every aspect of <a href="http://clayh53.github.io/tufte-jekyll/articles/15/tufte-style-jekyll-blog">tufte-jekyll</a> is not
currently that important to me. (At least, not yet.)</p>

<p>What I really wanted was to cherry-pick certain aspects that I find
important.</p>

<p>In particular, I <em>really</em> want sidenotes (and margin notes/figures),
and an option for full width figures. I&rsquo;ll discuss each in turn.</p>

<p>Luckily for me, the presentation of <a href="http://clayh53.github.io/tufte-jekyll/articles/15/tufte-style-jekyll-blog">tufte-jekyll</a> is itself
somewhat dedicated to spelling out how each feature was added.  In
other words, it seems <em>perfect</em> to use as the basis for such
cherry-picking.</p>

<p>Pretty much all of the things I wanted were implemented in
<a href="http://clayh53.github.io/tufte-jekyll/articles/15/tufte-style-jekyll-blog">tufte-jekyll</a> via Jekyll Plugins. Let&rsquo;s go through them one by one,
largely just to prove to myself that it is all working as I expect,</p>

<p>(In actual practice, what this actually meant is that iteratively
fixed my CSS and/or made my own variants of the plugins until this
text rendered as a postable demonstration).</p>

<p>(The presentation below makes claims about how each construct is
written in the source markdown; however, each case is assuming that
one has installed the appropriate Jekyll plugins and SCSS support
files)</p>

<a name="Side.Notes"></a>
<h2>Side Notes</h2>

<p>My previous blog posts<label for='previous-blog-posts' class='margin-toggle sidenote-number'></label><input type='checkbox' id='previous-blog-posts' class='margin-toggle'/><span class='sidenote'>Hey, a sidenote! One post that can/will benefit from these is my earlier <a href="blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work/">GC and Rust Part 0</a>. </span>
sometimes hacked in ad-hoc footnotes. But footnotes on the web are
super awkward because I am never quite sure how far down into the post
to collect the footnotes together.  Furthermore, I dislike how my
ad-hoc footnotes would disrupt the flow of the text if they were not
placed at the bottom of the (potentially very long) post; but if they
were all collected at the bottom, then navigating the page becomes
unwieldy at best.</p>

<p>Side notes do not suffer from either of these problems.</p>

<p>Side note support (and margin content in general) <em>does</em> come at the
cost of potentially introducing a large unused space on the right-hand
side of the presentation.</p>

<p>But the CSS magic here is smart enough to only try to grab the space
if it can afford to do so; if you are viewing this on a narrow
device,<label for='thin-browser' class='margin-toggle sidenote-number'></label><input type='checkbox' id='thin-browser' class='margin-toggle'/><span class='sidenote'>Or make your browser window sufficiently thin relative to its font size. </span>
the superscript indicating the presence of an associated side note
turns into a toggle switch for the associated content (now presented <em>inline</em>
with the text when toggled on).</p>

<p>One writes a sidenote with the following liquid tag syntax:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>main content{% sidenote 'unique-id' 'side content' %}</span></code></pre></td></tr></table></div></figure>


<p>which renders as:
main content<label for='unique-id' class='margin-toggle sidenote-number'></label><input type='checkbox' id='unique-id' class='margin-toggle'/><span class='sidenote'>side content </span></p>

<a name="Margin.Notes"></a>
<h2>Margin Notes</h2>

<p>Sometimes even the superscripted number that a sidenote carries is
disruptive, and unnecessary if:</p>

<ol>
<li><p>the content is lined up nicely, and</p></li>
<li><p>the presentation width for the main column is sufficiently wide.</p></li>
</ol>


<p>In other words: Why not drop the superscript?
<label for='inherited-from-foonotes' class='margin-toggle'> &#8853;</label><input type='checkbox' id='inherited-from-foonotes' class='margin-toggle'/><span class='marginnote'>This is a margin note <em>without</em> a superscript. The superscripts on sidenotes are a holdover from the world of footnotes. </span></p>

<p>That&rsquo;s what marginnotes are for.</p>

<p>But again, one wants to handle the case where the rendering area is
too narrow to set aside a margin. If your make the window narrow, you
will see that a margin note is replaced with an
inline symbol<label for='checkplus' class='margin-toggle sidenote-number'></label><input type='checkbox' id='checkplus' class='margin-toggle'/><span class='sidenote'>Since there is no number associated with a margin note, the symbol is a plus sign with a circle around it; I think it is this: &ldquo;&#x2295;&rdquo; U+2295 (aka &ldquo;CIRCLED PLUS&rdquo;) </span>
that will provide the reader with a way to toggle the presentation
of the elided content on and off, the same way that the superscript
acted as a toggle for a sidenote above.</p>

<p>Anyway, the code for <code>marginnote</code> is entirely analogous to that for <code>sidenote</code>.
One writes a margin note with the following liquid tag syntax:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>main content{% marginnote 'uniq-id' 'margin content' %}</span></code></pre></td></tr></table></div></figure>


<p>which renders as:
main content<label for='uniq-id' class='margin-toggle'> &#8853;</label><input type='checkbox' id='uniq-id' class='margin-toggle'/><span class='marginnote'>margin content </span></p>

<a name="Margin.Figures"></a>
<h2>Margin Figures</h2>

<p>Another topic I have touched on (and plan to do more with soon) is
drawing diagrams of graph structures. This usually involves SVG in
some manner.
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
     id="demo_svg_defs" height="0" viewBox="0 0 32 32">
<defs>
<pattern id="grid_cell" width=10 height=10 patternUnits="userSpaceOnUse">
<path d="M 0,0 v10 h10" fill="none" stroke="#aaa" stroke-width=1/>
</pattern>
<pattern id="grid" width=100 height=100 patternUnits="userSpaceOnUse">
<path d="M 0,0 v100 h100 v-100 z" stroke="#555" stroke-width=1 fill="url(#grid_cell)"/>
</pattern>
<g id="the_pic">
<rect x=0 y=0 width="100%" height="100%" fill="url(#grid)"/>
<circle cx=20 cy=20 r=10 stroke="green" fill="none"/>
<path d="M 80,30 C 90,20 30,20 10,40" stroke="blue" fill="none"/>
</g>
</defs>
</svg></p>

<p>Here is a relatively simple bit of SVG:</p>

<p><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
     id="demo_svg_main" height="50" width="100%">
<use xlink:href="#the_pic"/>
</svg></p>

<!-- If you're looking at this source code, then you can see that the
     actual content definitions are above, in the SVG group (`g`)
     element identified by `the_pic` -->


<p>I want to be able to present such diagrams in the same manner that
<code>tufte-css</code> and <code>tufte-jekyll</code> presents margin figures, full-width
figures, and column width figures.</p>

<p>However, <code>tufte-jekyll</code> assumes in its plugin for these features that
whatever figure you want to present is held in a separate file.</p>

<p><label for='svg-margin-figure' class='margin-toggle'>&#8853;</label><input type='checkbox' id='svg-margin-figure' class='margin-toggle'/><span class='marginnote'>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
     id="demo_svg_margin" height="50" width="100%">
<use xlink:href="#the_pic"/>
</svg>
Here is a margin figure; it shows a circle and a cubic bezier curve
(along with helpful grid lines, which I need to figure out how to
adjust the coordinates in the source SVG).
</span></p>

<p>I resolved this by hacking the <code>margin_figure.rb</code> plugin so that it
extends from <code>Liquid::Block</code> instead of <code>Liquid::Tag</code>, and then
hacking the implementation of the plugin until it started producing
the output I expect. By the time I finished, I had something
with a totally different feature-set and interface; so I renamed
this version of the plugin to <code>marginblock</code>.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
Actually, I think all of the side- and margin-content extensions
discussed here have the same limitation that they only work with
inline elements.
</span></p>

<p>Important Caveat: this hacked <code>marginblock</code> plugin can only handle
inline elements.</p>

<p><label for='demo-code-in-margin' class='margin-toggle'>&#8853;</label><input type='checkbox' id='demo-code-in-margin' class='margin-toggle'/><span class='marginnote'>
<code>&lt;code&gt;styling&lt;/code&gt;</code> does work (via HTML or Markdown backticks), but
fenced code blocks do not, because they generate <code>figure</code> and <code>table</code>
elements.
</span></p>

<ol>
<li><p>HTML code for certain elements (like
 <nobr><code>figure</code>,</nobr> <nobr><code>p</code>,</nobr> <nobr><code>pre</code>,</nobr> or
 <code>table</code> elements) will fragment the content, with some initial
 portion in the margin, and the remainder injected into the main
 text.</p></li>
<li><p>Markdown syntax that generates block-level elements has the
 same problem as HTML block-level elements.</p>

<p> For example, content after an empty line will be converted into
 a <code>p</code> element (and those will end up injected back into the main
 text).</p></li>
</ol>


<p>In other words: any markdown syntax inside a <code>marginblock</code>, including just an empty line
separating two blocks of text, will just confuse things.</p>

<p>So, don&rsquo;t do that.</p>

<p>To write a margin block, use the following syntax:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{% marginblock %}
</span><span class='line'>Margin block content, with no line breaks (see caveat above).
</span><span class='line'>{% endmarginblock %}</span></code></pre></td></tr></table></div></figure>


<a name="Full.Width.Figures"></a>
<h2>Full Width Figures</h2>

<p>You might have noticed that in the SVG diagram <a
href="#demo_svg_main">above</a>, the diagram only spans the width of
the &ldquo;main text&rdquo;, while the code block spans the full extent of the
page, flowing into the margin area.</p>

<p>I have hacked the CSS so that all of the figures for code are given
the full width of the page (otherwise, they always overflowed the
available space, yielding unfortunate scroll bars).</p>

<p>Still, it might well be that some SVG diagrams will likewise need the
full width of the page.
<code>tufte-jekyll</code> provides a plugin for this (called <code>fullwidth</code>), but
much like with its <code>marginfigure</code> plugin,
the <code>fullwidth</code> plugin assumes that
the content to be rendered lives in a separate file. Analogously to
how I dealt with that by making my own version of plugin,
<code>margin_block</code>, I have here made my own <code>fullwidth_figure</code> plugin.</p>

<p>Here is that circle and bezier curve again, this time spanning
the full width of the page:</p>

<p><figure class='fullwidth'>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
     id="demo_svg_main" height="50" width="100%">
<use xlink:href="#the_pic"/>
</svg>
</figure></p>

<p>So, all you need to do is write:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{% fullwidthfigure %}
</span><span class='line'>The lines of fullwidth figure content will extend across the full
</span><span class='line'>width of the page before line wrapping. (Some block elements will end
</span><span class='line'>up being mishandled, so don't use elements like `p` or `ul`, et
</span><span class='line'>cetera, or Markdown that generates them.)
</span><span class='line'>As the name implies, this is nested within a `figure` element;
</span><span class='line'>that means, for example, you can use `figcaption` to add a caption:
</span><span class='line'>&lt;figcaption&gt;Caption for `fullwidthfigure` demo&lt;/figcaption&gt;
</span><span class='line'>{% endfullwidthfigure %}</span></code></pre></td></tr></table></div></figure>


<p>which renders as:
<figure class='fullwidth'>
The lines of fullwidth figure content will extend across the full
width of the page before line wrapping. (Some block elements will end
up being mishandled, so don&rsquo;t use elements like <code>p</code> or <code>ul</code>, et
cetera, or Markdown that generates them.)
As the name implies, this is nested within a <code>figure</code> element;
that means, for example, you can use <code>figcaption</code> to add a caption:
<figcaption>Caption for <code>fullwidthfigure</code> demo</figcaption>
</figure></p>

<a name="Drawbacks..Rendering.Bugs.and.or.Gotcha.s"></a>
<h2>Drawbacks, Rendering Bugs and/or Gotcha&rsquo;s</h2>

<p>Originally I had a whole section here decrying the fact that I could
not put <em>any</em> line breaks into the source for a <code>sidenote</code> or
<code>marginnote</code>, since the Liquid tag parser requires the entirety of a
tag be contained on one line.</p>

<p>But then I hacked up <code>marginblock</code> (described above), and my problem
just goes away
<label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
Well, it goes away for superscript-free margin notes, at least.
If I ever feel the need to write a long side note, then I guess
I&rsquo;ll make a <code>sideblock</code> plugin at that time.
</span></p>

<p>Besides, maybe discouraging me from writing
long side notes<label for='dfw' class='margin-toggle sidenote-number'></label><input type='checkbox' id='dfw' class='margin-toggle'/><span class='sidenote'>I am pretty sure <a href="https://en.wikipedia.org/wiki/Infinite_Jest">Infinite Jest</a> would not work so well as a blog post. </span>
is not such a bad thing.</p>

<ul>
<li><p>Oh, by the way, it looks like you cannot throw side notes just
<em>anywhere</em><label for='bullet-test' class='margin-toggle sidenote-number'></label><input type='checkbox' id='bullet-test' class='margin-toggle'/><span class='sidenote'>Like, say, a bulleted list; further discussion in the <a href="#on-bulleted-lists">On Bulleted Lists</a> section. </span>
and expect them to play nice with the other marked up text.</p>

<p>For example, it may appear at a inconsistently inset margin&hellip; or worse&hellip;</p></li>
<li><p>Markup in a surrounding context is handled <em>somewhat<label for='emph-test' class='margin-toggle sidenote-number'></label><input type='checkbox' id='emph-test' class='margin-toggle'/><span class='sidenote'>This is relatively fine, even though it was not written with emphasis. </span> poorly</em>,
in that it may inherit the style of the surrounding markup it was embedded within</p></li>
<li><p>And some contexts, like code markup,<label for='code-test' class='margin-toggle'> &#8853;</label><input type='checkbox' id='code-test' class='margin-toggle'/><span class='marginnote'>Yeah, that raw HTML you see there is due to some bad interaction between the Jekyll sidenote plugin code and the markdown pre-processor. </span>
are handled <em>especially poorly</em>.
<code>
As in `not&lt;label for='code-test' class='margin-toggle sidenote-number'&gt;&lt;/label&gt;&lt;input type='checkbox' id='code-test' class='margin-toggle'/&gt;&lt;span class='sidenote'&gt;This is not fine &lt;/span&gt; good.
</code></p></li>
</ul>


<a name="L.a.id..on-bulleted-lists....a.On.Bulleted.Lists"></a>
<h2><a id="on-bulleted-lists"></a>On Bulleted Lists</h2>

<p>Speaking of bulleted lists: I implied up above that Tufte has a
problem with the use of bulleted lists, and that this is why the
standard <a href="https://edwardtufte.github.io/tufte-css/">tufte-css</a> does away with
them.<label for='is-ul-really-gone' class='margin-toggle sidenote-number'></label><input type='checkbox' id='is-ul-really-gone' class='margin-toggle'/><span class='sidenote'>Or rather, it does away with the bullet sigils, not unordered lists themselves. </span></p>

<p>If you are curious about Tufte&rsquo;s argument against the use of bulleted
lists, I highly recommend you pick up his essay
<a href="http://www.edwardtufte.com/tufte/books_pp">&ldquo;The Cognitive Style of PowerPoint&rdquo;</a>,<label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
Your local library is more likely to carry &ldquo;Beautiful Evidence&rdquo;
than the PowerPoint essay on its own (which one might deem a pamphlet).
Alternatively, you can also
<a href="http://www.edwardtufte.com/tufte/ebooks">purchase</a>
the Powerpoint essay as a PDF-format e-book on Tufte&rsquo;s website.
</span>
(which you can acquire on its own, or can be found as a chapter of his book
<a href="http://www.edwardtufte.com/tufte/books_be">&ldquo;Beautiful Evidence&rdquo;</a>).</p>

<p>For me, when writing markdown, the visible bullets serve a purpose.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
According to some conventions, my argument here is a strawman,
because I have already failed by putting more than six words on a
single bullet (&ldquo;any more words per bullet, and you don&rsquo;t have a
bullet.&rdquo;). I do not really have an argument against that,
(except that Tufte himself seems to lambast such rules of thumb).
</span></p>

<ul>
<li><p>In particular, I sometimes attach more than one paragraph of text
to an item in an unordered list.</p></li>
<li><p>But if I associate more than one paragraph of text with an item on
such a list, then without the visible bullet, one cannot readily
tell whether the new paragraph has started a new item, &hellip;</p>

<p>&hellip; or if it is a continuation of the previous item.</p></li>
<li><p>Then again, since the standard Octopress format does not indent
unordered lists, the same problem arises unless one
customizes<label for='scss-indented-list' class='margin-toggle sidenote-number'></label><input type='checkbox' id='scss-indented-list' class='margin-toggle'/><span class='sidenote'>See the <code>$indented-lists</code> variable in <code>_layout.scss</code> </span>
its SCSS to turn it on. (I tried this, but it ends up being more
trouble than its worth in terms of it breaking other things in the
CSS implementing this main-and-margin presentation.)</p></li>
<li><p>Have you noticed that the indentation of the margin notes
that are attached to list-elements are a little screwy?</p>

<ul>
<li><p>This is because of how the CSS is implemented; the main content elements
(like <code>p</code>, <code>ul</code>, et cetera) are all assigned <code>width: 60%</code>,
so that the remaining 40% is available for the margin content,
which is then assigned <code>margin-right: -40%</code> in the CSS.</p></li>
<li><p>The problem, as far as I can tell, is that the <code>-40%</code> is computed
relative to the width of the parent element.<label for='relative-margins-and-list-indents' class='margin-toggle sidenote-number'></label><input type='checkbox' id='relative-margins-and-list-indents' class='margin-toggle'/><span class='sidenote'>When list content gets indented, the width of a list element is less than that of paragraphs in the main text, and so its computed <code>margin-right: -40%</code> is a bit smaller than that for other margin content, causing a slight (but annoyingly noticeable) difference. </span></p></li>
<li><p>(Update: For that matter, the <em>width</em> of the text in nested list elements,
 like this one, does not play well with the margin content; the text
 of the list element in the main column is creeping into the margin.)</p></li>
<li><p>I have spent some time trying to puzzle this out, but at this point
I am willing to just say &ldquo;avoid attaching margin content to list
elements.&rdquo;</p></li>
</ul>
</li>
</ul>


<p>I <em>am</em> trying to learn how to make my blog posts more stream of thought
(for quick generation and publication), rather than carefully crafted
pieces of art. The bulleted list approach certainly provides a
quick-and-dirty way to do that.<label for='long-text' class='margin-toggle sidenote-number'></label><input type='checkbox' id='long-text' class='margin-toggle'/><span class='sidenote'>Speaking of quick-and-dirty, here is some really long text because I want to see what happens to the horizontal rule that divides the two parts of the main text below. At first different browsers handled the rendering in different ways; but now I have customized my SCSS so that <code>hr</code> has the same <code>width</code> constraint as a <code>p</code> element. </span></p>

<p>Update: a draft verison of this blog post had an <code>hr</code>-element between the
previous paragraph and this point in the text. Then shortly before publication,
I changed the <code>hr</code>-element to a new section heading, and didn&rsquo;t notice that
the fix I had put into the CSS to make the span of <code>hr</code>-element shorter
did not apply to the dotted line being rendered above the section header.</p>

<hr />

<p>So, now (post publication) I have put back in an <code>hr</code>-element at roughly the point
I expect it in the text.</p>

<a name="How.d.He.Do.Dat."></a>
<h2>How&rsquo;d He Do Dat?</h2>

<p>So how did I do all this?</p>

<p>I started by copying the <a href="http://clayh53.github.io/tufte-jekyll/articles/15/tufte-style-jekyll-blog">tufte-jekyll</a> plugins and SCSS support
files into my blog source tree. Since I use Octopress, I had to move
things around a bit:</p>

<ol>
<li><p>The <code>tufte.scss</code> that you find in tufte-jekyll&rsquo;s <code>css/</code>
needs to go somewhere; I put a copy of it into <code>sass/custom</code>.</p>

<p>Then I made a copy of the copy and named it <code>_fsk_tufte.scss</code><label for='on-renaming' class='margin-toggle'> &#8853;</label><input type='checkbox' id='on-renaming' class='margin-toggle'/><span class='marginnote'>In truth, the renamed copy came later, but it is good practice and simplifies the current discussion to assume I did it at the outset. </span></p></li>
<li><p>After putting the <code>.scss</code> files into place, I had to actually load the
main one into the Jekyll&rsquo;s page generation system. That is accomplished
via an <code>@import</code> in <code>sass/custom/_styles.scss</code>:</p>

<pre><code>@import "fsk_tufte";
</code></pre></li>
<li><p>Running the <code>rake generate</code> task to generate the CSS and the pages showed that
there were references to undefined variables like <code>$constrast-color</code>.
I skimmed through <code>fsk_tufte.scss</code> and either removed such references
or figured out where those variables were defined in the original
tufte-jekyll source repository, and ported them over accordingly.
For example, <code>$contrast-color</code> was defined in <code>_sass/_settings.scss</code>;
I cut-and-pasted it into <code>sass/custom/_color.scss</code>.</p></li>
<li><p>I initially copied all of the plugins from tufte-jekyll&rsquo;s
<code>_plugins/</code> into my <code>plugins/</code>.</p></li>
<li><p>Even after doing this, a lot of things were broken. I spent a <em>long</em>
time with a web browser&rsquo;s &ldquo;Inspect Element&rdquo; tool, comparing how
the tufte-jekyll post was being rendered to how my own draft blog
post was rendered.</p>

<p>Over the course of doing this, I found it necessary to revise my
<code>_fsk_tufte.scss</code> in myriad ways.</p></li>
</ol>


<a name="Revisions.to._fsk_tufte.scss"></a>
<h3>Revisions to _fsk_tufte.scss</h3>

<ol>
<li><p>I removed any content that I hypothesized was not related to my
margin-rendering related goals. For example, <code>tufte.scss</code>
automatically increases the font size as the browser window
width increases. I find this distracting as a programmer (and
annoying as a reader), so I removed it.</p></li>
<li><p>I changed the footnote font-size selection strategy.</p>

<ul>
<li><p>Tufte-jekyll&rsquo;s strategy is to use <code>1.0rem</code><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
&ldquo;rem&rdquo; stands for &ldquo;root em&rdquo; which in turn means &ldquo;unit equal to the
height of a capital M in the root (i.e. <code>html</code>) element of the document&rdquo;
</span>
as the <code>font-size</code> for the margin text and then scaling up the font-size
for the main content to be <code>1.4rem</code> (so that the main text ends up 1.4x
the size of the margin text).</p></li>
<li><p>I instead used <code>font-size: 0.8rem;</code> for margin text, and leave the
font-size for the main text unchanged (so that in principle it will
remain at <code>1rem</code>).</p></li>
<li><p>My reasoning here is that the majority of the text should be
occurring in the main content area, and we should be respecting
the font settings chosen by the user in their browser for such
text. If the user has selected a font size of 14, then that is
what we should use for the main text; we should not be using 14
for the margin notes and scale the main text up to 1.4*14 (=
19.6).</p></li>
</ul>
</li>
<li><p>After I noticed that my main-and-margin presentation style was
begin applied even to things like the <em>sidebar</em> of the blog,
I added guards to all of the relevant parts of <code>_fsk_tufte.scss</code>
so that the main-and-margin styling <em>only</em> applies to elements
that occur within an <code>article</code> element (since the main content
blocks always fall under an article).</p>

<p>Those were rules like this:</p>

<pre><code>// If a `ul`/`ol` occurs *immediately* (&gt;) under an `article`
article &gt; ul, article &gt; ol {
    width: 60%
}
</code></pre>

<p>I also added customization to try to avoid double-applications of
the percentage-based width restrictions; for example, I added
a rule like:</p>

<pre><code>p, ul, ol { p, ul, ol: width: 100 }
</code></pre>

<p>Update: Then I discovered that:</p>

<ol>
<li><p>this rule was not necessary for the cases where I had originally needed it,</p></li>
<li><p>it is not actually being applied since it is overridden by other rules
 (presumably due to some resolution logic for CSS that I have not digested),
 and,</p></li>
<li><p>if you get it to apply, it has a negative overall effect on
 e.g. nested lists: it causes them to be assigned a width corresponding
 to main <em>plus</em> margin. (Clearly my mental model of what how these percentages
 relate to the parent element is flawed in various ways.)</p></li>
</ol>


<p>So I have since removed that last rule.</p></li>
</ol>


<p>Anyway, those are the main customizations of the SCSS that I can think
of off-hand. You can of course just go peek at <a href="https://github.com/pnkfelix/pnkfx-blog/">its source code</a>
if you want to see what it currently looks like (and perhaps offer
tips on how I might revise it).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GC and Rust Part 1: Specifying the Problem]]></title>
    <link href="http://blog.pnkfx.org/blog/2015/11/10/gc-and-rust-part-1-specing-the-problem/"/>
    <updated>2015-11-10T17:45:00+01:00</updated>
    <id>http://blog.pnkfx.org/blog/2015/11/10/gc-and-rust-part-1-specing-the-problem</id>
    <content type="html"><![CDATA[<p>This is the first in a series of posts will discuss why garbage
collection is hard, especially for Rust, and brainstorm about
solutions to the problems we face.</p>

<p>The relationship between garbage collection (GC) and the Rust
programming language has been an interesting one.</p>

<p>GC was originally deeply integrated into the language, complete with
dedicated syntax (good old <code>@T</code> &hellip;). Over time the team found ways to
lessen the dependency on GC, and then finally remove it from the
language entirely.</p>

<p>However, we still want to provide support for garbage collection.</p>

<p>To explain why, I need to define the actual problems we seek to solve.
So let us explore the problem space.</p>

<!-- more -->


<a name="L.....now.you.have..nyh..two.problems"></a>
<h1>&hellip; <a href="http://regex.info/blog/2006-09-15/247">now you have</a> two problems</h1>

<p>(The body of this post makes heavy use of client-side rendering,
because of author idiosyncrasies.  You may need to wait a moment while
the supporting Javascript loads.)</p>

<script src="http://blog.pnkfx.org/javascripts/viz.js" charset="utf-8"></script>


<script src="http://blog.pnkfx.org/javascripts/js_to_dot.js" charset="utf-8"></script>


<script src="http://blog.pnkfx.org/javascripts/gc_rendering.js" charset="utf-8"></script>


<a name="The.Problem.Space"></a>
<h2>The Problem Space</h2>

<p>Now that we have <a href="http://blog.pnkfx.org/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work/">reviewed</a> what GC is and how it works, let us
discuss what GC could mean to Rust.</p>

<p>I have identified two distinct kinds of support that we could provide:
&ldquo;GC&rdquo; could describe a feature for pure Rust programs, or &ldquo;GC&rdquo; could mean a
3rd-party runtime interoperation feature. Let us discuss each in turn.</p>

<a name="One.GC.shared.by.every.crate"></a>
<h3>One GC shared by every crate</h3>

<p>We could add a smart-pointer to <code>libstd</code>, e.g. a <code>Gc&lt;T&gt;</code> type, that
arbitrary library crates could use as they create or receive instances
of <code>T</code>. The intention here would be similar to how <code>Rc&lt;T&gt;</code> is used:
One does not want to track ownership precisely, but rather treat
ownership as shared amongst all users of a value, and let the runtime
system handle reclaiming the value.</p>

<p>So for example, we might want to write code that looks like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kn">use</span> <span class="n">std</span><span class="o">::</span><span class="n">gc</span><span class="o">::</span><span class="n">Gc</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">Cons</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">head</span><span class="o">:</span> <span class="n">T</span><span class="p">,</span>
</span><span class='line'>    <span class="n">tail</span><span class="o">:</span> <span class="n">Cell</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Gc</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Cons</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fn</span> <span class="n">new</span><span class="p">(</span><span class="n">head</span><span class="o">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">tail</span><span class="o">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Gc</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Cons</span> <span class="p">{</span> <span class="n">head</span><span class="o">:</span> <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="o">:</span> <span class="n">Cell</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">fn</span> <span class="n">head</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span> <span class="p">{</span> <span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">head</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">fn</span> <span class="n">tail</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Gc</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;&gt;</span> <span class="p">{</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#[test]</span>
</span><span class='line'><span class="k">fn</span> <span class="n">demo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">f</span><span class="o">:</span> <span class="n">Gc</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">;</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>            <span class="n">a</span> <span class="o">=</span> <span class="k">box</span> <span class="n">Cons</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">None</span><span class="p">);</span>
</span><span class='line'>        <span class="kd">let</span> <span class="n">b</span> <span class="o">=</span> <span class="k">box</span> <span class="n">Cons</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">Some</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
</span><span class='line'>        <span class="kd">let</span> <span class="n">c</span> <span class="o">=</span> <span class="k">box</span> <span class="n">Cons</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">Some</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
</span><span class='line'>        <span class="kd">let</span> <span class="n">d</span> <span class="o">=</span> <span class="k">box</span> <span class="n">Cons</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nb">Some</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
</span><span class='line'>        <span class="kd">let</span> <span class="n">e</span><span class="o">:</span> <span class="n">Gc</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">;</span>
</span><span class='line'>            <span class="n">e</span> <span class="o">=</span> <span class="k">box</span> <span class="n">Cons</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">Some</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
</span><span class='line'>            <span class="n">f</span> <span class="o">=</span> <span class="k">box</span> <span class="n">Cons</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">Some</span><span class="p">(</span><span class="n">d</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>        <span class="kd">let</span> <span class="k">mut</span> <span class="n">g</span> <span class="o">=</span> <span class="k">box</span> <span class="n">Cons</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">None</span><span class="p">);</span>
</span><span class='line'>        <span class="kd">let</span>     <span class="n">h</span> <span class="o">=</span> <span class="k">box</span> <span class="n">Cons</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="nb">Some</span><span class="p">(</span><span class="n">g</span><span class="p">));</span>
</span><span class='line'>        <span class="n">g</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">h</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">// here, locals `a` and `f` are the roots</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>(The above snippet assumes we have extended <code>box EXPR</code> to an
overloaded operator in the manner similar to that described in
<a href="https://github.com/rust-lang/rfcs/blob/master/text/0809-box-and-in-for-stdlib.md">RFC 809</a>, so that <code>let g: Gc&lt;_&gt; = box EXPR;</code> works, and that
the type inference figures out that all the locals need to be
in <code>Gc&lt;_&gt;</code>.)</p>

<p>This results in a stack and heap modelled by this picture.</p>

<p id="target_anchor_gc_demo_1" class="fullwidth"></p>


<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };
var a = object_record("A", "<head> head: 1 | <tail> tail: None");
var b = object_record("B", "<head> head: 2 | <tail> tail: Some(A)");
var c = object_record("C", "<head> head: 3 | <tail> tail: Some(A)");
var d = object_record("D", "<head> head: 4 | <tail> tail: Some(B)");
var e = object_record("E", "<head> head: A | <tail> tail: Some(B)");
var f = object_record("F", "<head> head: C | <tail> tail: Some(D)");
var g = object_record("G", "<head> head: 10 | <tail> tail: Some(H)");
var h = object_record("H", "<head> head: 20 | <tail> tail: Some(G)");

var local_a = { id: "local_a", label: "a", shape: "record" };
var local_f = { id: "local_f", label: "f", shape: "record" };

stack[1] = local_a;
stack[2] = local_f;

b.tail = edge_from_port(":tail", a);
c.tail = edge_from_port(":tail", a);
d.tail = edge_from_to_ports(":tail", ":id", b);
e.head = edge_from_port(":head", a);
e.tail = edge_from_to_ports(":tail", ":id", b);
f.head = edge_from_to_ports(":head", ":id", c);
f.tail = edge_from_to_ports(":tail", ":id", d);
g.tail = edge_from_to_ports(":tail", ":id", h);
h.tail = edge_from_to_ports(":tail", ":id", g);

local_a.ref = a;
local_f.ref = edge_to_port(":id", f);

gc_heap[0] = a;
gc_heap[1] = b;
gc_heap[2] = c;
gc_heap[3] = d;
gc_heap[4] = e;
gc_heap[5] = f;
gc_heap[6] = g;
gc_heap[7] = h;

var objects = [stack, gc_heap];
post_objects("target_anchor_gc_demo_1", objects, { rankdir:"LR", nodesep:0.2, no_dims:true });
</script>


<p>The GC would be allowed to collect the objects labelled &ldquo;E&rdquo;, &ldquo;G&rdquo;, and
&ldquo;H&rdquo; in the picture, since they are not reachable from the roots.
(However, the GC is not obligated to reclaim them at any particular
time. Usually GC&rsquo;s provide little guarantees about how soon objects
will be reclaimed.)</p>

<p>This kind of feature could be useful in any Rust library.</p>

<a name="Advantages.of.Gc.T..over.Rc.T."></a>
<h4>Advantages of Gc<T> over Rc<T></h4>

<p>The main hypothesized advantages over <code>Gc&lt;T&gt;</code> over <code>Rc&lt;T&gt;</code> are:</p>

<ul>
<li><p><code>Gc&lt;T&gt;</code> is <code>Copy</code>, which makes it possible to construct types like
<code>Cell&lt;Gc&lt;T&gt;&gt;</code>.</p>

<p>(It also has nicer programmer ergonomics in some cases; e.g. some
programmers dislike having to write <code>x.clone()</code> every time they
want to make a copy of ref-counted <code>x</code>.)</p></li>
<li><p><code>Gc&lt;T&gt;</code> allows cyclic structure to be reclaimed (e.g. the objects
 &ldquo;G&rdquo; and &ldquo;H&rdquo; in the picture above.</p></li>
<li><p>Using <code>Gc&lt;T&gt;</code> <em>might</em> have less overhead than <code>Rc&lt;T&gt;</code>: every time
you clone an <code>Rc&lt;T&gt;</code> it incurs reference-count overhead, while
<code>Gc&lt;T&gt;</code> just copies the reference.</p>

<p>(However, this stated advantage must be tempered by the
realization that GC incurs its own separate overheads, as
discussed in the <a href="http://blog.pnkfx.org/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work/">background post</a>.</p></li>
</ul>


<a name="Drawbacks.of.one.GC.for.everyone"></a>
<h4>Drawbacks of one GC for everyone</h4>

<p>There are two immediate drawbacks with this kind of collector
support.</p>

<p>First, adding it would require that the standard library either
provide a garbage collector (that all clients of <code>Gc&lt;T&gt;</code> would have to
link in), or at least standardize a fixed API that third-party
collector implementations would have to satisfy to support <code>Gc&lt;T&gt;</code>.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
In particular, smart-pointers in Rust
require at <em>least</em> support for the <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code> trait</a>, so
that dereferencing expressions like <code>gc_ref.field</code> and
<code>gc_ref.method()</code> are compiled into code that resolves the <code>gc_ref</code> to
a<code>&amp;T</code> reference (and then the subsequent field or method lookup is
performed with respect to that <code>&amp;T</code> reference).
<br></br>
As a reminder, the signature of the <code>deref</code> method, before lifetime
elision, is <code>fn deref&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a Self::Target</code> (and the
associated <code>Target</code> type for <code>Gc&lt;T&gt;</code> would be <code>T</code>).  Thus, the
compiler will ensure that the reference <code>&amp;'a T</code> we extract from the
<code>gc_ref</code> outlive the <code>gc_ref</code> itself; this means that the <code>gc_ref</code>
will be one (of potentially many) root keeping the object from being
reclaimed for the entirety of the lifetime <code>'a</code>, and thus supporting
the <code>Deref</code> trait design on a <code>Gc&lt;T&gt;</code> could work seamlessly on an
entirely non-moving GC.
<br></br>
However, moving objects complicate <code>Deref</code> support; now one needs to
ensure not only that the object remains alive, but also that the
reference <code>&amp;'a T</code> consistently points to the same object that the
original <code>Gc&lt;T&gt;</code> pointed to, and that references to substructure
within the object (e.g. a <code>&amp;Left</code> within a <code>Gc&lt;(Left, Right)&gt;</code> that
has been deref'ed to <code>&amp;(Left, Right)</code>) also retain a consistent view
of the heap structure. Doing this at an acceptable cost is difficult;
I may discuss this more in a future post.
</span>
Second, it is difficult to provide the ergonomics that one expects
from a smart-pointer type analogous to
<code>Rc&lt;T&gt;</code>.</p>

<p>Okay, so that&rsquo;s the outline of the tradeoffs of providing
a &ldquo;GC for everyone&rdquo; in <code>libstd</code>.  What about a more limited
GC feature, where the audience is not &ldquo;every Rust crate&rdquo;, but instead
just the crates linking to a managed runtime.</p>

<a name="GC.as.Interoperation.Feature"></a>
<h3>GC as Interoperation Feature</h3>

<p>GC as an interoperation feature means that Rust would provide
introspective hooks to improve integration with application frameworks
that are using their own garbage collector. One example of this is
Servo&rsquo;s use of the SpiderMonkey Virtual Machine for its Javascript
support.</p>

<p>Servo is relying on SpiderMonkey&rsquo;s garbage collection for memory
management, not only for Javascript values, but even for
<a href="https://blog.mozilla.org/research/2014/08/26/javascript-servos-only-garbage-collector/">native-code DOM objects</a>.</p>

<p>That post describes (unchecked) scenarios where one can end up with
dangling pointers &ndash; that is, they invite unsoundness.  Proper support
for GC-interoperation in Rust could address this; I will discuss this
further down in this post.</p>

<p>Critically, GC-interoperation does not require the same level of
ergonomics that <code>Rc&lt;T&gt;</code> provides. For example, in this context it is
acceptable for <code>Gc&lt;T&gt;</code> to not support <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a>.</p>

<p>(Furthermore, in this context, it may even be acceptable to require
unchecked constraints like &ldquo;the programmer must ensure the collector
is not invoked during this extent&rdquo;, or perhaps &ldquo;the programmer must
periodically invoke a call that tells the GC that this is an
acceptable time to do collection work that could move objects.&rdquo;)</p>

<p>Without a <code>Deref</code> trait and with such unchecked requriements, such
interoperation might end up looking something like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">double_last</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">Gc</span><span class="o">&lt;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">unsafe</span> <span class="p">{</span>
</span><span class='line'>        <span class="kd">let</span> <span class="n">ptr</span><span class="o">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">get_ptr</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// during the extent of this block, it is the responsibility</span>
</span><span class='line'>        <span class="c1">// of the double_last author to ensure the GC never gets</span>
</span><span class='line'>        <span class="c1">// invoked (i.e., do not do any allocations to the GC&#39;ed heap</span>
</span><span class='line'>        <span class="c1">// during this unsafe-block).</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="nb">Some</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">).</span><span class="n">last_mut</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>            <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>In this context, interoperation still requires defining a standard
interface that the third-party collector implementation has to conform
with.</p>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
In truth, even for a conservative collector like <a href="http://www.hboehm.info/gc/">BDW</a>,
one must do more than just &ldquo;swap in a new <code>#[allocator]</code>&rdquo; to actually
integrate it properly; the current Rust standard library does not
provide a way to intercept thread spawns and register the new
stack associated with each new thread.
<br></br>
I only realized this only <a href="https://github.com/swgillespie/boehm_gc_allocator/issues/2">recently</a>.
</span>
In a simple world (e.g., a conservative collector designed to
interoperate with C/C++, such as <a href="http://www.hboehm.info/gc/">boehm-demers-weiser</a> (BDW)), this
standard interface could be nothing more than just &ldquo;swap in a
different <a href="https://doc.rust-lang.org/nightly/book/custom-allocators.html">#[allocator] crate</a> that your GC provides.&rdquo;</p>

<p>(The actual interface is unlikely to be so
simple, but the point is, there is a wide
design space to be explored here.)</p>

<a name="Interoperation.with.a..black.box..GC"></a>
<h4>Interoperation with a &ldquo;black box&rdquo; GC</h4>

<p>One way to look at the difference between &ldquo;GC for pure Rust programs&rdquo;
versus &ldquo;GC for interoperation&rdquo; is that in the former case, the GC
feels deeply integrated with the language and standard library, while
in the latter case, the GC is clearly the concern of some entity
outside the language (and we are just trying to accommodate it as best
we can).</p>

<p>An extreme instance of a GC that is definitely an entity outside the
language is a case where the whole GC heap is treated like a black
box, and the objects inside the heap are never directly exposed to the
application code outside the box.</p>

<p>For example, one can imagine a virtual machine (VM) interface where
the code outside the VM is never given addresses of objects on the
heap. Instead, such foreign code only has <em>handles</em> that indirectly
point to those objects.</p>

<p id="target_anchor_black_box_gc_1" class="fullwidth"></p>


<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var rust_heap = { rankdir:"LR", id: "cluster_rust_heap", label: "Rust Heap", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };
var handles = object_record("handles", "<h2> Y | <h1> X | <h3> X");

var c = object_record("C", "<f0> Gc(X) | <f1> Box(O)");
c.style = "rounded";
var o = object_record("O", "<f0> Handle(2)");
var x = object_record("X", "<f0> 'a' | <f1> next");
var y = object_record("Y", "<f0> 'b' | <f1> next");
var z = object_record("Z", "<f0> 'c' | <f1> (next)");
x.style = "rounded";
y.style = "rounded";
z.style = "rounded";
var local_x = { id: "local_x", label: "handle_x", shape: "record" };
var local_y = { id: "local_y", label: "handle_y", shape: "record" };
var local_o = { id: "local_o", label: "boxed_o", shape: "record" };

x.next = edge_from_to_ports(":f1", ":id:sw", y);
y.next = edge_from_to_ports(":f1", ":id", z);

o.f0 = edge_from_to_ports(":f0", ":h3", handles);

c.f0 = edge_from_to_ports(":f0", ":id", x);
c.f1 = edge_from_to_ports(":f1", ":id", o);

stack[1] = local_x;
stack[2] = local_y;
stack[3] = local_o;

rust_heap[0] = o;
gc_heap[0] = handles;
handles.x1 = edge_from_to_ports(":h1", ":id", x);
handles.y2 = edge_from_to_ports(":h2", ":id", y);
handles.x3 = edge_from_to_ports(":h3", ":id:sw", x);
local_x.handle = edge_to_port(":h1", handles);
local_y.handle = edge_to_port(":h2", handles);
local_o.box = edge_to_port(":id", o);
gc_heap[2] = x;
gc_heap[3] = y;
gc_heap[4] = z;

var objects = [stack, gc_heap, rust_heap];
post_objects("target_anchor_black_box_gc_1", objects, { rankdir:"LR", nodesep:0.2, no_dims: true });
</script>


<p>In this setting, direct references to objects <em>never</em> escape the black
box. Instead, by setting up a level of indirection, the management of
the objects within the GC heap is completely abstracted away.</p>

<p>In a black box GC setting, one would not expose the data structure of
the objects (since they can never be directly addressed
anyway). Instead, one would define functions on handles that extract
the fields and maps them to handles when necessary:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">extern</span> <span class="k">fn</span> <span class="n">handle_data</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="n">Handle</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">char</span><span class="p">;</span>
</span><span class='line'><span class="k">extern</span> <span class="k">fn</span> <span class="n">handle_next</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="n">Handle</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Handle</span><span class="o">&gt;</span><span class="p">;</span>
</span><span class='line'><span class="k">extern</span> <span class="k">fn</span> <span class="n">handle_set_next</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="n">Handle</span><span class="p">,</span> <span class="n">b</span><span class="o">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Handle</span><span class="o">&gt;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// sample code interacting with the black box GC</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// all of these predicates hold of the above heap diagram</span>
</span><span class='line'><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">handle_data</span><span class="p">(</span><span class="n">handle_x</span><span class="p">),</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
</span><span class='line'><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">handle_data</span><span class="p">(</span><span class="n">handle_next</span><span class="p">(</span><span class="n">handle_y</span><span class="p">).</span><span class="n">unwrap</span><span class="p">()),</span> <span class="sc">&#39;c&#39;</span><span class="p">);</span>
</span><span class='line'><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">handle_next</span><span class="p">(</span><span class="n">handle_next</span><span class="p">(</span><span class="n">handle_y</span><span class="p">).</span><span class="n">unwrap</span><span class="p">()).</span><span class="n">is_none</span><span class="p">());</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// this changes the heap to match the diagram below.</span>
</span><span class='line'><span class="n">handle_set_next</span><span class="p">(</span><span class="n">handle_x</span><span class="p">,</span> <span class="n">handle_next</span><span class="p">(</span><span class="n">handle_y</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>




<p id="target_anchor_black_box_gc_2" class="fullwidth"></p>




<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var rust_heap = { rankdir:"LR", id: "cluster_rust_heap", label: "Rust Heap", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };
// var handles = object_record("handles", "<h2> Y | <h1> X | <h3> X | <h4> (temp for Z)");
var handles = object_record("handles", "<h2> Y | <h1> X | <h3> X");

var c = object_record("C", "<f0> Gc(X) | <f1> Box(O)");
c.style = "rounded";
var o = object_record("O", "<f0> Handle(2)");
var x = object_record("X", "<f0> 'a' | <f1> next");
var y = object_record("Y", "<f0> 'b' | <f1> next");
var z = object_record("Z", "<f0> 'c' | <f1> (next)");
x.style = "rounded";
y.style = "rounded";
z.style = "rounded";
var local_x = { id: "local_x", label: "handle_x", shape: "record" };
var local_y = { id: "local_y", label: "handle_y", shape: "record" };
var local_o = { id: "local_o", label: "boxed_o", shape: "record" };

x.next = edge_from_to_ports(":f1", ":id:w", z);
y.next = edge_from_to_ports(":f1", ":id:n", z);

o.f0 = edge_from_to_ports(":f0", ":h3", handles);

c.f0 = edge_from_to_ports(":f0", ":id", x);
c.f1 = edge_from_to_ports(":f1", ":id", o);

stack[1] = local_x;
stack[2] = local_y;
stack[3] = local_o;

rust_heap[0] = o;
gc_heap[0] = handles;
handles.x1 = edge_from_to_ports(":h1", ":id", x);
handles.y2 = edge_from_to_ports(":h2", ":id", y);
handles.x3 = edge_from_to_ports(":h3", ":id:sw", x);
// handles.z4 = edge_from_to_ports(":h4", ":id:sw", z);
local_x.handle = edge_to_port(":h1", handles);
local_y.handle = edge_to_port(":h2", handles);
local_o.box = edge_to_port(":id", o);
gc_heap[2] = x;
gc_heap[3] = y;
gc_heap[4] = z;

var objects = [stack, gc_heap, rust_heap];
post_objects("target_anchor_black_box_gc_2", objects, { rankdir:"LR", nodesep:0.2, no_dims: true });
</script>


<p>In case it isn&rsquo;t clear, supporting interoperation with this kind of
&ldquo;black box&rdquo; GC requires very little from the Rust side; potentially
nothing at all. The object addresses are hidden, so the GC could move
an object and update its address in the handle
array.<label for='handles' class='margin-toggle'> &#8853;</label><input type='checkbox' id='handles' class='margin-toggle'/><span class='marginnote'>If the GC Heap is exposed to multiple threads, then there are complications even with the seemingly simple task of updating the handles array, since one must ensure that if two threads have consistent views of the heap object graph. </span></p>

<p>However, this so-called interoperation is also quite limited in
expressiveness. The defining property of the &ldquo;black box&rdquo; GC, the fact
that it does not expose the addresses of the objects held within, also
means that we cannot expose <code>&amp;</code>-references to the objects or the state
within them, which means we cannot use these objects with the large
number of Rust functions that operate on <code>&amp;</code>-references and slices.</p>

<a name="Digression.on.limits.of..black.box..GC"></a>
<h3>Digression on limits of &ldquo;black box&rdquo; GC</h3>

<p>In addition to the limits regarding exposure of <code>&amp;</code>-references
described above, another issue with &ldquo;black box&rdquo; GC is that
it is not clear whether client code hooking
into the &ldquo;black box&rdquo; GC would be able to instantiate the GC objects
with its own types.</p>

<p>For example, one might think that the objects in the GC heap could be
defined via type parameterization: <code>fn bbox_gc_alloc&lt;T&gt;(t: T) -&gt; Handle;</code>
would create an object on the heap, copy <code>t</code> into it, and return a
handle to that object.</p>

<p>For this to work, the layout of the list cells in the GC heap above
would need to look something like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">struct</span> <span class="n">Cons</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">data</span><span class="o">:</span> <span class="n">T</span><span class="p">,</span>
</span><span class='line'>    <span class="n">next</span><span class="o">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">GcPtr</span><span class="o">&lt;</span><span class="n">Cons</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Then constructing a list like the &ldquo;X, Y, Z&rdquo; in the heap diagrams
above would look like:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kd">let</span> <span class="n">handle_z</span> <span class="o">=</span> <span class="n">bbox_gc_alloc</span><span class="p">(</span><span class="n">Cons</span> <span class="p">{</span> <span class="n">data</span><span class="o">:</span> <span class="sc">&#39;c&#39;</span><span class="p">,</span> <span class="n">next</span><span class="o">:</span> <span class="nb">None</span> <span class="p">});</span>
</span><span class='line'><span class="kd">let</span> <span class="n">handle_y</span> <span class="o">=</span> <span class="n">bbox_gc_alloc</span><span class="p">(</span><span class="n">Cons</span> <span class="p">{</span> <span class="n">data</span><span class="o">:</span> <span class="sc">&#39;b&#39;</span><span class="p">,</span> <span class="n">next</span><span class="o">:</span> <span class="nb">None</span> <span class="p">});</span>
</span><span class='line'><span class="kd">let</span> <span class="n">handle_x</span> <span class="o">=</span> <span class="n">bbox_gc_alloc</span><span class="p">(</span><span class="n">Cons</span> <span class="p">{</span> <span class="n">data</span><span class="o">:</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="n">next</span><span class="o">:</span> <span class="nb">None</span> <span class="p">});</span>
</span><span class='line'><span class="n">handle_set_next</span><span class="p">(</span><span class="n">handle_y</span><span class="p">,</span> <span class="n">handle_z</span><span class="p">);</span>
</span><span class='line'><span class="n">handle_set_next</span><span class="p">(</span><span class="n">handle_x</span><span class="p">,</span> <span class="n">handle_y</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>But there are two (related) problems:</p>

<ol>
<li><p>How does one instantiate values that <em>unconditionally</em> hold
 pointers to GC objects.  (For example, how do we allocate an
 instance of <code>Cons&lt;GcPtr&lt;Cons&lt;char&gt;&gt;&gt;</code>?)
 <br></br>
 We have already established that the address in the GC Heap are
 not exposed outside of the heap, so the approach of passing in an
 <code>T</code> value that we used with <code>bbox_gc_alloc</code> above will not work,
 because we cannot put our hands on a <code>GcPtr</code> to use for the
 <code>data</code> field.</p></li>
<li><p>How do we get from the <code>struct</code> definition for <code>Cons</code> to
 the family of methods defined in terms of <code>Handle</code>?
 <br></br>
 Every occurrence of <code>GcPtr</code> used for the struct (as seen from
 the point of view of the GC Heap) needs to be mapped to
 a <code>Handle</code> in the functions exposed to the functions outside
 of GC Heap.</p></li>
</ol>


<p>Also, the hidden object addresses may complicate client code trying to
instantiate GC objects with its own types.</p>

<p>It could be that there is a solution to the problem lurking here.
In any case, interoperation with a blackbox GC is not a primary goal,
since the level of indirection and (perhaps more crucially)
the maintenance of the handles array are not ideal.</p>

<a name="Objectives.and.Requirements..oh.no..now.five.problems."></a>
<h2>Objectives and Requirements (oh no, now five problems)</h2>

<p>The two (or perhaps three) kinds of support described above are
distinct features; there is overlap between them, but trying to find a
single solution that solves both problems completely may not be
possible, and in any case we do not want to wait for that single
solution to be discovered.</p>

<p>Since <code>Rc&lt;T&gt;</code> is already a workable solution for many (though not all)
use cases of <code>Gc&lt;T&gt;</code>, the above idealized &ldquo;one GC shared by every
crate&rdquo; is not a main priority right now (and may never be added to the
Rust language).</p>

<p>Let us focus on GC as an interop feature, and dive into what we would
want to get out of it.</p>

<p>There are a number of objectives for Rust/GC integration that are
worth noting, which I will list here and then define and discuss
below.</p>

<ol>
<li><a href="#safety">Safe</a></li>
<li><a href="#modularity">Modular</a></li>
<li><a href="#zero-cost">Zero-Cost</a></li>
<li><a href="#compositionality">Compositional</a></li>
<li><a href="#precision">Precise (Space-Efficient)</a></li>
</ol>


<a name="L.span.id..safety..Safety.with.respect.to.GC..span."></a>
<h3><span id="safety">Safety with respect to GC</span></h3>

<p>If a Rust crate does not use <code>unsafe</code> constructs (<code>unsafe</code> blocks,
attributes or types with &ldquo;unsafe&rdquo; in their name, etc.), then linking
it with a sound set of crates that use GC must maintain soundness.</p>

<p>In other words, linking in a crate that uses no <code>unsafe</code> construct
should not inject any dereferences of dangling pointers, nor any data
races.</p>

<p>By the way, we absolutely do need to provide criteria that says what
<code>unsafe</code> code <em>is</em> allowed to do when linked with a crate that uses
GC. I am going to assume for these initial posts that we will solve
that problem eventually, but not attempt to address it at the outset.</p>

<a name="L.span.id..modularity..Modularity.with.respect.to.GC..span."></a>
<h3><span id="modularity">Modularity with respect to GC</span></h3>

<p>A Rust program that uses GC should be able to link to a crate whose
source code was authored without knowledge of GC.</p>

<p>For example, if I make a parsing library today that works on string
slices <code>&amp;str</code>, you should be able to link that parsing library into a
program that uses GC, without having to worry about whether the
parsing library carries hidden requirements that invalidate
assumptions made by the GC.</p>

<p>Note: A crate being &ldquo;authored without knowledge of GC&rdquo; is a
property of the source code, not the generated object code. Given
such a crate, the Rust compiler may itself inject metadata
related to GC, such as descriptions of object layout, or
automatically-generated code that dictate how objects should
traced by the collector.</p>

<p>Note: A crate being &ldquo;authored without knowledge of GC&rdquo; is entirely
distinct a crate not supporting GC. That is, we may add well a way for
a crate to declare that it is not compatible with GC. (This would
count as having knowledge of GC; in fact, enough knowledge to know, or
at least guess, that its presence would cause the GC to break, or vice
versa.)</p>

<p>If we cannot satisfy this requirement, then the addition of GC
will, at best, split the growing space of library crates (such as
those available on <a href="https://crates.io/">crates.io</a>) into two disjoint
sub-communities: crates that support GC, and those that do not
(since the latter were written without accounting for the
potential presence of a GC).</p>

<p>An aside: I would really like to find a way to combine the
descriptions of &ldquo;modularity&rdquo; and &ldquo;safety&rdquo;, since they seem to be
attempted to express similar or related objectives.</p>

<p>A final note: There are some features available to crates, such as
requiring a specific low-level allocator, that are likely to be
incompatible with a program that uses GC. We need to define these
caveats and incorporate them into the above definition of
&ldquo;modularity&rdquo;, without weakening it to the point of uselessness.
(However, I will not attempt to tackle that here.)</p>

<a name="L.span.id..zero-cost..Zero-Cost.GC..span."></a>
<h3><span id="zero-cost">Zero-Cost GC</span></h3>

<p>If you don&rsquo;t use the GC feature (in whatever form it takes), your code
should not pay for it.</p>

<p>This applies to the quality of the generated code (in execution
time and code size), and also to the source code, with respect to
difficulty in writing a program or library.</p>

<p>There are two forms of the zero-cost property relevant here:</p>

<ol>
<li><p>Strongly zero-cost: A unit of code generation that does not use
 GC should not pay for it.</p>

<p> For example, in the above example of the string parsing module,
 ideally the code generated for parsing <code>&amp;str</code> values should have
 the same performance characteristics, regardless of whether it is
 linked into a program that uses GC or not.</p></li>
<li><p>Weakly zero-cost: A program that does not use GC should not pay
 for it.</p>

<p> (At worst, one can imagine ensuring this property by compiling
 two different versions of each code unit, and then linking to the
 appropriate one. Hopefully we will not need to resort to that.)</p></li>
</ol>


<p>Strongly zero-cost implies weakly zero-cost, but not vice-versa.</p>

<a name="L.span.id..compositionality..Compositional.GC..span."></a>
<h3><span id="compositionality">Compositional GC</span></h3>

<p>One can use a reference to a gc-allocated object (call it a <code>GcRef</code>)
as the field type in a <code>struct</code>, store it into a <code>Vec&lt;GcRef&gt;</code>, and
in general do anything with it that one can do with a normal Rust value.</p>

<p>Furthermore, one should be able to describe, via a Rust type
definition, the layout of a value allocated on the GC heap, allocate
such values there, and acquire a suitable <code>GcRef</code> to the allocated
object.</p>

<p>To be concrete about this, consider the following program,
which uses a hypothetical <code>make_gc_ref</code> function to move
values into a newly-allocated spot on the GC heap, and returns
a reference to that spot. (In the future one will probably use
the <code>box</code> syntax for this, and rely on type-context to inform
box that this is a GC-allocation.)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">demo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">gc_v</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>        <span class="kd">let</span> <span class="n">ref_x1</span> <span class="o">=</span> <span class="n">make_gc_ref</span><span class="p">(</span><span class="s">&quot;data_one&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="kd">let</span> <span class="n">ref_x2</span> <span class="o">=</span> <span class="n">make_gc_ref</span><span class="p">(</span><span class="s">&quot;data_two&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="kd">let</span> <span class="n">v</span> <span class="o">=</span> <span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">];</span>
</span><span class='line'>        <span class="n">make_gc_ref</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This results in the following diagram:</p>

<p id="target_anchor_demo_composition_1"></p>


<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var rust_heap = { rankdir:"LR", id: "cluster_rust_heap", label: "Rust Heap", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };

var x1 = object_record("X1", "<f0> 'data_one'");
var x2 = object_record("X2", "<f0> 'data_two'");

x1.style = "rounded";
x2.style = "rounded";

var gc_v = { id: "gc_v", label: "Gc(V)", shape: "record" };

var v = object_record("V", "<f0> len: 3 | cap: 4 | <f2> ptr: Arr");
v.style = "rounded";
var arr = object_record("Arr", "<f0> Gc(X1) | <f1> Gc(X1) | <f2> Gc(X2)");
arr.color = "blue";

v.f2 = edge_from_to_ports(":f2", ":id", arr);
gc_v.f0 = edge_to_port(":id", v);

arr.f0 = edge_from_to_ports(":f0", ":id", x1);
arr.f1 = edge_from_to_ports(":f1", ":id", x1);
arr.f2 = edge_from_to_ports(":f2", ":id", x2);

stack[0] = gc_v;
rust_heap[0] = arr;
gc_heap[0] = v;
gc_heap[1] = x1;
gc_heap[2] = x2;

var objects = [stack, gc_heap, rust_heap];
post_objects("target_anchor_demo_composition_1", objects, { rankdir:"LR", nodesep:0.2 });
</script>


<p>Here, I have made explicit the heap-allocated backing store <code>Arr</code> (in
blue) for the vector that holds the references to <code>x1</code> and <code>x2</code>.</p>

<p>This shows that if we want GC to reasonably usable (i.e., allow GC
references to be used like other Rust values), we need to support
references out of the GC heap and into the Rust heap, and likewise
references out of the Rust heap and into the GC heap.</p>

<p>It can sometimes be simpler (without necessarily eliminating the
fundamental problem) to just a <code>Box</code> rather than a <code>Vec</code>:</p>

<p id="target_anchor_demo_composition_2"></p>


<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var rust_heap = { rankdir:"LR", id: "cluster_rust_heap", label: "Rust Heap", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };
var c = object_record("C", "<f0> Gc(X) | <f1> Box(O)");
c.style = "rounded";
var o = object_record("O", "<f0> Gc(X)");
var x = object_record("X", "<f0> 'data'");
x.style = "rounded";
var gc_a = { id: "gc_c", label: "Gc(C)", shape: "record" };

gc_a.f0 = edge_to_port(":id", c);

o.f0 = edge_from_to_ports(":f0", ":id", x);

c.f0 = edge_from_to_ports(":f0", ":id", x);
c.f1 = edge_from_to_ports(":f1", ":id", o);

stack[0] = gc_a;
rust_heap[0] = o;
gc_heap[0] = c;
gc_heap[1] = x;

var objects = [stack, gc_heap, rust_heap];
post_objects("target_anchor_demo_composition_2", objects, { rankdir:"LR", nodesep:0.2, no_dims: true });
</script>


<p>The program to construct the above picture might look like
this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">demo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">C</span><span class="p">(</span><span class="n">Gc</span><span class="o">&lt;</span><span class="kt">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Box</span><span class="o">&lt;</span><span class="n">Gc</span><span class="o">&lt;</span><span class="kt">str</span><span class="o">&gt;&gt;</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">gc_c</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>        <span class="kd">let</span> <span class="n">ref_x</span> <span class="o">=</span> <span class="n">make_gc_ref</span><span class="p">(</span><span class="s">&quot;data&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="kd">let</span> <span class="n">box_o</span> <span class="o">=</span> <span class="n">Box</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">ref_x</span><span class="p">);</span>
</span><span class='line'>        <span class="n">make_gc_ref</span><span class="p">(</span><span class="n">C</span><span class="p">(</span><span class="n">ref_x</span><span class="p">,</span> <span class="n">box_o</span><span class="p">))</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>(The types in the demo program above assume certain features like
allowing <code>Gc&lt;T&gt;</code> for <code>T: ?Sized</code>, which may or may not be reasonable.)</p>

<p>The compositionality constraint may seem obvious (especially if one
starts by assuming that references to gc-allocated objects will be
values of type <code>Gc&lt;T&gt;</code> for arbtrary <code>T</code>).</p>

<p>But using &ldquo;black box&rdquo; GC interop (as described above) would likely
<em>defeat</em> compositionality.  That is why I point out this objective
explicitly.</p>

<a name="L.a.id..precision..Precision..Space-Efficiency...a."></a>
<h3><a id="precision">Precision (Space-Efficiency)</a></h3>

<p>A 100% precise GC is one that knows the type of every object and field
that it encounters, in terms of being able to classify a word of
memory as an integer or a pointer, and also classify whether a given
word of memory is actually usable according to the type of the value
the word is embedded within.</p>

<p>A space-efficient GC, in essence, is one that is eventually able to
reclaim all garbage, without being subverted by particular details of
the host program or the system state.</p>

<p>(Calling a language implementation space-efficient is a reference to
the <a href="http://www.cesura17.net/~will/professional/research/papers/tail.pdf">asymptotic space complexity</a> of a language implementation.  I am
employing the term here because the objective I want to capture is
more general than just precision.)</p>

<p>A <a href="http://blog.pnkfx.org/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work/#conservative-gc">conservative GC</a> lacks precision. In other words,
a precise GC is more space-efficient than a conservative GC: There
exists a program that will exhibit worse (asymptotic) space
performance atop a conservative GC than it would atop a precise GC.</p>

<p>We would like Rust to be able to interoperate with 100% precise
collectors.</p>

<p>Ideally, we would also like to be able to interoperate with collectors
that do not support <a href="http://blog.pnkfx.org/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work/#pinning-support">pinning</a>.</p>

<p>Finally, we would like to ensure that the heap patterns associated
with <a href="#compositionality">Compositionality</a> do not cause garbage to go unreclaimed.</p>

<ul>
<li>Note that a precise GC that treats <em>all</em> objects on the &ldquo;Rust Heap&rdquo;
as roots is not very space-efficient: it will fail to collect
cyclic garbage structure like the below.</li>
</ul>


<p id="target_anchor_demo_garbage_cycle_thru_rust_heap"></p>


<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var rust_heap = { rankdir:"LR", id: "cluster_rust_heap", label: "Rust Heap", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };

var local_a = { id: "local_a", label: "a", shape: "record" };

var a = object_record("A", "<f0> Some(Gc(B)) | <f1> None");
a.style = "rounded";
var b = object_record("B", "<f0> None | <f1> None");
b.style = "rounded";
var c = object_record("C", "<f0> Some(Gc(B)) | <f1> Some(Box(O))");
c.style = "rounded";
var o = object_record("O", "<f0> Gc(C)");

a.f0 = edge_from_to_ports(":f0", ":id:n", b);

c.f0 = edge_from_to_ports(":f0", ":id", b);
c.f1 = edge_from_to_ports(":f1:s", ":id", o);
o.f0 = edge_from_to_ports(":f0", ":id", c);

stack[1] = local_a;
local_a.ref = edge_to_port(":id", a);

gc_heap[0] = a;
gc_heap[1] = b;
gc_heap[2] = c;
rust_heap[0] = o;

var objects = [stack, gc_heap, rust_heap];
post_objects("target_anchor_demo_garbage_cycle_thru_rust_heap", objects, { rankdir:"LR", nodesep:0.2, no_dims: true});
</script>


<p>In the above diagram, &ldquo;C&rdquo; and &ldquo;O&rdquo; are unreachable by the program
itself (&ldquo;O&rdquo; is owned by the gc-allocated &ldquo;C&rdquo;), but if you treat all
objects in the Rust Heap as roots, then it will classify &ldquo;O&rdquo; as a
root, and &ldquo;C&rdquo; will never be reclaimed.</p>

<p>This is why compositionality can interact with space-efficiency.
Allowing gc-allocated objects to own data allocated on the Rust heap,
while also allowing references to gc-allocated objects to be stored in
values on the Rust heap, then you will encounter cyclic structure like
this. (This was the design bug that led me to withdraw my &ldquo;Take II&rdquo;
<a href="https://github.com/rust-lang/rfcs/pull/244">allocator RFC</a>.)</p>

<a name="Conclusion"></a>
<h2>Conclusion</h2>

<p>This post was dedicated to identifying criteria that we would
like GC-integration with Rust to satisfy.</p>

<p>Next up: Why is it hard to satisfy the above criteria simultaneously?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GC and Rust Part 0: Garbage Collection Background]]></title>
    <link href="http://blog.pnkfx.org/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work/"/>
    <updated>2015-10-27T14:09:00+01:00</updated>
    <id>http://blog.pnkfx.org/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work</id>
    <content type="html"><![CDATA[<p>This post is a prequel to a series of posts discussing why garbage
collection is hard, especially for Rust, and brainstorming about
solutions to the problems we face.</p>

<p>The goal of this post is to provide the background foundational material
about Garbage Collection that the other posts will then build upon.</p>

<!-- more -->


<p>You can skip ahead to the follow-up posts (once they are published) if
you feel you are already well-versed in the low-level mechanics of
garbage collection.</p>

<p>I may add more material to this post in the future if I discover a
need to provide more detail on a particular subtopic, such as &ldquo;write
barriers&rdquo;.</p>

<p>(The body of this post makes heavy use of client-side rendering,
because of author idiosyncrasies.  You may need to wait a moment while
the supporting Javascript loads.)</p>

<p>Update (17 November 2015): It has come to my attention that portions
of the post are not rendering properly in Google Chrome. I will try to
fix this, but in the meantime, you should be able to get the proper
renderings in Safari or Firefox. (I do not yet know about other
browsers.) If your browser is working as original expected, then
you should see a picture load immediately beneath this text.</p>

<p>Update (18 Novemer 2015): many thanks to <code>othermike</code> on reddit who
pointed out <a href="https://www.reddit.com/r/rust/comments/3t6nk7/gc_and_rust_part_1_specifying_the_problem/cx40odj">my bug</a>.
The content should now render properly on Chrome (and hopefully other
browsers too).</p>

<script src="http://blog.pnkfx.org/javascripts/viz.js" charset="utf-8"></script>


<script src="http://blog.pnkfx.org/javascripts/js_to_dot.js" charset="utf-8"></script>


<script src="http://blog.pnkfx.org/javascripts/gc_rendering.js" charset="utf-8"></script>


<script>
function simple_gc_structure() {
    var rf = make_regfile("RF");
    var a = { id: "A" };
    var b = { id: "B" };
    var c = { id: "C" };
    var d = { id: "D" };
    var e = { id: "E" };
    var f = { id: "F" };
    var g = { id: "G" };
    b.f0 = c;
    d.f0 = a;
    d.f1 = e;
    e.f0 = f;
    f.f0 = e;
    c.f0 = g;

    rf.link(0, a);
    rf.link(1, b);
    rf.link(3, c);

    return [rf, d];
}

function copied_gc_structure() {
    var rf = make_regfile("RF");
    var a = { id: "A" };
    var b = { id: "B" };
    var c = { id: "C" };
    var d = { id: "D" };
    var e = { id: "E" };
    var f = { id: "F" };
    var g = { id: "G" };

    var a2 = { id: "A2", label: "A'" };
    var b2 = { id: "B2", label: "B'" };
    var c2 = { id: "C2", label: "C'" };
    var g2 = { id: "G2", label: "G'" };

    b.f0 = c;
    c.f0 = g;
    d.f0 = a;
    d.f1 = e;
    e.f0 = f;
    f.f0 = e;

    b2.f0 = c2;
    c2.f0 = g2;

    a.fwd = dashed_edge(a2);
    b.fwd = dashed_edge(b2);
    c.fwd = dashed_edge(c2);
    g.fwd = dashed_edge(g2);

    rf.link(0, a2);
    rf.link(1, b2);
    rf.link(3, c2);

    return [rf, d, a, b, c];
}

function simple_gc2() {
    var gc_struct = simple_gc_structure();
    var rf = gc_struct[0];
    var d = gc_struct[1];
    // for_each_reachable([d], hide, { on_edge: hide });
    // for_each_reachable([rf], unhide);
    var content = render_objects([rf, d]);
    return digraph(content, { rankdir:"LR" });
}
</script>




<p id="target_anchor1"></p>


<script>
var gc_struct = simple_gc_structure();
var rf = gc_struct[0];
var d = gc_struct[1];
var content = render_objects([rf]);
post_graph("target_anchor1", digraph(content, { rankdir:"LR" }), { no_dims: true });
</script>


<a name="What.is.Garbage.Collection"></a>
<h2>What is Garbage Collection</h2>

<p>A garbage collector is a component in the runtime for a programming
language that periodically attempts to reclaim memory (without
requiring explicit calls to memory-freeing routines in the programning
language). To do this soundly, the collector must identify blocks of
memory that cannot possibly be used in the future by the program
(i.e., &ldquo;dead objects&rdquo;).</p>

<p>Discussions of garbage collection often equate the notion of &ldquo;dead
object&rdquo; with &ldquo;unreachable object&rdquo;: If no chain of references exists
that could lead the program to an object, then that object cannot be
reached<label for='collecting-more-garbage' class='margin-toggle'> &#8853;</label><input type='checkbox' id='collecting-more-garbage' class='margin-toggle'/><span class='marginnote'>Researchers have explored methods to identify objects as dead even when reachable, such as using <a href="http://pop-art.inrialpes.fr/~fradet/PDFs/LISP94.pdf">&ldquo;parametricity&rdquo;</a>; but I am not aware of any such method being used outside of a research setting. </span>
 (and therefore cannot be used in the future).</p>

<p>When one says &ldquo;garbage collector&rdquo;, one usually means a &ldquo;<em>tracing</em>
garbage collector&rdquo;: a collector that works by identifying the
reachable objects by computing the connected components that include
the &ldquo;roots&rdquo; of the object graph. (The &ldquo;roots&rdquo; are the starting points
from which any chain of references must originate in the source
program.)</p>

<p>So, for example, we might have the following set of
gc-managed objects (labelled &ldquo;A&rdquo; through &ldquo;F&rdquo; below),
along with a register file labelled &ldquo;RF&rdquo;.</p>

<p id="target_anchor2"></p>


<script>
post_objects("target_anchor2", simple_gc_structure(), { rankdir:"LR", no_dims: true });
</script>


<p>In the simple model above, the roots <em>are</em> the processor
registers. Such a model is applicable to a language runtime where all
memory blocks (<em>including</em> the stack frames) are managed by the garbage
collector. (In other words, we are not talking about Rust yet.)</p>

<p>The reachable objects, as stated above, are the connected
components of the graph that includes the roots, highlighted
below.</p>

<p id="target_anchor3"></p>


<script>
// Overriding the `highlight` I put into js_to_dot.js
function highlight(object) {
    object.penwidth = "3.0";
    return object;
}

var objects = simple_gc_structure();
for_each_reachable([objects[0]], { on_node: highlight, on_edge: highlight });
post_objects("target_anchor3", objects, { rankdir:"LR", no_dims: true });
</script>


<p>A garbage collector would determine that the objects
labelled &ldquo;D&rdquo;, &ldquo;E&rdquo;, and &ldquo;F&rdquo; are unreachable, and thus
their storage can be reclaimed.</p>

<a name="L.span.id..how-gc-works..How.Garbage.Collection.works..span."></a>
<h2><span id="how-gc-works">How Garbage Collection works</span></h2>

<p>A garbage collector is often presented as a <em>coroutine</em>
<label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
Coroutines are much like subroutines,
except that instead of having a parent-child relationship (where the
child subroutine &ldquo;returns&rdquo; to the parent caller), a call from
coroutine A to coroutine B: saves the current context of where A
currently is, transfers control to B, and the next time B calls A,
resumes the context that was saved at the outset.
<br></br>
In other words, once the linkage has been established between A and B,
then A&rsquo;s calls to B look like <em>returns</em> from the viewpoint of B, (and
B&rsquo;s calls to A look like returns from the viewpoint of A).
</span>
 that is linked in with the main
program. The main program itself is often referred to as a &ldquo;mutator&rdquo;,
since it is the entity that <em>mutates</em> the object graph.  (The
collector does not modify the abstract object graph, but rather the
<em>representation</em> of the object graph in memory.)</p>

<p>The mutator requests memory from some allocation service (usually
deeply integrated with the garbage collector for reasons we will see).
If there is a memory block immediately available to satisfy the
request, then the allocator hands that over. If there is not
sufficient free memory, then the mutator&rsquo;s allocation attempt invokes
the garbage collector coroutine.</p>

<p>Garbage collectors are also often divided into two categories: Copying
collectors, and Mark-Sweep collectors. Both collectors accomplish the
goal of identifying the reachable objects and reclaiming the
remainder, but they do it in different ways.</p>

<p>It is worthwhile to remember at this point that even though our object
graphs above are drawn as abstract circles and arrows, the objects are
represented somehow in memory.</p>

<p>For example, here is one potential representation for the above object
graph, where <code>-</code> denotes some value that the GC knows is not a
memory reference.</p>

<p id="target_anchor4" class=fullwidth></p>


<p>(Assume for this example that every GC allocated
object is made from four consecutive words in memory.)</p>

<script>
function make_memory_label(count, name_callback, val_callback) {
    var addresses = "ADDRESS";
    var contents = "CONTENT";
    var saw_one = true;
    for (i = 0; i < count; i++) {
        if (saw_one) { addresses += " | "; contents += " | ";}
        var name;
        if (name_callback) {
            name = name_callback(i);
        } else {
            name = "0x1";
            name += ("0000" + (i * 8).toString(16)).slice(-4);
        }
        addresses += name;
        if (val_callback) { contents += val_callback(i, name); }
        saw_one = true;
    }
    var label = "{ { " + addresses + " } | { " + contents + " } }";
    return label;
}
function make_memory_addr_val(state) {
var marks = state.marked;
var swept = state.swept;
var a_copied = state.a_copied;
var b_copied = state.b_copied;
var c_copied = state.c_copied;
var g_copied = state.g_copied;
var a_scanned = state.a_scanned;
var b_scanned = state.b_scanned;
var c_scanned = state.c_scanned;
var g_scanned = state.g_scanned;
var addr1=[
          "<nd> 0x10000 "+(swept?"":"(D) ")+"\\l",
          "0x10004 "+(swept?" (next)":"")+"\\l",
          "0x10008 \\l",
          "0x1000c \\l",
          "<na> 0x10010 (A) \\l",
          "0x10014 \\l",
          "0x10018 \\l",
          "0x1001c \\l",
          "<ne> 0x10020 "+(swept?"":"(E) ")+"\\l",
          "0x10024 "+(swept?" (next)":"")+"\\l",
          "0x10028 \\l",
          "0x1002c \\l",
          "<nb> 0x10030 (B) \\l",
          "0x10034 \\l",
          "0x10038 \\l",
          "0x1003c \\l",
         ];
var addr2 = [
          "<nc> 0x10040 (C) \\l",
          "0x10044 \\l",
          "0x10048 \\l",
          "0x1004c \\l",
          "<ny> 0x10050 \\l",
          "0x10054 "+(swept?" (next)":"")+"\\l",
          "0x10058 \\l",
          "0x1005c \\l",
          "<nf> 0x10060 "+(swept?"":"(F) ")+"\\l",
          "0x10064 "+(swept?" (next)":"")+"\\l",
          "0x10068 \\l",
          "0x1006c \\l",
          "<ng> 0x10070 (G) \\l",
          "0x10074 \\l",
          "0x10078 \\l",
          "0x1007c \\l",
         ];
var addr3 = [
          "<na> 0x20000 "+(a_copied?"(A') ":"")+"\\l",
          "0x20004 \\l",
          "0x20008 \\l",
          "0x2000c \\l",
          "<nb> 0x20010 "+(b_copied?"(B') ":"")+"\\l",
          "0x20014 \\l",
          "0x20018 \\l",
          "0x2001c \\l",
          "<nc> 0x20020 "+(c_copied?"(C') ":"")+"\\l",
          "0x20024 \\l",
          "0x20028 \\l",
          "0x2002c \\l",
          "<ng> 0x20030 "+(g_copied?"(G') ":"")+"\\l",
          "0x20034 \\l",
          "0x20038 \\l",
          "<lastg> 0x2003c \\l",
];
var val1 = [
           (swept ? "<vd> (free) " : "<vd> (header)"), // (D)
           (swept ? "<f0> 0x10020" : "<dpa> 0x10010"),
           (swept ? " - "          : "<dpe> 0x10020"),
           " - ",
           (marks ? "<va> (marked)" : a_copied ? "<va> (fwd)" : "<va> (header)"), // (A)
           (a_copied ? "<afwd> 0x20000" : " - "),
           " - ",
           " - ",
           (swept ? "<ve> (free) " : "<ve> (header)"), // (E)
           (swept ? "<f1> 0x10050" : "<epf> 0x10060"),
           " - ",
           " - ",
            // (B)
           (marks ? "<vb> (marked)" : b_copied ? "<vb> (fwd)" : "<vb> (header)"),
           (b_copied ? "<bfwd> 0x20010" : "<bpc> 0x10040"),
           " - ",
           " - ",
          ];
var val2 = [
           (marks ? "<vc> (marked)" : c_copied ? "<vc> (fwd)" : "<vc> (header)"), // (C)
           (c_copied ? "<cfwd> 0x20020" : "<cpg> 0x10070"),
           " - ",
           " - ",
           (swept ? "<vy> (free) " : "<vy> (header)"), // unused
           (swept ? "<f2> 0x10060" : " - "),
           " - ",
           " - ",
           (swept ? "<vf> (free) " : "<vf> (header)"), // (F)
           (swept ? "<f3> null " : " - "),
           (swept ? " - "          : "<fpe> 0x10020"),
           " - ",
           (g_copied ? "<vg> (fwd)" : marks ? "<vg> (marked)" : "<vg> (header) "), // (G)
           (g_copied ? "<gfwd> 0x20030" : " - "),
           " - ",
           " - ",
          ];
var val3 = [
           ((a_scanned || a_copied) ? "<va> (header)" : " - "), // (A')
           " - ",
           " - ",
           " - ",
           // (B')
           (b_scanned ? "<vb> (header) " : b_copied ? "<vb> (header)" : " - "),
           (b_scanned ? "<bpc2> 0x20020 " : b_copied ? "<bpc> 0x10040" : " - "),
           " - ",
           " - ",
           // (C')
           (c_scanned ? "<vc> (header) " : c_copied ? "<vc> (header)" : " - "),
           (c_scanned ? "<cpg2> 0x20030 " : c_copied ? "<cpg> 0x10070" : " - "),
           " - ",
           " - ",
            // (G')
           (g_scanned ? "<vg> (header) " : g_copied ? "<vg> (header)" : " - "),
           " - ",
           " - ",
           " - ",
          ];
    return [addr1, val1, addr2, val2, addr3, val3];
}
function make_graph_in_memory(options) {
    var original = options.original;
    var marking  = options.marking;
    var marked = options.marked;
    var swept  = options.swept;
    var free_list = options.free_list;
    var conservative_r2 = options.conservative_r2;
    var avail = options.avail;
    var rf = make_regfile("RF");
    var addrval = make_memory_addr_val(options);
    var addr1 = addrval[0];
    var val1 = addrval[1];
    var addr2 = addrval[2];
    var val2 = addrval[3];
    var addr3 = addrval[4];
    var val3 = addrval[5];
    var a_copied = options.a_copied;
    var b_copied = options.b_copied;
    var c_copied = options.c_copied;
    var g_copied = options.g_copied;
    var a_scanned = options.a_scanned;
    var b_scanned = options.b_scanned;
    var c_scanned = options.c_scanned;
    var g_scanned = options.g_scanned;
    var highlight_bpc2 = options.highlight_bpc2;
    var highlight_rc2 = options.highlight_rc2;
    var highlight_cfwd = options.highlight_cfwd;
    rf.label = "<id>RF | { { <r0>r0 | <r1>r1 | <r2>r2 | <r3>r3 } |" +
        " { <r0v>"+(a_copied?"0x20000":"0x10010")+
        " | <r1v>"+(b_copied?"0x20010":"0x10030")+
        " | <r2v>"+(conservative_r2?"0x10000":"-")+
        " | <r3v>"+(c_copied?"0x20020":"0x10040")+
        " } }";
    rf.pos = "0,500!";
    var from_space = options.from_space;
    var two_space = options.two_space;
    var two_space_content = !two_space ? "" : [
        'mem3 [shape="record",',
        'pos="-180,500!",',
        'label=\"'+make_memory_label(16,
                function (i) { return addr3[i]; },
                function (i, addr) { return val3[i]; })+'\",',
        '];',
        (!from_space ? "" : a_copied ? 'mem1:afwd:w -> mem3:va:e [style="dashed"];' : ""),
        (!from_space ? "" : b_copied ? 'mem1:bfwd:w -> mem3:vb:e [style="dashed"];' : ""),
        (!from_space ? "" : c_copied ? 'mem2:cfwd:w -> mem3:vc:e ['+(highlight_cfwd ? 'penwidth="3.0",' : '')+'style="dashed"];' : ""),
        (!from_space ? "" : g_copied ? 'mem2:gfwd:w -> mem3:vg:e [style="dashed"];' : ""),
        (b_scanned ? 'mem3:bpc2:e -> hidden_bc2 ['+(highlight_bpc2 ? 'penwidth="3.0",' : '')+'arrowhead="none"];' : b_copied ? 'mem3:bpc:e -> hidden_rc [arrowhead="none"];' : ""),
        (b_scanned ? 'hidden_bc2 -> mem3:vc:e' + (highlight_bpc2 ? '[penwidth="3.0"]':';') : ""),
        (c_scanned ? 'mem3:cpg2:e -> hidden_cg2 [arrowhead="none"];' : c_copied ? 'mem3:cpg:e -> mem2:ng:w;' : ""),
        (c_scanned ? 'hidden_cg2 -> mem3:vg:e;' : ""),
        (avail ? 'avail[pos="-90,375!"]; ' : ''),
        ((avail && avail.trim() != "") ? 'avail -> ' + avail + ';': ''),
    ].join('\n');
    var from_space_content = [
        'mem1 [shape="record",',
        !from_space ? 'style="invis",' : "",
        'pos="120,500!",',
        'label=\"'+make_memory_label(16,
            function (i) { return addr1[i]; },
            function (i, addr) { return val1[i]; })+'\",',
        '];',
        'hidden_ra  [ pos="-50,550!", shape="point", label="", width=0 ];',
        'hidden_rb  [ pos="-50,450!", shape="point", label="", width=0 ];',
        'hidden_rc  [ pos="-30,660!", shape="point", label="", width=0 ];',
        'hidden_da  [ pos="200,590!", shape="point", label="", width=0 ];',
        'hidden_de  [ pos="200,540!", shape="point", label="", width=0 ];',
        'hidden_bc  [ pos="220,590!", shape="point", label="", width=0 ];',
        'hidden_bc2  [ pos="-100,510!", shape="point", label="", width=0 ];',
        'hidden_cg  [ pos="375,590!", shape="point", label="", width=0 ];',
        'hidden_cg2  [ pos="-100,430!", shape="point", label="", width=0 ];',
        'hidden_fe1 [ pos="375,350!", shape="point", label="", width=0 ];',
        'hidden_fe2 [ pos="25,350!", shape="point", label="", width=0 ];',
        'hidden_yf [ pos="375,500!", shape="point", label="", width=0 ];',
        'hidden_fz [ pos="375,450!", shape="point", label="", width=0 ];',
        free_list ? 'free_list [ pos="0,620!", shape="rectangle", label="free-list" ];' : '',
        'mem2 [shape="record",',
        !from_space ? 'style="invis",' : "",
        'pos="300,500!",',
        'label=\"'+make_memory_label(16,
            function (i) { return addr2[i]; },
            function (i, addr) { return val2[i]; })+'\",',
        '];',
    ].join('\n');

    var graph_in_memory = ['digraph { node [fontsize=8]; ',
        'bgcolor="transparent";',
        'layout="neato"; inputscale=72;',
        // 'overlap="false";',
        // 'node [ pin=true ];',
        'rankdir="LR";',
        'nodesep=1.2;',
        // 'rank="same";',
        'splines="curved";',
        // 'node [font = "10px Monospace"];',
        render_node(rf),
        from_space_content,
        // !marking ? 'RF:r0:w -> hidden_ra [arrowhead="none"];' : 'RF:r0:w -> hidden_ra [arrowhead="none",penwidth=3.0];',
        // !marking ? 'hidden_ra -> mem1:na:w;' : 'hidden_ra -> mem1:na:w [label="1", penwidth=3.0];',
        a_copied ? 'RF:r0:w -> mem3:va:e;' : !marking ? 'RF:r0v:e -> mem1:na:w;' : 'RF:r0v:e -> mem1:na:w [label="1", penwidth=3.0];',
        b_copied ? 'RF:r1:w -> mem3:vb:e;' : !marking ? 'RF:r1:w -> hidden_rb [arrowhead="none"];' : 'RF:r1:w -> hidden_rb [arrowhead="none",penwidth=3.0];',
        b_copied ? "" : !marking ? 'hidden_rb -> mem1:nb:w;' : 'hidden_rb -> mem1:nb:w [label="2", penwidth=3.0,penwidth=3.0];',
        c_copied ? 'RF:r3:w -> mem3:vc:e'+(highlight_rc2 ? "[penwidth=3.0]" : "") + ';' : !marking ? 'RF:r3:w -> hidden_rc [arrowhead="none"];' : 'RF:r3:w -> hidden_rc [arrowhead="none",penwidth=3.0];',
        conservative_r2 ? 'RF:r2v:e -> mem1:nd:w [penwidth=3.0];' : '',
        b_scanned ? '' : !marking ? 'hidden_rc -> mem2:nc:w;' : 'hidden_rc -> mem2:nc:w [label="5", penwidth=3.0];',
        two_space ? '' : original ? 'mem1:dpa:e -> hidden_da [arrowhead="none"];' : '',
        two_space ? '' : original ? 'hidden_da -> mem1:va:e;' : '',
        two_space ? '' : original ? 'mem1:dpe:e -> hidden_de [arrowhead="none"];' : '',
        two_space ? '' : original ? 'hidden_de -> mem1:ve:e;' : '',
        two_space ? '' : original ? 'mem1:epf:e -> mem2:nf:w;' : '',
        b_copied ? '' : !marking ? 'mem1:bpc:e -> hidden_bc [arrowhead="none"];' :
                 'mem1:bpc:e -> hidden_bc [arrowhead="none", label="3", penwidth=3.0];',
        b_copied ? '' : !marking ? 'hidden_bc -> mem2:nc:w;' : 'hidden_bc -> mem2:nc:w [penwidth=3.0];',
        c_copied ? '' : !marking ? 'mem2:cpg:e -> hidden_cg [arrowhead="none"];' :
                 'mem2:cpg:e -> hidden_cg [arrowhead="none", label="4", penwidth=3.0];',
        c_copied ? '' : !marking ? 'hidden_cg -> mem2:vg:e;' : 'hidden_cg -> mem2:vg:e [penwidth=3.0];',
        two_space ? '' : original ? 'mem2:fpe:e -> hidden_fe1 [arrowhead="none"];' : '',
        two_space ? '' : original ? 'hidden_fe1 -> hidden_fe2 [arrowhead="none"];' : '',
        two_space ? '' : original ? 'hidden_fe2 -> mem1:ne:w' : '',
        free_list ? 'free_list -> mem1:nd:w [style="dashed",penwidth=3.0]' : '',
        free_list ? 'mem1:f0:e -> hidden_de [style="dashed",penwidth=3.0, arrowhead="none"]' : '',
        free_list ? 'hidden_de -> mem1:ve:e [style="dashed",penwidth=3.0]' : '',
        free_list ? 'mem1:f1:e -> mem2:ny:w [style="dashed",penwidth=3.0]' : '',
        free_list ? 'mem2:f2:e -> hidden_yf [style="dashed",penwidth=3.0, arrowhead="none"]' : '',
        free_list ? 'hidden_yf -> mem2:vf:e [style="dashed",penwidth=3.0]' : '',
        two_space_content,
        '}'].join('\n');

    return graph_in_memory;
}
var graph_in_memory = make_graph_in_memory({from_space:true,original:true});
post_graph("target_anchor4", graph_in_memory, {no_dims:true});
</script>


<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
Regarding the &ldquo;(header)&rdquo; words in the diagram:
Garbage collectors often require that the
GC-managed memory be formatted in a way such that the collector can
&ldquo;parse&rdquo; it when doing a scan over its address space.
<br></br>
As part of this &ldquo;parsing&rdquo;, the GC needs to be able to derive the size
of each object it looks at.
<br></br>
The address-space could be
partitioned into size classes.
Or if objects in a
block are to be variable-sized, the size could be recorded in object
headers (which are often needed anyway to store things like mark bits or other data).
<br></br>
Clever representation techniques exist that avoid using
header words for small objects (like pairs) without requiring size-class
partitioning; but I digress.
</span></p>

<p>In these pictures, there is no difference between an arrow pointing to
the left- verus right-side of a memory cell; so the occurrence of the
pointer to A (<code>0x10010</code>) in <code>r0</code> is no different than the occurrence
of that same value in memory cell <code>0x10004</code> (the first non-header word
of <code>D</code>), even though the arc for the former is pointing at the left
side of the first memory cell of <code>A</code>, and the arc for the latter is
pointing at the right side of that memory cell.</p>

<a name="Mark-Sweep.Collection"></a>
<h3>Mark-Sweep Collection</h3>

<p>A Mark-Sweep collector works by first doing a traversal of the
reachable memory, <em>marking</em> each object it finds (e.g. by setting a
bit reserved in the object header, or in separate mark bitmap if there
is no such bit reserved). This traversal requires some amount of extra
memory in reserve to track remaining work for the trace (e.g. a &ldquo;mark
stack&rdquo; of objects we are in the midst of traversing, and/or a queue of
objects scheduled for future traversal).</p>

<a name="The..Mark..phase"></a>
<h4>The &ldquo;Mark&rdquo; phase</h4>

<p>Here is a sketch of the traversals that the garbage collector
makes in order to mark each reachable object.</p>

<p id="target_anchor5" class="fullwidth"></p>


<script>
var graph_in_memory = make_graph_in_memory({from_space:true,marking:true, marked:true});
post_graph("target_anchor5", graph_in_memory, {no_dims: true});
</script>


<p>As reflected in the diagram above, each object that the GC reaches has
its mark bit set to &ldquo;marked&rdquo; in its header word.</p>

<p>The numbers on the arcs above are meant to correspond to a
hypothetical traversal order as the GC marks the memory; particular
tracing strategies may yield different orders. (No matter what, we
will not trace object &ldquo;G&rdquo; until after we have seen &ldquo;C&rdquo; via some
route.)</p>

<p>Also, I have left the memory for the mark-stack out of the picture; in
this case the mark-stack would not grow very large, but in general one
must anticipate the mark-stack growing as large as the longest path
through the reachable object graph. (The longest path in this case is
three objects long.)</p>

<a name="The..Sweep..phase"></a>
<h4>The &ldquo;Sweep&rdquo; phase</h4>

<p><label for='' class='margin-toggle'>&#8853;</label><input type='checkbox' id='' class='margin-toggle'/><span class='marginnote'>
As previously mentioned, the GC much be able to &ldquo;parse&rdquo; the memory when
scanning the address space.
<br></br>
In the case of the Mark-Sweep collector, in addition to having to be able
to derive the size of each object, we also need the mark bit for each object
to be located at predictable location.
</span>
A Mark-Sweep collector does not move objects, so it must resort to
metadata such as a free-list to track reclaimed memory.  So, after the
marking is finished, the GC then <em>sweeps</em> over the memory: it walks
over the GC-managed address space
and builds up a free-list of blocks that were not marked during the traversal.</p>

<p id="target_anchor6" class="fullwidth"></p>


<script>
var graph_in_memory = make_graph_in_memory({from_space:true,marked:true, swept: true, free_list: true});
post_graph("target_anchor6", graph_in_memory, {no_dims:true});
</script>


<p>(The arcs that make up the free-list above are dashed, to distinguish
them from the &ldquo;real&rdquo; references that make up the object graph. In the
above scheme, the pointer to the next element in the free list is held
in the second word of each free block.<label for='free-list-next' class='margin-toggle'> &#8853;</label><input type='checkbox' id='free-list-next' class='margin-toggle'/><span class='marginnote'>Putting the <code>next</code>-pointers for the free-list into the second word of each four-word block is one way of satisfying the aforementioned requirement that the GC-managed memory be parseable. </span>)</p>

<p>With that, the GC is done; the mutator (i.e. main program) is now free
to take blocks off of the free-list to satisfy memory requests.</p>

<a name="L.span.id..conservative-gc..Conservative.Collection..span."></a>
<h3><span id="conservative-gc">Conservative Collection</span></h3>

<p>A conservative collector is a particular kind of Mark-Sweep collector
where it is not provided enough information to know whether one or
more words of reachable data that it encounters should be interpreted
as a reference or not. Such a collector is forced to assume
(conservatively) that if the encountered datum is an allocated address
on the GC-managed heap, then that could be its purpose from the
perspective of the mutator, and therefore that datum must be treated
as a reference to memory.</p>

<p>In the diagrams above, I said that <code>-</code> denotes some value that the
GC knows is not a memory reference. In a conservative collector
without any type information, the only kind of value that can be
interpreted that way is one that lies outside the addreses space of
the GC-heap.</p>

<p>So for example, if we had the same picture as above, but the register
<code>r2</code> happen to hold an integer with value <code>0x10000</code>, and the
conservative collector is not told &ldquo;<code>r2</code> holds a non-reference at this
point in the execution&rdquo;, then this diagram would result:</p>

<p id="target_anchor_conservative_gc" class="fullwidth"></p>


<script>
var graph_in_memory = make_graph_in_memory({from_space:true,original:true,conservative_r2:true});
post_graph("target_anchor_conservative_gc", graph_in_memory, {no_dims:true});
</script>


<p>That is, even though in the program itself, the value <code>0x10000</code> is not
meant to be interpreted as a memory address, <code>D</code> (and <code>E</code> and <code>F</code>) are
all conservatively classified as live objects.</p>

<a name="Copying.Collection"></a>
<h3>Copying Collection</h3>

<p>A Copying collector moves objects from one location to another as part
of its tracing process, and updates the references in reachable
objects as it goes.</p>

<p>I will first illustrate this using our low-level memory graph,
but I will not draw the edges for the dead objects anymore,
as they add significant clutter to the picture.</p>

<a name="The.Reserved..To-space."></a>
<h4>The Reserved &ldquo;To-space&rdquo;</h4>

<p>First, we need to have some reserved memory to target as we copy
objects.  I have put this target memory (the so-called &ldquo;to-space&rdquo;) on
the left-hand side of the picture; the nearby &ldquo;avail&rdquo; circle is a
local variable in the GC that indicates the starting address that we
can use to copy objects into; so it starts off at the first address,
<code>0x20000</code>.</p>

<p id="target_anchor7" class="fullwidth"></p>


<script>
var graph_in_memory = make_graph_in_memory({from_space:true,original:true, two_space:true, avail: "mem3:na"});
post_graph("target_anchor7", graph_in_memory, {no_dims:true});
</script>


<a name="Copying.from.the.Roots"></a>
<h4>Copying from the Roots</h4>

<p>First we walk over the roots (in our simplified model, the registers),
and copy over all of the objects we see. So the below results after
we scan just the first two registers, copying the objects <code>A</code> and <code>B</code>
into new locations, respectively labelled <code>A'</code> and <code>B'</code>, and updating
<code>avail</code> accordingly.</p>

<p><a id="memory_post_copy_a_and_b"><p id="target_anchor8a" class="fullwidth"></p></a></p>

<script>
var graph_in_memory = make_graph_in_memory({from_space:true,original:true, two_space:true,
    a_copied:true, b_copied:true, avail: "mem3:nc"});
post_graph("target_anchor8a", graph_in_memory, {no_dims:true});
</script>


<p>Note that as we copy objects from the source memory
(the so-called &ldquo;from-space&rdquo;), we must maintain a map from the
original object to its newly allocated copy. In this model,
this is accomplished by imperatively overwriting the original object
with <code>fwd</code> header marking it as &ldquo;forwarded&rdquo; as well as a &ldquo;forwarding
pointer&rdquo; (the dashed arcs) that points to the new location.</p>

<p>The copies themselves just get the original memory contents, so they
may have pointers to the old objects in the source memory (such as the
<code>B' -&gt; C</code> arc in the picture). Those will get fixed up later.</p>

<p>We still need to scan the rest of the registers, which copies <code>C</code> as
shown below.</p>

<p id="target_anchor8b" class="fullwidth"></p>


<script>
var graph_in_memory = make_graph_in_memory({from_space:true,original:true, two_space:true,
    highlight_rc2: true, highlight_cfwd: true,
    a_copied:true, b_copied:true, c_copied:true, avail: "mem3:ng"});
post_graph("target_anchor8b", graph_in_memory, {no_dims:true});
</script>


<a name="Scan.the..To-space."></a>
<h4>Scan the &ldquo;To-space&rdquo;</h4>

<p>Now that we have finished scanning the roots, we start the fixup
process of scanning over the &ldquo;to-space.&rdquo; Every time we encounter a
pointer into the &ldquo;from-space&rdquo;, there are two cases to consider: Either
it is an already copied object (in which case there will be a
forwarding pointer installed), or it is an object that is not yet
copied.</p>

<p>If its a forwarded object, then we fixup our reference so that it
points to the new copy in the &ldquo;to-space&rdquo;. We see this when the fixup
scan is scanning over <code>B'</code> and sees the <code>B' -&gt; C</code> reference, which it
then rewrites to a <code>B' -&gt; C'</code> reference, highlighted below.</p>

<p id="target_anchor9" class="fullwidth"></p>


<script>
var graph_in_memory = make_graph_in_memory({from_space:true,original:true, two_space:true,
    highlight_bpc2:true,
    a_copied:true, b_copied:true, c_copied:true,
    a_scanned:true, b_scanned:true, avail: "mem3:ng"
    });
post_graph("target_anchor9", graph_in_memory, {no_dims:true});
</script>


<p>The fixup scan is not yet complete; the next object it encounters,
<code>C'</code>, illustrates the other case of a reference to an object (<code>G</code>
here) that has not yet been copied. In this case, it just copies it,
in the same manner that we did when we were scanning the roots. (This
adds the forwarded object to the set of objects enqueued for fixup
scanning.)</p>

<p id="target_anchor10" class="fullwidth"></p>


<script>
var graph_in_memory = make_graph_in_memory({from_space:true,original:true, two_space:true,
    a_copied:true, b_copied:true, c_copied:true, g_copied:true,
    a_scanned:true, b_scanned:true, c_scanned:true, avail: "mem3:lastg:s",
    });
post_graph("target_anchor10", graph_in_memory, {no_dims:true});
</script>


<a name="Reclaim.the..From-space."></a>
<h4>Reclaim the &ldquo;From-space&rdquo;</h4>

<p>Eventually the fixup scan will finish processing all of the &ldquo;to-space&rdquo;
(since there are only a finite number of objects that could be
enqueued). At this point, there will be no more reachable objects in
any part of the from-space, and thus those memory blocks can be
reclaimed in their entirety.</p>

<p id="target_anchor11" class="fullwidth"></p>


<script>
var graph_in_memory = make_graph_in_memory({two_space:true,
    a_copied:true, b_copied:true, c_copied:true, g_copied:true,
    a_scanned:true, b_scanned:true, c_scanned:true, g_scanned:true, avail: "mem3:lastg:s"
    });
post_graph("target_anchor11", graph_in_memory, {no_dims:true});
</script>


<p>Woo, done!</p>

<a name="A.Spectrum.of.Collectors"></a>
<h3>A Spectrum of Collectors</h3>

<p>The mark-sweep and copying collection methods illustrated above
actually form two extreme points on a spectrum of implementation
techhniques.</p>

<p>In practice, many collectors are neither entirely mark-sweep nor
copying, but rather employ a hybrid strategy, where some memory
regions are reclaimed via a copying-collection, while others are
managed via a mark-sweep method. For example, some generational
collectors work by promoting objects from a young space into an older
space via copying collection, but then the last space (with the eldest
objects) can be managed via mark-sweep.</p>

<p>As another example of a hybrid strategy, there exist conservative
collectors (such as &ldquo;mostly copying&rdquo; collectors) where exact type
information is known for the heap-allocated objects, but the types are
not known for the roots (i.e. the registers and values embedded in the
stack). In such systems, it is not safe to move objects that are
referenced via conservatively-scanned words. Such objects are &ldquo;pinned&rdquo;
in place (which means that it cannot be moved by the collector) for
the duration of this collection, and thus space in their memory blocks
can only be reclaimed with via a mark-sweep collection.  However,
objects reachable solely via precisely-scanned words <em>can</em> be moved,
and memory blocks made up solely of such objects can be reclaimed via
a copying-collection strategy.</p>

<a name="L.span.id..pinning-support..Pinning.Support..span."></a>
<h3><span id="pinning-support">Pinning Support</span></h3>

<p>In our discussion to follow, rather than attempt to characterize a
collector as &ldquo;mark-sweep&rdquo; or &ldquo;copying&rdquo;, it will be more useful to
distinguish collectors in terms of whether or not they support
&ldquo;pinning&rdquo;. In a language runtime that supports pinning, a mutator
(i.e. the main program linked with the collector coroutine) can tag
any live object as &ldquo;pinned&rdquo;.</p>

<p>(In the example of &ldquo;mostly copying&rdquo; above, such pinning is
accomplished by putting a reference into a conservatively-scanned
root. However, some language runtimes provide first class support for
pinning; for example, the Microsoft CLR once offerred a
<a href="https://msdn.microsoft.com/en-us/library/1dz8byfh.aspx"><code>pin_ptr</code></a> smart-pointer for Managed C++ that would prevent
a referenced object from moving.)</p>

<p>In other words, in a runtime with pinning, the mutator dictates which
objects can be managed via copying collection. If the runtime does not
support pinning, then it is the <em>collector</em> that dictates which
objects are managed via copying; the mutator cannot rely on the
collector allowing arbitrary objects to be pinned.</p>

<a name="Simplifying.our.diagrams"></a>
<h3>Simplifying our diagrams</h3>

<p>While I am sure it was fun to decode the above renderings of memory
banks, now that we have seen how collectors work at a low-level, I am
going to revert to the earlier high-level object notation.  It should
be easier for you to read, and (just as important) for me to write.</p>

<p id="target_anchor12"></p>


<script>
var gc_struct = simple_gc_structure();
var rf = gc_struct[0];
var d = gc_struct[1];

var a = rf.r0.target;
var b = rf.r1.target;
var c = rf.r3.target;

a_and_b = [a,b];
a_and_b.is_subgraph = true;
a_and_b.id = "cluster_a_and_b";
a_and_b.rank = "same";
a_and_b.style = "invis";

var gc_heap = [];
gc_heap.push(a_and_b);
for_each_reachable([c,d], function (o) { if (o !== rf) { gc_heap.push(o); } })

gc_heap.is_subgraph = true;
gc_heap.style = "invis";
gc_heap.id = "cluster_gc_heap";
var content = render_objects([rf, a_and_b, gc_heap, d]);
post_graph("target_anchor12", digraph(content, {rankdir:"LR"}), {no_dims:true});
</script>


<p>To show a copying collector&rsquo;s intermediate state in a high-level
picture, I will show newly copied objects with prime marks (and, if
possible, in a separately delineated to-space), and a dashed-line for
forwarding pointers.</p>

<p>Here is an example of this style of rendering, using the earlier
example at <a href="#memory_post_copy_a_and_b">the point where</a> a copying
collector had scanned just registers <code>r0</code> and <code>r1</code> (but had not yet
copied <code>C</code> from register <code>r3</code>), highlighting the copied objects and
the newly written references (including the dashed forwarding
pointers).</p>

<p id="target_anchor_simplified_copying"></p>


<script>
var rf = make_regfile("RF");
// rf.label = "{" + rf.label + "}";
var a = { id: "A" };
var b = { id: "B" };
var c = { id: "C" };
var d = { id: "D" };
var e = { id: "E" };
var f = { id: "F" };
var g = { id: "G" };
var a2 = { id: "A2", label: "A'", penwidth: "3.0" };
var b2 = { id: "B2", label: "B'", penwidth: "3.0" };
b.f0 = c;
c.f0 = g;
d.f0 = a;
d.f1 = e;
e.f0 = f;
f.f0 = e;
b2.f0 = c;
a.fwd = highlight(dashed_edge(a2));
b.fwd = highlight(dashed_edge(b2));
rf.link(0, a2, {penwidth: "3.0"});
rf.link(1, b2, {penwidth: "3.0"});
rf.link(3, c);

var a_and_b = [a, b];
a_and_b.is_subgraph = true;
a_and_b.rank="same";
var gc_heap1 = [a_and_b, c, d, e, f, g];
gc_heap1.is_subgraph = true;
gc_heap1.label = "from space";
gc_heap1.id = "cluster_gc_heap1";
var gc_heap2 = [a2, b2];
gc_heap2.is_subgraph = true;
gc_heap2.id = "cluster_gc_heap2";
gc_heap2.label = "to space";
gc_heap2.rank = "same";
gc_heaps = [gc_heap1, gc_heap2];
gc_heaps.is_subgraph = true;
// gc_heaps.id = "cluster_all_gc_heaps";
// gc_heaps.rankdir = "TD";
var objects = [rf, gc_heaps];
post_objects("target_anchor_simplified_copying", objects, {rankdir:"LR",no_dims:true});
</script>


<p>(This rendering is arguably just as clear (or unclear) as our earlier
<a href="#memory_post_copy_a_and_b">memory diagram</a> was, apart from some
annoying edge-crossings due to the graphviz layout engine.)</p>

<a name="Conclusion"></a>
<h2>Conclusion</h2>

<p>Well, I don&rsquo;t know if you learned anything about GC from this post.
I certainly learned a lot about techniques for wrestling with
graphviz.  :)</p>

<p>There will be a followup post soon-ish that will bring Rust into the
picture, discussing what GC and Rust integration even <em>means</em>, and
the host of problems that crop up.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vis-a-vis, part 1: Visualizing Graphs via viz.js]]></title>
    <link href="http://blog.pnkfx.org/blog/2015/10/12/viz-a-viz-js/"/>
    <updated>2015-10-12T14:10:00+02:00</updated>
    <id>http://blog.pnkfx.org/blog/2015/10/12/viz-a-viz-js</id>
    <content type="html"><![CDATA[<p>This is a post discussing a couple different ways to draw pictures,
mostly those of graphs (nodes and edges, i.e. circles or boxes, and
lines between them).</p>

<p>The technology covered by this post is <a href="https://github.com/mdaines/viz.js/">viz.js</a>, a Javascript
library for rendering graphs specified via the <a href="http://www.graphviz.org/content/dot-language">DOT</a> language.</p>

<!-- more -->


<p>Its meant both as a reference for me to use when I want to remind
myself of my options here, and as a demo of some interesting web
technologies.</p>

<p>I hope in later posts to cover SVG (&ldquo;Scalable Vector Graphics&rdquo;)
itself, and perhaps higher level Javascript libraries such as <a href="http://d3js.org/">D3</a>.</p>

<p>I will focus in these posts on client-side rendering technologies.
Another entirely reasonable option is to render the content to an
image (or SVG, or a JS script that renders into a canvas, et cetera).
However, one of my goals with my documents is to embed all of the
source text into the markdown content; a separate rendering tool would
require some sort of pre-process step, and I am loathe to try to
incoporate that into the <code>Rakefile</code> that Octopress uses.</p>

<a name="viz.js"></a>
<h2>viz.js</h2>

<p>The first item we will cover, since it amongst the simplest to adopt,
is <code>vis.js</code>, a javascript library that provides
<a href="http://www.graphviz.org/">graphviz-style</a> rendering in the browser client.</p>

<p>(<a href="http://www.graphviz.org/">Graphviz</a> is a tool for automatically laying out and
rendering graphs; it is coupled with <a href="http://www.graphviz.org/content/dot-language">DOT</a>, a simple domain-specific
language for describing graph structures by defining the nodes, edges,
and various attributes attached to them, like labels.)</p>

<a name="Hooking.up.the.JS.source"></a>
<h3>Hooking up the JS source</h3>

<p>Since this is using (heavy duty) javascript, you are not likely to
want to put the supporting source code inline in your web page.
Instead, you will need to load it up, either:</p>

<ol>
<li><p>from the original <a href="src=" title="https://github.com/mdaines/viz.js/releases/download/0.0.3/viz.js">source site</a>, or</p></li>
<li><p>in a server-side local copy of the file that you deploy alongside
your content
(e.g. put it into the <code>_source/javascripts/</code> directory,
if you are using Octopress for a blog like this one).</p></li>
</ol>


<p>I recommend the latter route, since the linked github repository is
outside of your control, and if it dissapears, you lose the rendering
and your page is broken.</p>

<p>After you have selected your source for the code, you need to
make your page load it up, via a <code>script</code> tag invocation,
like: <code>&lt;script src="http://blog.pnkfx.org/javascripts/viz.js" charset="utf-8"&gt;&lt;/script&gt;;</code></p>

<p>This script can take a while to load. You may want to insert a warning,
like this one, before the <code>script</code> invocation.</p>

<script src="http://blog.pnkfx.org/javascripts/viz.js" charset="utf-8"></script>


<a name="Injecting.generated.SVG.into.the.document"></a>
<h3>Injecting generated SVG into the document</h3>

<p>Once the script is loaded, you can start using inline Javascript to
render graphviz-style descriptions of directed graphs to SVG within
the page.</p>

<p>The smallest example of this given in the <code>viz.js</code> documentation
does this by dynamically adding to the <code>innerHTML</code> property:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>  <span class="nt">&lt;script&gt;</span>
</span><span class='line'>    <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">+=</span> <span class="s2">&quot;&lt;p&gt;Sample addition.&lt;/p&gt;&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">+=</span> <span class="nx">Viz</span><span class="p">(</span><span class="s2">&quot;digraph { a -&gt; b; }&quot;</span><span class="p">,</span> <span class="s2">&quot;svg&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="nt">&lt;/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>The above &ldquo;works&rdquo; (even in the context of an Octopress blog post), but
it is a rather brute-force approach. Plus, the resulting composition
of the blog text with the graphics added at the end is not likely to
please you nor your audience.</p>

<p>We can do better: Add a content-less <code>div</code> tag (or <code>p</code> tag, et
cetera), and then search for that element in a <code>script</code> block that
will add our picture to the inner HTML for that tag.</p>

<p>Here is a concrete illustration of the idea (that does not use
Graphviz or <code>viz.js</code>):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;target_anchor0&quot;</span><span class="nt">&gt;&lt;/div&gt;</span>
</span><span class='line'><span class="nt">&lt;script&gt;</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">elem</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;target_anchor0&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">elem</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="s2">&quot;This text was injected.&quot;</span><span class="p">;</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>




<div id="target_anchor0"></div>


<script>
    var elem = document.getElementById("target_anchor0");
    elem.innerHTML = "This text was injected.";
</script>


<p>So, now that we know how to insert HTML into our document (even in the
context of the markdown source for a blog post), let us dive into how
to combine that with Graphviz, via <code>viz.js</code>.</p>

<a name="L.code.dot_source..code..holds.DOT.source"></a>
<h3><code>dot_source</code> holds DOT source</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;target_anchor1&quot;</span><span class="nt">&gt;&lt;/div&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;script&gt;</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">dot_source</span> <span class="o">=</span> <span class="s1">&#39;digraph { rankdir=&quot;LR&quot;; bgcolor=&quot;transparent&quot;; a -&gt; b -&gt; c; }&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">elem</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;target_anchor1&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">elem</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">Viz</span><span class="p">(</span><span class="nx">dot_source</span><span class="p">,</span> <span class="s2">&quot;svg&quot;</span><span class="p">);</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>The contents of <code>dot_source</code> make up a DOT program:</p>

<ul>
<li><p><code>digraph</code> means we are making a directed graph,</p></li>
<li><p><code>rankdir="LR"</code> means we want the nodes to prefer horizontal left-to-right layout (the default is to have them vertically stacked top-to-bottom),</p></li>
<li><p><code>bgcolor="transparent"</code> means we want a transparent background (the default is white, which is fine but a little offputting for this site),</p></li>
<li><p><code>a -&gt; b</code> means &ldquo;I want an edge coming out of <code>a</code> and into <code>b</code>&rdquo;; you can chain them together as shown in <code>a -&gt; b -&gt; c</code>.</p></li>
</ul>


<p>Here is how that ends up rendering:</p>

<div id="target_anchor1"></div>


<script>
    var dot_source = 'digraph { rankdir="LR"; bgcolor="transparent"; a -> b -> c; }';
    var elem = document.getElementById("target_anchor1");
    elem.innerHTML = Viz(dot_source, "svg");
</script>


<p>It turns out that the generated SVG is actually pretty readable.  That
is, I am able to use &ldquo;Inspect Element&rdquo; in my web browser, and I see
there that the SVG element is actually made up of many <code>g</code> elements
that have each had their <code>class</code> attribute set according to their
role: the whole graph has <code>class="graph"</code>, and then each node and edge
is assigned <code>"node1"</code>, <code>"node2"</code>, <code>"edge1"</code>, <code>"node3"</code>, <code>"edge2"</code>.
(There are also comments embedded in the generated SVG above each
element, so that one can map the element back to the node or edge
in the original <code>dot_source</code> text.)</p>

<p>That is how to use <code>viz.js</code> to embed graphs described via <a href="http://www.graphviz.org/content/dot-language">DOT</a>.</p>

<p>This can be especially useful if you are making a dynamic page where
the user can inject their own graph descriptions, and you want <code>viz.js</code>
to do the heavy lifting of deciding how to lay out the nodes.</p>

<a name="Controlling.node.layout"></a>
<h3>Controlling node layout</h3>

<p>But what if we want more control over the layout of the picture
elements?</p>

<p>For example, one might want more control over layout to
ensure that there is a easy-to-see correspondence between a series of
pictures, or if there is a structural symmetry that is easier to see
if the layout is also symmetrical.</p>

<p>Consider the following example graph:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;p</span> <span class="na">id=</span><span class="s">&quot;target_anchor2&quot;</span><span class="nt">&gt;</span>Symmetric structure but asymmetric layout: <span class="nt">&lt;/p&gt;</span>
</span><span class='line'><span class="nt">&lt;script&gt;</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">dot_source</span> <span class="o">=</span> <span class="s1">&#39;digraph { rankdir=&quot;LR&quot;; bgcolor=&quot;transparent&quot;; a -&gt; b -&gt; c -&gt; e; b -&gt; d -&gt; e -&gt; a; }&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">elem</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;target_anchor2&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">elem</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">Viz</span><span class="p">(</span><span class="nx">dot_source</span><span class="p">,</span> <span class="s2">&quot;svg&quot;</span><span class="p">);</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>




<p id="target_anchor2">Symmetric structure but asymmetric layout: </p>


<script>
    var dot_source = 'digraph { rankdir="LR"; bgcolor="transparent"; a -> b -> c -> e; b -> d -> e -> a; }';
    var elem = document.getElementById("target_anchor2");
    elem.innerHTML = Viz(dot_source, "svg");
</script>


<p>There are a number of options at this point. We could abandon Graphviz (and <code>viz.js</code>),
and do our diagrams directly in SVG. But, assuming we want to stay within the confines
of <code>viz.js</code>, there are a few things we <em>can</em> do.</p>

<p>First, we can specify initial node positions by adding a <code>pos</code> attribute to
each node that needs it. The default layout engine (called <code>dot</code>) just
ignores such attributes, but other engines, such as the <code>neato</code> layout,
will incorporate such information.</p>

<p>One can switch the layout engine via an argument to the <code>Viz</code> function, but I will instead do it
by setting an attribute in the graph itself.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;p</span> <span class="na">id=</span><span class="s">&quot;target_anchor3&quot;</span><span class="nt">&gt;&lt;/p&gt;</span>
</span><span class='line'><span class="nt">&lt;script&gt;</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">dot_source</span> <span class="o">=</span> <span class="s1">&#39;digraph { rankdir=&quot;LR&quot;; bgcolor=&quot;transparent&quot;;&#39;</span>
</span><span class='line'>    <span class="c1">// Start of the layout selection code</span>
</span><span class='line'>    <span class="nx">dot_source</span> <span class="o">+=</span> <span class="s1">&#39;layout=&quot;neato&quot;; inputscale=72;&#39;</span> <span class="c1">// specifying &quot;neato&quot; layout to allow init position specification</span>
</span><span class='line'>    <span class="nx">dot_source</span> <span class="o">+=</span> <span class="s1">&#39;overlap=&quot;false&quot;;&#39;</span> <span class="c1">// if you leave this out, the engine may put nodes in overlapping spots</span>
</span><span class='line'>    <span class="nx">dot_source</span> <span class="o">+=</span> <span class="s1">&#39;start=0;&#39;</span> <span class="c1">// seed the RNG (to ensure consistent results)</span>
</span><span class='line'>    <span class="c1">// End of the layout selection code</span>
</span><span class='line'>    <span class="nx">dot_source</span> <span class="o">+=</span> <span class="s1">&#39;a -&gt; b -&gt; c -&gt; e; b -&gt; d -&gt; e -&gt; a;&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">dot_source</span> <span class="o">+=</span> <span class="s1">&#39; }&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">elem</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;target_anchor3&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">elem</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">Viz</span><span class="p">(</span><span class="nx">dot_source</span><span class="p">,</span> <span class="s2">&quot;svg&quot;</span><span class="p">);</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>




<p id="target_anchor3"></p>


<script>
    var dot_source = 'digraph { rankdir="LR"; bgcolor="transparent";'
    // Start of the layout selection code
    dot_source += 'layout="neato"; inputscale=72;' // specifying "neato" layout to allow init position specification
    dot_source += 'overlap="false";' // if you leave this out, the engine may put nodes in overlapping spots
    dot_source += 'start=0;' // seed the RNG (to ensure consistent results)
    // End of the layout selection code
    dot_source += 'a -> b -> c -> e; b -> d -> e -> a;';
    dot_source += ' }';
    var elem = document.getElementById("target_anchor3");
    elem.innerHTML = Viz(dot_source, "svg");
</script>


<p>As you can see, we definitely have a different node layout. It is not
yet directly illustrating the mirror symmetry of the graph structure,
though. To achieve that, we could put the <code>a</code> node inside of a
diamond shape formed by { <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code> }.</p>

<p>We can specify node positions by adding separate declarations for
each of the individual nodes, and then adding <code>pos</code> attributes
for each.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>dot_source += &#39;b [pos=&quot;0,40&quot;]; a [pos=&quot;100,40&quot;]; c [pos=&quot;160,80&quot;];&#39;
</span><span class='line'>dot_source += &#39;d [pos=&quot;160,0&quot;]; e [pos=&quot;220,40&quot;];&#39;
</span></code></pre></td></tr></table></div></figure>




<p id="target_anchor4"></p>


<script>
    var dot_source = 'digraph { rankdir="LR"; bgcolor="transparent";'
    // Start of the layout selection code
    dot_source += 'layout="neato"; inputscale=72;' // specifying "neato" layout to allow init position specification
    dot_source += 'overlap="false";' // if you leave this out, the engine may put nodes in overlapping spots
    dot_source += 'start=0;' // seed the RNG (to ensure consistent results)
    // End of the layout selection code
    // Start of the node positioning code
    dot_source += 'b [pos="0,40"]; a [pos="100,40"]; c [pos="160,80"];'
    dot_source += 'd [pos="160,0"]; e [pos="220,40"];'
    // End of the node positioning code
    dot_source += 'a -> b -> c -> e; b -> d -> e -> a;';
    dot_source += ' }';
    var elem = document.getElementById("target_anchor4");
    elem.innerHTML = Viz(dot_source, "svg");
</script>


<p><em>That</em> shows the mirror symmetry of the graph.</p>

<p>The careful reader may have noticed an oddity in the above rendering: I had specified
that <code>a</code> have an x-coordinate of 100, while the corresponding x-coordinate for <code>c</code> and <code>d</code> is 160; but
in the rendering, all three of the nodes fall on a vertical line sharing the same x-coordinate.
What happened?</p>

<p>The answer is that the input node positions are by default only as
<em>initial</em> values; the layout engine may still choose to adjust them in
order to &ldquo;improve&rdquo; the layout according to its internal heuristics.</p>

<p>We can override this by <em>pinning</em> the nodes in place. An individual node can be pinned by
putting an exclamation point after the coordinate in its <code>pos</code> attribute, or equivalently by
setting the nodes <code>pin</code> attribute to <code>true</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>dot_source += &#39;b [pos=&quot;0,40&quot;]; a [pos=&quot;100,40!&quot;]; c [pos=&quot;160,80!&quot;];&#39;
</span><span class='line'>dot_source += &#39;d [pos=&quot;160,0!&quot;]; e [pos=&quot;220,40&quot;];&#39;
</span></code></pre></td></tr></table></div></figure>




<p id="target_anchor5"></p>


<script>
    var dot_source = 'digraph { rankdir="LR"; bgcolor="transparent";'
    // Start of the layout selection code
    dot_source += 'layout="neato"; inputscale=72;' // specifying "neato" layout to allow init position specification
    dot_source += 'overlap="false";' // if you leave this out, the engine may put nodes in overlapping spots
    dot_source += 'start=0;' // seed the RNG (to ensure consistent results)
    // End of the layout selection code
    // Start of the node positioning code
    dot_source += 'b [pos="0,40"]; a [pos="100,40!"]; c [pos="160,80!"];'
    dot_source += 'd [pos="160,0!"]; e [pos="220,40"];'
    // End of the node positioning code
    dot_source += 'a -> b -> c -> e; b -> d -> e -> a;';
    dot_source += ' }';
    var elem = document.getElementById("target_anchor5");
    elem.innerHTML = Viz(dot_source,"svg");
</script>


<p>Now we can see that <code>a</code>, <code>c</code>, and <code>d</code> are all pinned in place, and the resulting layout
is perhaps not as nice.</p>

<p>In particular, the <code>a -&gt; b</code> edge does not even have enough room
for its arrow head. We could fix this by pinning the <code>b</code> node in place as well,
but an alternative is to encourage graphviz to put more space between the nodes
via the <code>sep</code> attribute.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>dot_source += &#39;sep=0.2;&#39; // treat each node as 1.2 times larger than it is
</span></code></pre></td></tr></table></div></figure>




<p id="target_anchor6"></p>


<script>
    var dot_source = 'digraph { rankdir="LR"; bgcolor="transparent";'
    // Start of the layout selection code
    dot_source += 'layout="neato"; inputscale=72;' // specifying "neato" layout to allow init position specification
    dot_source += 'overlap="false";' // if you leave this out, the engine may put nodes in overlapping spots
    dot_source += 'sep=0.2;' // treat each node as 1.2 times larger than it is
    dot_source += 'start=0;' // seed the RNG (to ensure consistent results)
    // End of the layout selection code
    // Start of the node positioning code
    dot_source += 'b [pos="0,40"]; a [pos="100,40!"]; c [pos="160,80!"];'
    dot_source += 'd [pos="160,0!"]; e [pos="220,40"];'
    // End of the node positioning code
    dot_source += 'a -> b -> c -> e; b -> d -> e -> a;';
    dot_source += ' }';
    var elem = document.getElementById("target_anchor6");
    elem.innerHTML = Viz(dot_source, "svg");
</script>


<p>That is a pretty legible graph. Of course, the code to describe it is
quite a bit more complex than our <a href="#target_anchor2">original code</a>;
hopefully I will not feel the need to specify node placement too
often.</p>

<a name="Edge.attributes"></a>
<h3>Edge attributes</h3>

<p>Above we saw examples of node attributes, which can be used to adjust the
node placement and rendering. (The <a href="http://www.graphviz.org/doc/info/attrs.html">family of attributes</a> is much larger,
and includes ways to specify shapes, color, label text, et cetera.)</p>

<p>Graphviz also offers the ability to customize attributes for each
<em>edge</em>.  This can also be useful for influencing layout.
In particular, the <code>len</code> attribute can specify a preferred edge length
(ignored by the <code>dot</code> layout), and the <code>weight</code> attribute can be
increased to encourage the edge to be shorter (or, when <code>len</code> is
specified and relevant, to encourage that edge length to more closely
approximate <code>len</code>).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;p</span> <span class="na">id=</span><span class="s">&quot;target_anchor7a&quot;</span><span class="nt">&gt;&lt;/p&gt;</span>
</span><span class='line'><span class="nt">&lt;script&gt;</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">dot_source</span> <span class="o">=</span> <span class="s1">&#39;digraph { rankdir=&quot;LR&quot;; bgcolor=&quot;transparent&quot;;&#39;</span>
</span><span class='line'>    <span class="nx">dot_source</span> <span class="o">+=</span> <span class="s1">&#39;edge [weight=2];&#39;</span>
</span><span class='line'>    <span class="nx">dot_source</span> <span class="o">+=</span> <span class="s1">&#39;a -&gt; b -&gt; c -&gt; e; b -&gt; d -&gt; e -&gt; a [weight=1];&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">dot_source</span> <span class="o">+=</span> <span class="s1">&#39; }&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">elem</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;target_anchor7a&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">elem</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">Viz</span><span class="p">(</span><span class="nx">dot_source</span><span class="p">,</span> <span class="s2">&quot;svg&quot;</span><span class="p">);</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here we have used <code>edge [weight=2]</code> to specify a default weight of 2 for all edges,
and then we override that weight for the <code>e -&gt; a</code> edge (and just that edge).
(Note: The <code>dot</code> layout requires integral values for <code>weight</code>.)</p>

<p>Here is the effect of this:</p>

<p id="target_anchor7a"></p>


<script>
    var dot_source = 'digraph { rankdir="LR"; bgcolor="transparent";'
    dot_source += 'edge [weight=2];'
    dot_source += 'a -> b -> c -> e; b -> d -> e -> a [weight=1];';
    dot_source += ' }';
    var elem = document.getElementById("target_anchor7a");
    elem.innerHTML = Viz(dot_source, "svg");
</script>


<p>Look at that! We can see the mirror symmetry of the graph (depending on
how much we are willing to squint with regards to that <code>e -&gt; a</code> edge),
but we did not have to do any layout hacking.</p>

<p>Unsurprisingly, a different weight-assignment may yield a different layout.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>dot_source += &#39;   { edge [weight=10]; a -&gt; b; e -&gt; a; }&#39;
</span><span class='line'>dot_source += &#39;   { edge [weight=1]; b -&gt; c -&gt; e; b -&gt; d -&gt; e; }&#39;
</span></code></pre></td></tr></table></div></figure>


<p>Here we have moved a portion of the edges into a subgraph, so that we
can override their default <code>weight</code> as a group.</p>

<p id="target_anchor7b"></p>


<script>
    var dot_source = 'digraph { rankdir="LR"; bgcolor="transparent";'
    dot_source += '   { edge [weight=10]; a -> b; e -> a; }'
    dot_source += '   { edge [weight=1]; b -> c -> e; b -> d -> e; }'
    dot_source += ' }';
    var elem = document.getElementById("target_anchor7b");
    elem.innerHTML = Viz(dot_source, "svg");
</script>


<p>Perhaps more surprising, changing node introduction order in the
source can also affect the layout.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>dot_source += &#39;   b -&gt; a [dir=&quot;back&quot;]; a -&gt; e [dir=&quot;back&quot;];&#39;
</span><span class='line'>dot_source += &#39;   b -&gt; c -&gt; e; b -&gt; d -&gt; e;&#39;
</span></code></pre></td></tr></table></div></figure>


<p>Here, we introduce the nodes <code>b</code> then <code>a</code> then <code>e</code> to encourage them
to be laid out horizontally in that order, then apply the <code>dir</code>
attribute so that the edge between them has its direction reversed.</p>

<p id="target_anchor7c"></p>


<script>
    var dot_source = 'digraph { rankdir="LR"; bgcolor="transparent";'
    dot_source += '   b -> a [dir="back"]; a -> e [dir="back"];'
    dot_source += '   b -> c -> e; b -> d -> e;'
    dot_source += ' }';
    var elem = document.getElementById("target_anchor7c");
    elem.innerHTML = Viz(dot_source, "svg");
</script>


<p>Finally, if you want to describe a path through the graph, you can
highlight the edges of the path by overriding their <code>color</code> and
<code>penwidth</code> attribute.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;p</span> <span class="na">id=</span><span class="s">&quot;target_anchor8&quot;</span><span class="nt">&gt;&lt;/p&gt;</span>
</span><span class='line'><span class="nt">&lt;script&gt;</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">dot_source</span> <span class="o">=</span> <span class="s1">&#39;digraph { rankdir=&quot;LR&quot;; bgcolor=&quot;transparent&quot;;&#39;</span>
</span><span class='line'>    <span class="nx">dot_source</span> <span class="o">+=</span> <span class="s1">&#39;edge [weight=2];&#39;</span>
</span><span class='line'>    <span class="nx">dot_source</span> <span class="o">+=</span> <span class="s1">&#39;a -&gt; b -&gt; d;&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">dot_source</span> <span class="o">+=</span> <span class="s1">&#39;{ edge [color=&quot;red&quot;,penwidth=&quot;3.0&quot;]; b -&gt; c -&gt; e -&gt; a [weight=1] }&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">dot_source</span> <span class="o">+=</span> <span class="s1">&#39; }&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">elem</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;target_anchor8&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">elem</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">Viz</span><span class="p">(</span><span class="nx">dot_source</span><span class="p">,</span> <span class="s2">&quot;svg&quot;</span><span class="p">);</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here again we have used a subgraph to reduce the annotation burden.</p>

<p id="target_anchor8"></p>


<script>
    var dot_source = 'digraph { rankdir="LR"; bgcolor="transparent";'
    dot_source += 'edge [weight=2];'
    dot_source += 'a -> b -> d -> e;';
    dot_source += '{ edge [color="red",penwidth="3.0"]; b -> c -> e -> a [weight=1] }';
    dot_source += ' }';
    var elem = document.getElementById("target_anchor8");
    elem.innerHTML = Viz(dot_source, "svg");
</script>


<p>(One can use subgraphs for a number of other tricks, such as forcing all
nodes in the subgraph to fall into the same <code>rank</code>, which can be another
useful technique for encouraging particular layouts.)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[An insight regarding DST grammar for Rust]]></title>
    <link href="http://blog.pnkfx.org/blog/2014/03/13/an-insight-regarding-dst-grammar-for-rust/"/>
    <updated>2014-03-13T07:04:00+01:00</updated>
    <id>http://blog.pnkfx.org/blog/2014/03/13/an-insight-regarding-dst-grammar-for-rust</id>
    <content type="html"><![CDATA[<p>Executive summary: <code>type</code> = <code>unsized</code> ⊎ <code>sized</code>, so we should use
<code>type</code> as our generalization marker, not <code>unsized</code>.</p>

<!-- more -->


<ul>
<li><a href="#background_dst">Background: Dynamically Sized Types (DST)</a></li>
<li><a href="#the_insight">The Insight: <code>type</code> is a better generalization marker</a></li>
<li><a href="#the_examples">Examples ported from DST, Take 5</a></li>
</ul>


<a name="L.a.id..background_dst..Background:.Dynamically.Sized.Types..DST...a."></a>
<h2><a id="background_dst">Background: Dynamically Sized Types (DST)</a></h2>

<p>The Rust team has been discussing incorporating &ldquo;dynamically-sized
types&rdquo; into the static semantics for Rust.  Essentially the idea is to
allow code to describe and name static types whose size is only known
at Runtime.  E.g. the integer vector <code>[int, ..5]</code> is known at compile
time to have five elements, and is considered (statically) sized,
while the vector <code>[int]</code> has unknown size at compile time, and so that
type is called unsized.</p>

<p><a href="http://smallcultfollowing.com/babysteps/blog/2013/04/30/dynamically-sized-types/">There</a>
is <a href="http://smallcultfollowing.com/babysteps/blog/2013/06/06/reducing-dst-annotation/">a</a>
series <a href="http://smallcultfollowing.com/babysteps/blog/2013/11/26/thoughts-on-dst-1/">of</a>
blog <a href="http://smallcultfollowing.com/babysteps/blog/2013/11/27/thoughts-on-dst-2">posts</a>
about <a href="http://smallcultfollowing.com/babysteps/blog/2013/11/27/thoughts-on-dst-3/">dynamically</a>
sized <a href="http://smallcultfollowing.com/babysteps/blog/2013/12/02/thoughts-on-dst-4/">types</a>
on <a href="http://smallcultfollowing.com/babysteps/blog/2014/01/05/dst-take-5/">niko&rsquo;s</a>
blog.
So I will not dive into the details too much here</p>

<p>The main points are that the compiler wants to know whether a type is
meant to always have a static size, or if it can potentially be
unsized.  In a language without type polymorphism, this might be easy
to determine directly from the parsed type expression (such as in the
vector examples I gave at the outset).  But once you add polymorphism,
things get a litle harder for the compiler.</p>

<p>Anyway, the plan drafted in Niko&rsquo;s
<a href="http://smallcultfollowing.com/babysteps/blog/2014/01/05/dst-take-5/">&ldquo;DST, Take 5&rdquo;</a>
is to add an <code>unsized</code> keyword, and then use it as a marker to make
certain spots more general than they are by default.  The reasoning
here is that in the common case, you want a type parameter to
represent a sized type.  (Since there are certain operations you
cannot do with a value of an unsized type, such copying the value into
some other location, the compiler needs to know its size statically so
that it can allocate an appopriate amount of space for it.)</p>

<p>So under that scheme, to write type parameter of most general type,
e.g. for a <code>struct</code> definition that ends with an unsized field,
you need to write:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">struct</span> <span class="n">Named</span><span class="o">&lt;</span><span class="kr">unsized</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">name</span><span class="o">:</span> <span class="o">~</span><span class="kt">str</span><span class="p">,</span>
</span><span class='line'>    <span class="n">payload</span><span class="o">:</span> <span class="n">T</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Accepts solely *sized* Named&lt;T&gt;.</span>
</span><span class='line'><span class="k">fn</span> <span class="n">foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Named</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Accepts both sized and *unsized* Named&lt;T&gt;</span>
</span><span class='line'><span class="k">fn</span> <span class="n">bar</span><span class="o">&lt;</span><span class="kr">unsized</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Named</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>That is, you need to use what I will call a &ldquo;generalization&rdquo; marker at
the spot where you bind a type variable, to indicate that the domain of
that type variable is more general than the common-case default of
a sized type.</p>

<p>For defining a trait that can be implemented on any possible type,
including unsized ones, you would need to use the <code>unsized</code> keyword
somewhere there as well.  &ldquo;DST, Take 5&rdquo; proposed
<code>trait Foo&lt;unsized Self&gt; : NormalBounds { ... }</code>
(or <code>trait Foo : unsized + NormalBounds { ... }</code>, but this is broken for
various reasons).
I had been suggesting <code>unsized trait Foo : NormalBounds { ... }</code>,
which Niko rightly objected to (since it is not the trait that is
unsized, but rather potentially its Self type).
Over the Rust work week last week I suggested
<code>trait Foo for unsized : NormalBounds</code> { &hellip; }, which I think is the first
suggestion that Niko and myself could both stomach.  (The reasoning
behind the latter suggestion is that we write <code>impl Trait for
SelfType</code>, so it makes sense to put the generalization marker into the
same position, i.e. filling the placeholder in: <code>Trait for _</code>.)</p>

<a name="L.a.id..the_insight..The.Insight:..code.type..code..is.a.better.generalization.marker..a."></a>
<h2><a id="the_insight">The Insight: <code>type</code> is a better generalization marker</a></h2>

<p>One of the concerns that Niko has pointed out to me is that it is easy
to (mis)read <code>unsized T</code> as saying &ldquo;<code>T</code> must be unsized&rdquo;.  But that is not
what it is saying; it is saying &ldquo;<code>T</code> <em>can</em> be unsized&rdquo;; you can still pass in
a sized type for <code>T</code>.</p>

<p>I was reflecting on that this morning, and I realized something:
The whole point of DST is to partition the type universe into (Sized ⊎ Unsized).
So if you want this construct to be more self-documenting, the
generalization marker should be using some name to describe that union
(Sized ⊎ Unsized), rather than the name <code>unsized</code>.</p>

<p>But we already have a very appropriate name for that union: <code>type</code>!</p>

<p>So that started me thinking: Why don&rsquo;t we use <code>type</code> as our generalization marker?
So the definition of <code>bar</code> in the example above would be written</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">bar</span><span class="o">&lt;</span><span class="k">type</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Named</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>In fact, this can have a very simple explanation: If we keep the <code>Sized</code> trait bound,
then you can just say that</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">...){</span> <span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>desugars to</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">foo</span><span class="o">&lt;</span><span class="k">type</span> <span class="n">T</span><span class="o">:</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>and in general, any type variable formal binding <code>&lt;T:Bounds&gt;</code> desugars
to <code>&lt;type T:Sized+Bounds&gt;</code></p>

<p>I admit, when I first wrote this, I said &ldquo;hmm, this looks a bit like
C++, is that a problem?&rdquo;  But I&rsquo;m coming to like it.  The biggest
problem I can foresee is that a developer might be confused about when
they are suppposed to write <code>foo&lt;type T&gt;</code> versus <code>foo&lt;T&gt;</code>.  But chances
are that someone who does not understand the distinction will <em>not</em>
suffer if they just guess the answer; if they over-generalize, either:</p>

<ul>
<li><p>the code will compile successfully anyway, in which case there is
no harm, except perhaps w.r.t. forward-compatibility of their
library when they may have wished they had imposed the <code>Sized</code>
bound, or</p></li>
<li><p>the compiler will flag a problem in their code, in which case
hopefully our error messages will suggest to add a <code>:Sized</code> bound
or to just not use <code>type</code> in the binding for <code>T</code>.</p></li>
</ul>


<p>If they under-generalize, then they (or their library&rsquo;s clients) will
discover the problem when they apply <code>foo</code>.</p>

<p>For the trait case, it is a little less obvious what to do.
I think we could likewise write:
<code>trait Foo for type : NormalBounds</code>
for the maximally general case.
<code>trait Foo : NormalBounds</code> would then desugar to
<code>trait Foo for type : Sized + NormalBounds</code></p>

<p>So the point is that you would only use the <code>type</code> keyword when you
wanted to explicitly say &ldquo;I am generalizing over <em>all</em> types, not just
sized ones&rdquo;, and thus are opting into the additional constraints that
that scenario presents.</p>

<p>This approach wouldn&rsquo;t be so palatable under earlier envisioned
designs for DST where e.g. you were restricted to write explicitly
<code>unsized struct S { ... }</code> for structs that could end up being
unsized.  But at this point I think we have collectively decided that
such a restriction is unnecessary and undesired, so there is no worry
that someone might end up having to write <code>type struct S { ... }</code>,
which definitely looks nonsensical.</p>

<p>There is another potential advantage to this approach that I have not
explored much yet: we could also add an <code>Unsized</code> trait bound, and
allow people to write <code>&lt;type X:Unsized&gt;</code> for when they want to
restrict <code>X</code> to unsized types alone.  I am not sure whether this is
actual value in this, but it does not seem absurd to put in a special
case in the coherence checker to allow one to write
<code>impl&lt;X:Sized&gt; SomeTrait for X { ... }</code>
and
<code>impl&lt;X:Unsized&gt; SomeTrait for X { ... }</code>
in order to get full coverage of <code>SomeTrait</code> for all types.</p>

<p>Finally, another obvious (though obviously post Rust 1.0) direction
that this approach suggests is that if we decide to add
parameterization over constants, we can likewise use the <code>const</code>
keyword in the spot where I have written the generalization marker
<code>type</code>, e.g.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">foo</span><span class="o">&lt;</span><span class="kr">const</span> <span class="n">N</span><span class="o">:</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nums</span><span class="o">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="kt">f64</span><span class="p">,</span> <span class="p">..</span><span class="n">N</span><span class="p">])</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>(In this case <code>const</code> would not be a generalization marker but instead
a <em>kind</em> marker, since it is changing the domain of the parameter from
being that of a type to being some value within a type.)</p>

<a name="L.a.id..the_examples..Examples.ported.from.DST..Take.5..a."></a>
<h2><a id="the_examples">Examples ported from DST, Take 5</a></h2>

<p>Here are the ported definitions of <code>Rc</code> and <code>RcData</code>.
(Update: had to turn off syntax highlighting to work-around a rendering bug on <code>*</code>.)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>struct Rc&lt;type T&gt; {
</span><span class='line'>    ptr: \*RcData&lt;T&gt;,
</span><span class='line'>    // (a dummy field, just for illustrative purposes)
</span><span class='line'>    dummy: uint,
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct RcData&lt;type T&gt; {
</span><span class='line'>    ref_count: uint,
</span><span class='line'>
</span><span class='line'>    #[max_alignment]
</span><span class='line'>    data: T
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>impl&lt;type T&gt; Drop for Rc&lt;T&gt; {
</span><span class='line'>    fn drop&lt;&#39;a&gt;(&amp;&#39;a mut self) {
</span><span class='line'>        unsafe {
</span><span class='line'>            intrinsics::drop(&amp;mut (*self.ptr).data);
</span><span class='line'>            libc::free(self.ptr);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>Here is the <code>ImmDeref</code> example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">trait</span> <span class="n">ImmDeref</span><span class="o">&lt;</span><span class="k">type</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fn</span> <span class="n">deref</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">&#39;a</span> <span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">&amp;</span><span class="n">&#39;a</span> <span class="n">T</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">impl</span><span class="o">&lt;</span><span class="k">type</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">ImmDeref</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fn</span> <span class="n">deref</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">&#39;a</span> <span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">&amp;</span><span class="n">&#39;a</span> <span class="n">T</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">unsafe</span> <span class="p">{</span>
</span><span class='line'>            <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">ptr</span><span class="p">).</span><span class="n">data</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>(I think I need a wider variety of examples, but this is good enough for now.)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Updating Octopress post-Mavericks upgrade.]]></title>
    <link href="http://blog.pnkfx.org/blog/2014/03/13/meta-updating-octopress-post-mavericks-upgrade/"/>
    <updated>2014-03-13T06:18:00+01:00</updated>
    <id>http://blog.pnkfx.org/blog/2014/03/13/meta-updating-octopress-post-mavericks-upgrade</id>
    <content type="html"><![CDATA[<p>I decided this morning to write a blog post related to Rust.  I have
not posted to this blog in months, and in the meantime I had upgraded
this computer at home to Mac OS X Mavericks (10.9.2).</p>

<p>So of course my existing set of commands for Octopress workflow did
not work.</p>

<!-- more -->


<p>At first there were dependencies like <code>chunky_png-1.2.7</code> that had to
be satisfied (re-installed, I assume; I am pretty sure I blew away my
previous Homebrew setup during the upgrade; I do not know how much
that overlaps with Ruby&rsquo;s package management system).</p>

<p>The few step was just blind following of the suggestions made by my
tools: <code>rake</code> suggests to run <code>bundle install</code>, and I comply.  And the results
seem promising:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>% rake generate
</span><span class='line'>Could not find chunky_png-1.2.7 in any of the sources
</span><span class='line'>Run \`bundle install\` to install missing gems.
</span><span class='line'>% bundle install
</span><span class='line'>Fetching gem metadata from http://rubygems.org/.......
</span><span class='line'>Fetching gem metadata from http://rubygems.org/..
</span><span class='line'>Using rake (0.9.6)
</span><span class='line'>Using RedCloth (4.2.9)
</span><span class='line'>Installing chunky_png (1.2.7)
</span><span class='line'>Using fast-stemmer (1.0.2)
</span><span class='line'>Using classifier (1.3.3)
</span><span class='line'>Using fssm (0.2.10)
</span><span class='line'>Installing sass (3.2.5)
</span><span class='line'>Using compass (0.12.2)
</span><span class='line'>Using directory_watcher (1.4.1)
</span><span class='line'>Installing haml (3.1.8)
</span><span class='line'>Installing kramdown (0.13.8)
</span><span class='line'>Installing liquid (2.3.0)
</span><span class='line'>Using syntax (1.0.0)
</span><span class='line'>Using maruku (0.6.1)
</span><span class='line'>Using posix-spawn (0.3.6)
</span><span class='line'>Using yajl-ruby (1.1.0)
</span><span class='line'>Installing pygments.rb (0.3.7)
</span><span class='line'>Installing jekyll (0.12.0)
</span><span class='line'>Installing rack (1.4.5)
</span><span class='line'>Installing rack-protection (1.3.2)
</span><span class='line'>Using rb-fsevent (0.9.3)
</span><span class='line'>Using rdiscount (1.6.8)
</span><span class='line'>Using redcarpet (2.2.2)
</span><span class='line'>Using rubypants (0.2.0)
</span><span class='line'>Installing tilt (1.3.3)
</span><span class='line'>Installing sinatra (1.3.4)
</span><span class='line'>Installing stringex (1.4.0)
</span><span class='line'>Using bundler (1.3.5)
</span><span class='line'>Your bundle is complete!
</span><span class='line'>Use \`bundle show [gemname]\` to see where a bundled gem is installed.
</span></code></pre></td></tr></table></div></figure>


<p>But I
balked on the second step:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>% rake generate
</span><span class='line'>rake aborted!
</span><span class='line'>You have already activated rake 10.1.0, but your Gemfile requires rake 0.9.6. Using bundle exec may solve this.
</span><span class='line'>/Users/pnkfelix/Dev/Sites/pnkfx-blog/Rakefile:2:in \`&lt;top (required)&gt;&#39;
</span><span class='line'>(See full trace by running task with --trace)
</span><span class='line'>% bundle exec
</span><span class='line'>bundler: exec needs a command to run
</span></code></pre></td></tr></table></div></figure>


<p>I did not understand what <code>bundle exec</code> meant here, so I did not do the &ldquo;obvious thing&rdquo;, which apparently is to re-run generate but within bundle, like so:
<code>% bundle exec rake generate</code></p>

<p>Instead I fumbled around trying to figure out what my situation was
with respect to <code>rake:</code> do I need to downgrade to a previous version?
Or do I need to upgraade its subcomponents, and/or my whole site
configuration?</p>

<p>The first things I learned from a couple web interactions:</p>

<p>From <a href="http://stackoverflow.com/questions/17474969/you-have-already-activated-rake-0-9-6-but-your-gemfile-requires-rake-10-1-0-us">stackoverflow</a>
I learned:</p>

<ul>
<li>You can find out what version(s) of a gem you have install, with
the relatively obvious <code>gem list</code> command:</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>% gem list rake
</span><span class='line'>
</span><span class='line'>*** LOCAL GEMS ***
</span><span class='line'>
</span><span class='line'>rake (10.1.0, 0.9.6)
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>You can also remove particular versions of a gem, with the <code>gem
uninstall</code> command:</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>% gem uninstall rake
</span><span class='line'>
</span><span class='line'>Select gem to uninstall:
</span><span class='line'> 1. rake-0.9.6
</span><span class='line'> 2. rake-10.1.0
</span><span class='line'> 3. All versions
</span><span class='line'>&gt; 1
</span><span class='line'>Successfully uninstalled rake-0.9.6
</span></code></pre></td></tr></table></div></figure>


<p>But these facts and this process did not actually help, because I
still needed <code>rake-0.9.6</code> for my site configuration, for some reason I
have not yet determined (mostly due to lack of trying).</p>

<p>I then did some more guessing and followed some false paths, like
reinstalling the <code>bundler</code> gem, uninstalling and reinstalling rake
(which effectively led to me replacing rake-10.1.0 with rake-10.1.1).</p>

<p>At some point I ran this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>% bundle update rake
</span><span class='line'>Fetching gem metadata from http://rubygems.org/........
</span><span class='line'>Fetching gem metadata from http://rubygems.org/..
</span><span class='line'>Resolving dependencies...
</span><span class='line'>Installing rake (0.9.6)
</span><span class='line'>Using RedCloth (4.2.9)
</span><span class='line'>Using chunky_png (1.2.7)
</span><span class='line'>Using fast-stemmer (1.0.2)
</span><span class='line'>Using classifier (1.3.3)
</span><span class='line'>Using fssm (0.2.10)
</span><span class='line'>Using sass (3.2.5)
</span><span class='line'>Using compass (0.12.2)
</span><span class='line'>Using directory_watcher (1.4.1)
</span><span class='line'>Using haml (3.1.8)
</span><span class='line'>Using kramdown (0.13.8)
</span><span class='line'>Using liquid (2.3.0)
</span><span class='line'>Using syntax (1.0.0)
</span><span class='line'>Using maruku (0.6.1)
</span><span class='line'>Using posix-spawn (0.3.6)
</span><span class='line'>Using yajl-ruby (1.1.0)
</span><span class='line'>Using pygments.rb (0.3.7)
</span><span class='line'>Using jekyll (0.12.0)
</span><span class='line'>Using rack (1.4.5)
</span><span class='line'>Using rack-protection (1.3.2)
</span><span class='line'>Using rb-fsevent (0.9.3)
</span><span class='line'>Using rdiscount (1.6.8)
</span><span class='line'>Using redcarpet (2.2.2)
</span><span class='line'>Using rubypants (0.2.0)
</span><span class='line'>Using tilt (1.3.3)
</span><span class='line'>Using sinatra (1.3.4)
</span><span class='line'>Using stringex (1.4.0)
</span><span class='line'>Using bundler (1.3.5)
</span><span class='line'>Your bundle is updated!
</span></code></pre></td></tr></table></div></figure>


<p>but I still got the error:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>% rake generate
</span><span class='line'>rake aborted!
</span><span class='line'>You have already activated rake 10.1.1, but your Gemfile requires rake 0.9.6. Using bundle exec may solve this.
</span><span class='line'>/Users/pnkfelix/Dev/Sites/pnkfx-blog/Rakefile:2:in \`&lt;top (required)&gt;&#39;
</span><span class='line'>(See full trace by running task with --trace)
</span></code></pre></td></tr></table></div></figure>


<p>and this is when I finally saw that I had to do:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>% bundle exec rake generate
</span></code></pre></td></tr></table></div></figure>


<p>Except that this did not solve everything:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>% bundle exec rake generate
</span><span class='line'>## Generating Site with Jekyll
</span><span class='line'>unchanged sass/screen.scss
</span><span class='line'>Configuration from /Users/pnkfelix/Dev/Sites/pnkfx-blog/_config.yml
</span><span class='line'>Building site: source -&gt; public
</span><span class='line'>YAML Exception reading 2013-04-12-better-command-completion-in-bash-aka-resolving-zsh-envy.markdown: invalid byte sequence in US-ASCII
</span><span class='line'>/Users/pnkfelix/Dev/Sites/pnkfx-blog/plugins/backtick_code_block.rb:13:in \`gsub&#39;: invalid byte sequence in US-ASCII (ArgumentError)
</span><span class='line'>  from /Users/pnkfelix/Dev/Sites/pnkfx-blog/plugins/backtick_code_block.rb:13:in \`render_code_block\&#39;
</span><span class='line'>  from /Users/pnkfelix/Dev/Sites/pnkfx-blog/plugins/octopress_filters.rb:12:in \`pre_filter&#39;
</span><span class='line'>  from /Users/pnkfelix/Dev/Sites/pnkfx-blog/plugins/octopress_filters.rb:28:in \`pre_render&#39;
</span><span class='line'>  from /Users/pnkfelix/Dev/Sites/pnkfx-blog/plugins/post_filters.rb:112:in \`block in pre_render&#39;
</span><span class='line'>  from /Users/pnkfelix/Dev/Sites/pnkfx-blog/plugins/post_filters.rb:111:in \`each&#39;
</span><span class='line'>  from /Users/pnkfelix/Dev/Sites/pnkfx-blog/plugins/post_filters.rb:111:in \`pre_render&#39;
</span><span class='line'>  from /Users/pnkfelix/Dev/Sites/pnkfx-blog/plugins/post_filters.rb:166:in \`do_layout&#39;
</span><span class='line'>  from /Users/pnkfelix/.rbenv/versions/1.9.3-p194/lib/ruby/gems/1.9.1/gems/jekyll-0.12.0/lib/jekyll/post.rb:195:in \`render&#39;
</span><span class='line'>  from /Users/pnkfelix/.rbenv/versions/1.9.3-p194/lib/ruby/gems/1.9.1/gems/jekyll-0.12.0/lib/jekyll/site.rb:200:in \`block in render&#39;
</span><span class='line'>  from /Users/pnkfelix/.rbenv/versions/1.9.3-p194/lib/ruby/gems/1.9.1/gems/jekyll-0.12.0/lib/jekyll/site.rb:199:in \`each&#39;
</span><span class='line'>  from /Users/pnkfelix/.rbenv/versions/1.9.3-p194/lib/ruby/gems/1.9.1/gems/jekyll-0.12.0/lib/jekyll/site.rb:199:in \`render&#39;
</span><span class='line'>  from /Users/pnkfelix/.rbenv/versions/1.9.3-p194/lib/ruby/gems/1.9.1/gems/jekyll-0.12.0/lib/jekyll/site.rb:41:in \`process&#39;
</span><span class='line'>  from /Users/pnkfelix/.rbenv/versions/1.9.3-p194/lib/ruby/gems/1.9.1/gems/jekyll-0.12.0/bin/jekyll:264:in \`&lt;top (required)&gt;&#39;
</span><span class='line'>  from /Users/pnkfelix/.rbenv/versions/1.9.3-p194/bin/jekyll:23:in \`load&#39;
</span><span class='line'>  from /Users/pnkfelix/.rbenv/versions/1.9.3-p194/bin/jekyll:23:in \`&lt;main&gt;&#39;
</span></code></pre></td></tr></table></div></figure>


<p>Another web search brought me to a <a href="http://otfusion.org/blog/2013/10/27/os-x-mavericks/">post by a fellow Mavericks user</a> who seems to have a similar attitude to my own about ruby development.
And from that I found the full command I needed</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>% LANG=en_US.utf-8 bundle exec rake generate
</span><span class='line'>## Generating Site with Jekyll
</span><span class='line'>unchanged sass/screen.scss
</span><span class='line'>Configuration from /Users/pnkfelix/Dev/Sites/pnkfx-blog/_config.yml
</span><span class='line'>Building site: source -&gt; public
</span><span class='line'>Successfully generated site: source -&gt; public
</span></code></pre></td></tr></table></div></figure>


<p>And here we are!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Detective Work on Rust Closures]]></title>
    <link href="http://blog.pnkfx.org/blog/2013/06/07/detective-work-on-rust-closures/"/>
    <updated>2013-06-07T10:17:00+02:00</updated>
    <id>http://blog.pnkfx.org/blog/2013/06/07/detective-work-on-rust-closures</id>
    <content type="html"><![CDATA[<ul>
<li><a href="#background_fns">Background: Closures (recurring and otherwise)</a></li>
<li><a href="#background_dst">Background: DST</a></li>
<li><a href="#the_problem">The Problem: DST and Closures</a>

<ul>
<li><a href="#is_fn_too_ugly">Is fn~ too ugly?</a></li>
<li><a href="#leveraging_proc">Leveraging a proc keyword/expression</a></li>
<li><a href="#other_ways_to_proc">Other ways to express proc</a>

<ul>
<li><a href="#digression_on_macros">A Personal Digression on Macros</a></li>
</ul>
</li>
<li><a href="#more_followup_on_procs_and_fns">More followups on procs and fns</a></li>
</ul>
</li>
<li><a href="#where_are_we">So where are we?</a></li>
</ul>


<p>I have recently been trying to keep myself abreast of a flurry of
discussion about reforming the design of Rust closures.  Niko has a
series of blog posts (<a href="http://smallcultfollowing.com/babysteps/blog/2013/04/30/the-case-of-the-recurring-closure/">1</a>, <a href="http://smallcultfollowing.com/babysteps/blog/2013/04/30/dynamically-sized-types/">2</a>, <a href="http://smallcultfollowing.com/babysteps/blog/2013/05/13/recurring-closures-and-dynamically-sized-types/">3</a>, <a href="http://smallcultfollowing.com/babysteps/blog/2013/05/13/mutable-fn-alternatives/">4</a>, <a href="http://smallcultfollowing.com/babysteps/blog/2013/05/14/procedures/">5</a>, <a href="http://smallcultfollowing.com/babysteps/blog/2013/05/30/removing-procs/">6</a>, <a href="http://smallcultfollowing.com/babysteps/blog/2013/06/03/more-on-fns/">7</a>, <a href="http://smallcultfollowing.com/babysteps/blog/2013/06/06/reducing-dst-annotation/">8</a>); the
content of some of those posts were further discussed at Rust team
meetings (<a href="https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-04-30">11</a>, <a href="https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-05-07">12</a>, <a href="https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-05-14">13</a>, <a href="https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-05-21">14</a>, <a href="https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-05-28">15</a>, <a href="https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-06-04">16</a>), and there have been some
more formalized proposals with their own set of discussions: (<a href="https://github.com/mozilla/rust/wiki/Proposal-for-closure-reform">9</a>,
<a href="https://github.com/mozilla/rust/wiki/Proposal-for-closure-reform-%28specific%29">10</a>).</p>

<p>There are also associated github issues (<a href="https://github.com/mozilla/rust/issues/2202">17</a>, <a href="https://github.com/mozilla/rust/issues/3569">18</a>, <a href="https://github.com/mozilla/rust/issues/6308">19</a>), though
without sufficient context the discussion in the github issues may not
always be intelligible.</p>

<p>Some of the links above are more about &ldquo;Dynamically Sized Types&rdquo;
(DST), a related topic, as we shall see.</p>

<p>This post is my attempt to condense all of this information down into
something where I can see all the pieces at once, and discard the
red herrings along the way.</p>

<!-- more -->


<a name="L.a.id..background_fns..Background:.Closures..recurring.and.otherwise...a."></a>
<h2><a id="background_fns">Background: Closures (recurring and otherwise)</a></h2>

<p>In Rust circa version 0.6, closures have three categories according to
the type system (<code>&amp;fn</code>, <code>@fn</code>, and <code>~fn</code>), but <a href="http://smallcultfollowing.com/babysteps/blog/2013/05/14/procedures/">as Niko describes</a>,
they can be divided into two kinds: by-reference closures and copying
closures.  By-reference closures are also referred to as
stack-allocated closures or sometimes &ldquo;stack closure.&rdquo;
(There is also a orthogonal division of <code>once</code> closures, versus
closures that can be invoked more than once; some of these things are,
to my knowledge, only part of planned future implementation.  Niko
discusses them in the blog posts but I&rsquo;m mostly sidestep them here.)</p>

<p>As Niko states in the first paragraph of <a href="http://smallcultfollowing.com/babysteps/blog/2013/04/30/the-case-of-the-recurring-closure/">1</a>, a stack closure is
allocated on the stack, and can refer to and manipulate the local
variables of the enclosing stack frame (by reference).</p>

<p>In Rust (as of version 0.6), one creates a stack-allocated closure by
writing an expression <code>|x ...| { ... }</code> within an expression context
dictating that it wants a closure of <code>&amp;fn</code> type.  Analogously, a
closure allocated on the exchange-heap is expressed by putting the
expression into a context of <code>~fn</code> type, et cetera.  Since a
stack-allocated closure is currently expressed solely by use of <code>&amp;fn</code>
type, Niko often uses the term <code>&amp;fn</code> closure synonymously with
stack-allocated closure.</p>

<p>(However, Niko also points out (first section of
<a href="http://smallcultfollowing.com/babysteps/blog/2013/05/14/procedures/">&ldquo;Procedures, Continued&rdquo;</a>) that one can borrow a <code>@fn</code> or <code>~fn</code> to
a <code>&amp;fn</code>, so the type does <em>not</em> tell you whether you actually have a
by-reference or a copying-closure.)</p>

<p>Here is the example of an unsound function that Niko described in
his <a href="http://smallcultfollowing.com/babysteps/blog/2013/04/30/the-case-of-the-recurring-closure/">Case of the Recurring Closure</a> post from 2013-04-30,
making use of higher-order functions to express a fixed-point
combinator:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">struct</span> <span class="n">R</span><span class="o">&lt;</span><span class="nl">&#39;self</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// This struct is needed to create the</span>
</span><span class='line'>    <span class="c1">// otherwise infinite type of a fn that</span>
</span><span class='line'>    <span class="c1">// accepts itself as argument:</span>
</span><span class='line'>    <span class="n">c</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">&#39;self</span> <span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">R</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">innocent_looking_victim</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="k">mut</span> <span class="n">vec</span> <span class="o">=</span> <span class="o">~</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
</span><span class='line'>    <span class="n">conspirator</span><span class="p">(</span><span class="o">|</span><span class="n">f</span><span class="o">|</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">vec</span><span class="p">.</span><span class="n">len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">vec</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
</span><span class='line'>            <span class="k">for</span> <span class="n">vec</span><span class="p">.</span><span class="n">each</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">f</span><span class="p">.</span><span class="n">c</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">})</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">conspirator</span><span class="p">(</span><span class="n">f</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">R</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">R</span> <span class="p">{</span><span class="n">c</span><span class="o">:</span> <span class="n">f</span><span class="p">};</span>
</span><span class='line'>    <span class="n">f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>As Niko explains, the vector <code>vec</code> is mutated while being traversed by
an iterator; this is illegal.  The closure <code>|f| { ... }</code> captures
a reference to <code>vec</code>, and Rust&rsquo;s borrow checker is not treating the argument
<code>f</code> as a potential source of aliases to <code>vec</code>, even though it does alias
<code>vec</code> because <code>f</code> ends up being bound to the closure <code>|f| { ... }</code>.</p>

<p>An important detail here is that the closure in question is
a stack-allocated closure.</p>

<p>Niko has described his solution to this problem in <a href="http://smallcultfollowing.com/babysteps/blog/2013/04/30/the-case-of-the-recurring-closure/">1</a>; it would
entail adding some new rules about how <code>&amp;fn</code> closures are invoked
and passed as parameters.  One of the main changes imposed by his
solution was that <code>&amp;fn</code> closures would become non-aliasable;
this would ensure that one could not express the Y-combinator.
The restriction to ensure <code>&amp;fn</code> closures are unaliasable interacts
with other proposals, as we shall see.
(Note that Rust does have a way of expressing a non-aliasable pointer
to <code>T</code> for any <code>T</code>: <code>&amp;mut T</code>.)</p>

<a name="L.a.id..background_dst..Background:.DST..a."></a>
<h2><a id="background_dst">Background: DST</a></h2>

<p>The heart of the Dynamically Sized Types proposal is the discrepancy
described in Niko&rsquo;s <a href="http://smallcultfollowing.com/babysteps/blog/2013/04/30/dynamically-sized-types/">DST, Revisited</a> post from 2013-04-30
(published contemporaneously with <a href="http://smallcultfollowing.com/babysteps/blog/2013/04/30/the-case-of-the-recurring-closure/">Case of the Recurring Closure</a>).
Niko has been wrestling with the idea for a while, as one can see on
his posts from <a href="http://smallcultfollowing.com/babysteps/blog/2012/04/23/vectors-strings-and-slices/">2012-04-23</a> and <a href="http://smallcultfollowing.com/babysteps/blog/2012/04/27/in-favor-of-types-of-unknown-size/">2012-04-27</a>.</p>

<p>In Rust, vectors (and strings, which we will treat as a special case
of vectors) come in the following forms:</p>

<ul>
<li>dynamic-length: heap-allocated, carries its length N as part of its
record structure.  Consists of some amount of meta-data, including
the length word, followed by the inline-allocated array of N
elements.  Expressed as <code>~[T]</code> and <code>@[T]</code> in Rust.</li>
<li>slice: represents a substring of a vector; consists of two words: a
pointer to the payload, and a length bound.  Expressed as <code>&amp;[T]</code> in Rust.</li>
<li>fixed-length: represents exactly N elements, where N is statically
tracked at compile-time.  Consists of just the array of elements,
<code>T[N]</code>, and nothing more.  Expressed as <code>[T, ..N]</code> in Rust.</li>
</ul>


<p>Niko points out that a slice&rsquo;s two-word representation is quite
different from the representations of the other variants.  His
proposal is to unify the first two representations, by laying out
<code>~[T]</code> and <code>@[T]</code> as pairs of words (a pointer to the boxed elements
array, and a length).
(Niko claimed that this makes a <code>~[T]</code> and <code>@[T]</code> valid slices, &ldquo;apart
from the box header&rdquo;; it seems to me like the box header is quite
relevant here, unless the idea is that when you coerce a <code>@[T]</code> to a
slice, you increment the pointer value accordingly&hellip;)</p>

<p>Then, Niko classifies the types of Rust into two categories: Sized and
Unsized; i.e., size is statically known, versus size is tracked at
runtime (maybe the letters S and R would have been more appropriate
than S and U&hellip;).  The &ldquo;unsized types&rdquo; cannot themselves be assigned
as types of local variables, and you cannot have vectors of elements
of unsized type; this all stems from the fact that &ldquo;unsized types&rdquo; do
not have a static size.
(The &ldquo;unsized types&rdquo; are arguably not actually types; we might be
well-served by referring to them as &ldquo;pretypes&rdquo; or something).
But pointers to unsized types are valid types.  Such pointers are the
pairs of words discussed above, aka &ldquo;fat pointers&rdquo;: <code>(payload, meta)</code>,
where <code>payload</code> is the pointer to the data, and <code>meta</code> is the
descriptor that includes some way to determine the size of the payload
(to support runtime bounds checks).</p>

<p>The fact that &ldquo;unsized types&rdquo; need to be treated specially leads to a
complication, discussed further in the post; how to differentiate
between type-parameterized code that works on both kinds of types,
versus typed-parameterized code that solely operates on sized types.
The method proposed in the post is to express the distinction via a
trait bound: the <code>Sized</code> bound would restrict the type parameter to
one of statically-known size; you would not be able to express
types like <code>[X, ..3]</code> (a fixed-length vector of 3 X'es), unless you
include the bound <code>X:Sized</code>.  (There is more on this restriction
and ways to ease it further down.)</p>

<p>One of the benefits of DST that Niko proposes early on is that
Traits and closures are other instances of unsized types, so that
Rust&rsquo;s type hierarchy could be presented uniformly like so:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="n">T</span> <span class="o">=</span> <span class="n">S</span>            <span class="c1">// sized types</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">U</span>            <span class="c1">// unsized types</span>
</span><span class='line'><span class="n">S</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">&#39;r</span> <span class="n">T</span>        <span class="c1">// region ptr</span>
</span><span class='line'>  <span class="o">|</span> <span class="o">@</span><span class="n">T</span>           <span class="c1">// managed ptr</span>
</span><span class='line'>  <span class="o">|</span> <span class="o">~</span><span class="n">T</span>           <span class="c1">// unique ptr</span>
</span><span class='line'>  <span class="o">|</span> <span class="p">[</span><span class="n">S</span><span class="p">,</span> <span class="p">..</span><span class="n">N</span><span class="p">]</span>     <span class="c1">// fixed-length array</span>
</span><span class='line'>  <span class="o">|</span> <span class="kt">uint</span>         <span class="c1">// scalars</span>
</span><span class='line'>  <span class="o">|</span> <span class="p">...</span>
</span><span class='line'><span class="n">U</span> <span class="o">=</span> <span class="p">[</span><span class="n">S</span><span class="p">]</span>          <span class="c1">// vectors</span>
</span><span class='line'>  <span class="o">|</span> <span class="kt">str</span>          <span class="c1">// string</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">Trait</span>        <span class="c1">// existential (&quot;exists S:Trait.S&quot;)</span>
</span><span class='line'>  <span class="o">|</span> <span class="k">fn</span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">S</span>
</span></code></pre></td></tr></table></div></figure>


<p>(Note that the actual types assigned to expressions would be instances
of <code>S</code> according to this grammar.)</p>

<a name="L.a.id..the_problem..The.Problem:.DST.and.Closures..a."></a>
<h2><a id="the_problem">The Problem: DST and Closures</a></h2>

<p>So, from the &ldquo;Case of the Recurring Closure&rdquo;, we saw that
<code>&amp;fn</code> closures were to become non-copyable.
But under the DST proposal, generic code should be able to treat <code>&amp;T</code>
the same for all <code>T</code>, <em>including</em> when <code>T</code> is some <code>fn(S*) -&gt; S</code>.
These two criteria are not compatible; Niko has lots more explanation
in his corresponding post:
<a href="http://smallcultfollowing.com/babysteps/blog/2013/05/13/recurring-closures-and-dynamically-sized-types/">&ldquo;Recurring Closures and Dynamically Sized Types&rdquo;</a>,
from 2013-05-13.</p>

<p>Niko&rsquo;s immediate proposals to resolve this were either:</p>

<ul>
<li>we write <code>&amp;mut fn</code> instead of <code>&amp;fn</code>.  <code>&amp;mut T</code> for all <code>T</code>
(including <code>fn (S ...) -&gt; S</code>) is forced to be unaliasable by the
borrow-checker, and so the hole goes away, or,</li>
<li>we change notation, and move the sigils for closures <em>after</em> the fn,
side-stepping the special treatment of <code>&amp;fn</code> versus <code>&amp;T</code> by getting
rid of <code>&amp;fn</code> and replacing it with <code>fn&amp;</code>.</li>
</ul>


<a name="L.a.id..is_fn_too_ugly..Is.fn..too.ugly...a."></a>
<h3><a id="is_fn_too_ugly">Is fn~ too ugly?</a></h3>

<p>Niko at first favored the latter, then he wrote a second post,
<a href="http://smallcultfollowing.com/babysteps/blog/2013/05/13/mutable-fn-alternatives/">&ldquo;Mutable Fn Alternatives&rdquo;</a> on 2013-05-13,
which reconsidered whether <code>fn~</code> is too ugly, and included
new survey of the options:</p>

<ul>
<li>Maybe <code>&amp;mut fn</code> is not that bad, or</li>
<li>Maybe make <em>all</em> closures borrowed (i.e. stack-allocated), removing
the need for any sigil, or</li>
<li>Make <code>fn</code> denote stack-allocated closures,
and replace <code>fn~</code> with a new keyword, like <code>proc</code>.  (This is a variation
on the previous bullet.)</li>
</ul>


<p>For the second and third bullets, the main point is: If you need to
capture state in a manner that cannot be expressed via the available
options (stack-allocated closure, or a <code>proc</code>, if present), then you
have to use an trait instead (i.e. an object or a record).
(I personally am not thrilled about losing the option of using
closures to express combinator libraries, a use case for <code>fn@</code>.)</p>

<a name="L.a.id..leveraging_proc..Leveraging.a.proc.keyword.expression..a."></a>
<h3><a id="leveraging_proc">Leveraging a proc keyword/expression</a></h3>

<p>Then a third post, <a href="http://smallcultfollowing.com/babysteps/blog/2013/05/14/procedures/">&ldquo;Procedures, Continued&rdquo;</a> from
2013-05-15, refined the <code>proc</code> proposal a bit further.  As stated in
the background on closures, Rust has by-reference closures and copying
closures; the choice of which variant to construct is based on the
type expected by the context of the <code>|x ...| { ... }</code> expression.
In this post, Niko proposed that the distinction here deserves a
starker line between the two forms.  (In that post, he proposed both a
revision to English jargon and also to the Rust syntax; I&rsquo;m going to
focus solely on the Rust syntax changes, and let those guide the
changes to my own jargon here.)</p>

<p>So Niko proposes distinguishing a by-reference closure from a copying
closure via keywords.  A stack-allocated closure would be constructed
solely via <code>fn</code>, and a copying closure would be constructed solely via
<code>proc</code>.  While discussing this proposal henceforth, I will refer to a
by-reference closure as an <code>fn</code>-closure and a copying closure as a
<code>proc</code>-closure.</p>

<p>The type hierarchy that Niko then provides for this is:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="n">T</span> <span class="o">=</span> <span class="n">S</span>               <span class="c1">// sized types</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">U</span>               <span class="c1">// unsized types</span>
</span><span class='line'><span class="n">S</span> <span class="o">=</span> <span class="k">fn</span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">S</span>     <span class="c1">// closures (*)</span>
</span><span class='line'>  <span class="o">|</span> <span class="o">&amp;</span><span class="n">&#39;r</span> <span class="n">T</span>           <span class="c1">// region ptr</span>
</span><span class='line'>  <span class="o">|</span> <span class="o">@</span><span class="n">T</span>              <span class="c1">// managed ptr</span>
</span><span class='line'>  <span class="o">|</span> <span class="o">~</span><span class="n">T</span>              <span class="c1">// unique ptr</span>
</span><span class='line'>  <span class="o">|</span> <span class="p">[</span><span class="n">S</span><span class="p">,</span> <span class="p">..</span><span class="n">N</span><span class="p">]</span>        <span class="c1">// fixed-length array</span>
</span><span class='line'>  <span class="o">|</span> <span class="kt">uint</span>            <span class="c1">// scalars</span>
</span><span class='line'>  <span class="o">|</span> <span class="p">...</span>
</span><span class='line'><span class="n">U</span> <span class="o">=</span> <span class="p">[</span><span class="n">S</span><span class="p">]</span>             <span class="c1">// vectors</span>
</span><span class='line'>  <span class="o">|</span> <span class="kt">str</span>             <span class="c1">// string</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">Trait</span>           <span class="c1">// existential (&quot;exists S:Trait.S&quot;)</span>
</span><span class='line'>  <span class="o">|</span> <span class="k">proc</span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">S</span>   <span class="c1">// procedures (*)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now, <code>fn</code>-closures are considered <em>sized types</em>, because they are
always represented by two words: a (borrowed) environment pointer (to
the stack in Niko&rsquo;s proposal, though perhaps it could be generalized
to point elsewhere) and a function pointer.  <code>proc</code>-closures are
<em>unsized types</em>, because their copied lexical environment is of some
dynamically-determined size that they must carry in their record
structure.</p>

<p>In this version of the proposal, <code>proc</code> can now be allocated to either
the exchange heap (<code>~proc</code>) or the task heap (<code>@proc</code>).  So this
brings back the ability to express combinator libraries.</p>

<p>Niko&rsquo;s post provides further detail, such as dissection of the <code>fn</code>
and <code>proc</code> closure types (which include important details like the
lifetime and trait <em>bounds</em> for the closed-over variables; this is
important since with a separate keyword, it is now reasonable for
different defaults to be chosen for two cases; useful for making the
common case succinct).  He also describes a couple variations on the
theme, including modeling <code>proc</code> closures via traits (i.e. boxed
traits are objects carrying virtual method dispatch tables), and then
expressing them via a <code>proc!</code> macro (which means they could be left
out of the core language).</p>

<a name="L.a.id..other_ways_to_proc..Other.ways.to.express.proc..a."></a>
<h3><a id="other_ways_to_proc">Other ways to express proc</a></h3>

<p>In his next post, <a href="http://smallcultfollowing.com/babysteps/blog/2013/05/30/removing-procs/">&ldquo;Removing Procs&rdquo;</a>, Niko elaborates further
on the idea that <code>proc</code> need not be supported in the language at all.
Stack-allocated <code>fn</code>-closures would remain, expressed via <code>fn(S ...) -&gt; T</code>,
and the language already supports raw (environment-less) function
pointers via <code>extern "ABI" fn(S ...) -&gt; T</code>.
Niko points out two ways to re-express copying closures:</p>

<ol>
<li>One could pass around function pointers along with
records that carry the captured environment; this is basically
<a href="http://matt.might.net/articles/closure-conversion/">lambda-lifting</a> (the variant that turns the free variables
into fields of a single environment structure, rather than passing each
variable as a separate parameter), or</li>
<li>As stated earlier, (boxed) traits can used to express copying
closures.</li>
</ol>


<p>Niko surveyed how these patterns would look in his post, by considered
existing use cases of <code>@fn</code> and <code>~fn</code> in the standard libraries,
namely task spawning and futures.  Without more language support, the
lambda-lifting transformation requires that one list the captures
variables (at least once, though further repetitions can be avoided
via appropriate macro definitions).  I am personally hesistant to
approve of removing non stack-allocated closures wholesale, though
<em>if</em> it turns out that capture clauses are essentially unavoidable (or
if understanding behavior without them is unworkable), then my main
problem with the <code>proc!</code> macros (the explicit list of free variables)
would go away.</p>

<p>Alternatively, if the macro system were somehow extended to allow a
macro to query an expression for its free variables, then that might
help.</p>

<a name="L.a.id..digression_on_macros..A.Personal.Digression.on.Macros..a."></a>
<h4><a id="digression_on_macros">A Personal Digression on Macros</a></h4>

<p>Actually, this latter idea brings up a problem with the explicit list
of captured variables that I had not thought of before: some macros
may intentionally inject references to free variables, where the
injected free variables are not meant to be part of the public
interface of the macro (i.e., the macro is enforcing some protocol of
usage, and the variable is meant to be otherwise private to the module
where the macro is defined).  I know we do not currently have macros
exported from modules, but I thought it was supposed to be part of the
long term plans for Rust.</p>

<ul>
<li><p>Do we intend to disallow the use of such macros within copying closures?</p></li>
<li><p>Will we require the modules to expose those variable names, solely
so that they can be included on the lists of free variables?</p></li>
<li><p>Or, if a macro could query an expression for its free variables
(where even module-private identifiers might be included on such
a list), that might help impose a usage discipline that would
support a <code>proc!</code> macro,</p></li>
<li><p>Or, this whole example might serve as an argument for keeping
copying closures as a primitive linguistic construct.</p></li>
</ul>


<p>Okay, end of digression.</p>

<a name="L.a.id..more_followup_on_procs_and_fns..More.followups.on.procs.and.fns..a."></a>
<h3><a id="more_followup_on_procs_and_fns">More followups on procs and fns</a></h3>

<p>A few days passed, then Niko had a fourth post,
<a href="http://smallcultfollowing.com/babysteps/blog/2013/06/03/more-on-fns/">&ldquo;More on Fns&rdquo;</a>, from 2013-06-03.
This proposal renamed of a proposed <code>Task</code> trait to <code>Thunk</code>, since
Niko felt that the concept at hand (an encapsulated function and the
parameters it needs) is better reflected by that name.</p>

<p>More importantly, given the immediately preceding digression, the form
<code>thunk { ... }</code> would automatically determine the captured variables
instead of requiring an explicit list; this sidesteps the whole question
of how to handle macros that inject new free variable references.</p>

<p>There is then much discussion of whether or not to support <code>once fn</code>s,
which I won&rsquo;t summarize here.  The important detail of the post is
that we do not necessarily have to list the captured variables
explicitly.</p>

<p>After a few more days, Niko had a followup on the related topic of
dynamically sized types (DST), <a href="http://smallcultfollowing.com/babysteps/blog/2013/06/06/reducing-dst-annotation/">&ldquo;Reducing DST Annotation&rdquo;</a>, from
2013-06-06.  It took into account an <a href="https://github.com/mozilla/rust/issues/6308#issuecomment-18880575">investigation</a> by Ben Blum
on the implications of a <code>Sized</code> trait bound.  This led to Niko
exploring some alternatives to adopting DST with a <code>Sized</code> bound:</p>

<ul>
<li>Abandon DST altogether: Niko summarizes what DST still buys us, but
also points out where it does not live up to its original promises.</li>
<li>Make type parameters default to <code>Sized</code>, and adopt a different
syntactic mechanism to distinguish <code>Sized</code> from <code>Unsized</code> (such as
a keyword).</li>
<li>Use some sort of inference: the type-checker can use properties
of a function&rsquo;s parameter list to provide feedback
on whether the type parameter has an implicit <code>Sized</code> bound.
(Niko wonders if this approach is too clever; I am inclined to
 affirm that it is.)</li>
</ul>


<a name="L.a.id..where_are_we..So.where.are.we...a."></a>
<h2><a id="where_are_we">So where are we?</a></h2>

<p>The above summarizes the series of blog posts from Niko.  I had hoped
to get through the actual proposals (and maybe also the team meeting
notes), but at this point, it is late enough in the day and this post
is long enough that I think I will stop here.</p>

<p>The language is young, and I am a Rust novice.  So, grains of salt
for everyone:</p>

<ul>
<li>My intuition is that we should leave in copying closures in some form.</li>
<li>The <code>thunk { ... }</code> expression might suffice, but &hellip; I am not yet
convinced that I would be satisfied using boxed traits
to express the cases that need input arguments (like combinator
libraries).</li>
<li>I am not thrilled by the idea of writing out lists of free
variables.  Of course, this is a systems programming language,
and such a list may simply be the simplest way to accomplish
certain goals (e.g. to indicate whether a referenced value
is moved or copied).</li>
<li>If we do require a list of free variables in our copying
<code>proc</code>/<code>thunk</code>/etc, please ensure that the question of free
variables injected by macro invocations is addressed.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Designing syntax for associated items in Rust]]></title>
    <link href="http://blog.pnkfx.org/blog/2013/04/22/designing-syntax-for-associated-items-in-rust/"/>
    <updated>2013-04-22T14:37:00+02:00</updated>
    <id>http://blog.pnkfx.org/blog/2013/04/22/designing-syntax-for-associated-items-in-rust</id>
    <content type="html"><![CDATA[<ul>
<li><a href="#background">Background</a>

<ul>
<li><a href="#encodingunpalatable">Encoding via parameters is unpalatable</a></li>
</ul>
</li>
<li><a href="#rustspec">Rust-specific issues</a>

<ul>
<li><a href="#nikoposts">Niko&rsquo;s blog posts</a></li>
<li><a href="#thinkbinding">Simpler syntax: What about binding?</a></li>
</ul>
</li>
<li><a href="#insight">Insight</a></li>
<li><a href="#proposal">The proposed syntax for associated items in Rust</a></li>
<li><a href="#futurework">What the proposal does not cover</a></li>
</ul>


<p>Executive summary: if you don&rsquo;t want or need the background information
or the discussion motivating the proposal, then just jump
straight to the <a href="#proposal">proposal</a> itself.</p>

<!-- more -->


<a name="L.a.id..background..Background..a."></a>
<h2><a id="background">Background</a></h2>

<p>Early in my experimentation with Rust, I thought a reasonable exercise
would be to take the simple C++ programs from
<a href="http://www.elementsofprogramming.com/">Elements of Programming</a> (Stepanov and McJones), which make heavy yet
disciplined use of abstraction and C++ templates to encode various
mathematical concepts.  The early chapters of the book use templates
rather than classes as the means of code reuse, so translating those
examples seemed like a good way to exercise Rust&rsquo;s generic type and
trait systems.</p>

<p>However, almost immediately after starting the experiment, I encountered
a problem: code that makes heavy use of C++ templates is quite likely
to use particular features of C++ templates that are not a universal
part of another language&rsquo;s generic type system.</p>

<p>In particular, the code from Elements of Programming (hereby
abbreviated &ldquo;EOP&rdquo; in this post) almost immediately makes use of
&ldquo;associated types&rdquo;, such as in the following definition for <code>distance</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="n">requires</span><span class="p">(</span><span class="n">Transformation</span><span class="p">(</span><span class="n">F</span><span class="p">))</span>
</span><span class='line'><span class="n">DistanceType</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="n">distance</span><span class="p">(</span><span class="n">Domain</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="n">x</span><span class="p">,</span> <span class="n">Domain</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="n">y</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// Precondition: $y$ is reachable from $x$ under $f$</span>
</span><span class='line'>    <span class="k">typedef</span> <span class="n">DistanceType</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="n">N</span><span class="p">;</span>
</span><span class='line'>    <span class="n">N</span> <span class="nf">n</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">x</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span><span class='line'>        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">N</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The interesting thing about the above code is that it is parameterized
over one type: <nobr><code>F</code>,</nobr> but it uses other type expressions within the body
of the procedure, namely:</p>

<ul>
<li><p><code>Domain(F)</code>: this is a <code>type -&gt; type</code> operator that, given a
Transformation (which we can think of as some type classifying a
set of <code>T -&gt; T</code> functions for some type <code>T</code>), returns <code>T</code>.</p></li>
<li><p><code>DistanceType(F)</code>: this is a <code>type -&gt; type</code> operator that, given a
Transformation, returns a numeric type (think <code>uint8_t</code>,
<code>uint32_t</code>, <code>uintptr_t</code>, <code>BigNum</code>, etc) suitable for counting the
minimum number of applications of the transformation necessary to
get from any particular <code>T</code> value to some other <code>T</code> value.</p></li>
</ul>


<p>(Operators like <code>DistanceType</code>, to my mind, only makes sense when you
 look at things simultaneously in terms of bytes of memory in the
 machine and also in terms of pure abstract mathematical values.  If
 you omit either perspective, then the operator appears either
 pointless or nonsensical.)</p>

<p>It also requires that <code>F</code> obeys a constraint, specified in the
<code>requires</code> clause; I am going to conveniently ignore this detail for
now.  (The C++ code for EOP even macro-expands <code>requires(..)</code> into whitespace,
so treating them as helpful comments for the time being is not absurd.)</p>

<p>Type expressions like <code>triple&lt;A, B, C&gt;</code> (assuming three type expressions
<code>A</code>, <code>B</code>, and <code>C</code>), are the bread-and-butter of any generic type
system.  But these <code>type -&gt; type</code> operators are interesting.  How are
they implemented?  Here is a snippet from <code>type_functions.h</code> in the
EOP source code distribution:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="n">requires</span><span class="p">(</span><span class="n">Transformation</span><span class="p">(</span><span class="n">F</span><span class="p">))</span>
</span><span class='line'><span class="k">struct</span> <span class="n">distance_type</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// If all transformations on a type T have the same distance type,</span>
</span><span class='line'><span class="c1">// then DistanceType(T) is defined and returns that type.</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// For any fixed-size type T, there is an integral type of the same</span>
</span><span class='line'><span class="c1">// size that is a valid distance type for T.</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define DistanceType(T) typename distance_type&lt; T &gt;::type</span>
</span></code></pre></td></tr></table></div></figure>


<p>This code is making use of a C-style macro to define a easy-to-read
interface for the <code>DistanceType</code> operator (the subset of C++ used
for EOP&rsquo;s textbook examples is meant to be LL(1)), but the implementation
of the operator is using C++&rsquo;s template system to define a partial
mapping from types to (integral) types.  One can add new entries to
this mapping by defining a new template instantiation of
<code>struct distance_type&lt;F&gt;</code>, as illustrated in <code>tests.h</code> for the following
transformation <code>gen_orbit</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">I</span><span class="p">,</span> <span class="k">typename</span> <span class="n">N</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="n">requires</span><span class="p">(</span><span class="n">Integer</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">Integer</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">DistanceType</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">=</span> <span class="n">N</span><span class="p">)</span>
</span><span class='line'><span class="k">struct</span> <span class="n">gen_orbit</span> <span class="c1">// transformation</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">gen_orbit_predicate</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'>    <span class="n">gen_orbit</span><span class="p">(</span><span class="n">I</span> <span class="n">x_0</span><span class="p">,</span> <span class="n">N</span> <span class="n">h</span><span class="p">,</span> <span class="n">N</span> <span class="n">c</span><span class="p">)</span> <span class="o">:</span> <span class="n">p</span><span class="p">(</span><span class="n">x_0</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Precondition: h &lt; N(MaximumValue(I)) &amp;&amp; c &lt; N(MaximumValue(I))</span>
</span><span class='line'>        <span class="c1">// Precondition: !negative(h) &amp;&amp; !negative(c)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">I</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="n">I</span> <span class="n">x</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">Assert</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span><span class='line'>        <span class="n">x</span> <span class="o">=</span> <span class="n">successor</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">p</span><span class="p">.</span><span class="n">x_0</span> <span class="o">+</span> <span class="n">I</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">h</span><span class="p">)</span> <span class="o">+</span> <span class="n">I</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">c</span><span class="p">))</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">x_0</span> <span class="o">+</span> <span class="n">I</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">h</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">I</span><span class="p">,</span> <span class="k">typename</span> <span class="n">N</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="n">requires</span><span class="p">(</span><span class="n">Integer</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">Integer</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">DistanceType</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">=</span> <span class="n">N</span><span class="p">)</span>
</span><span class='line'><span class="k">struct</span> <span class="n">distance_type</span><span class="o">&lt;</span> <span class="n">gen_orbit</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">typedef</span> <span class="n">N</span> <span class="n">type</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Thus, the definition of <code>gen_orbit</code> (including its instantiation of
<code>distance_type</code>) collaborates with the definition of <code>DistanceType</code> to
indicate that <code>DistanceType(gen_orbit&lt;I, N&gt;)</code> is <code>N</code>.  As one adds new
structs (classes) representing other transformations, one is expected
to instantiate <code>distance_type</code> (as well as a host of other
template-abstracted structs) accordingly.</p>

<hr />

<p>So, what&rsquo;s the problem here?  Well, Rust, much like Java, does not
provide a way to define general <code>type -&gt; type</code> mappings like
<code>DistanceType(F)</code>.</p>

<p>One can try to work around this via a code transformation and lift any
type of interest up to a generic class&rsquo;s parameter list, like this
example in Rust:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">trait</span> <span class="n">Transformation</span><span class="o">&lt;</span><span class="n">DISTANCETYPE</span><span class="p">,</span> <span class="n">DOMAIN</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fn</span> <span class="n">apply</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="o">:</span> <span class="n">DOMAIN</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DOMAIN</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>or if you prefer Java:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">interface</span> <span class="nc">Transformation</span><span class="o">&lt;</span><span class="n">DISTANCETYPE</span><span class="o">,</span> <span class="n">DOMAIN</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">DOMAIN</span> <span class="nf">apply</span><span class="o">(</span><span class="n">DOMAIN</span> <span class="n">elem</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>At first glance, one might think this does not look so bad; after all,
the <code>gen_orbit</code> struct similarly was parameterized over a domain <code>I</code>
and a distance type <code>N</code>.  However, the problem comes when one
then attempts to write a function like distance:</p>

<p>Rust:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">distance</span><span class="o">&lt;</span><span class="n">F</span><span class="o">:</span> <span class="n">Transformation</span><span class="o">&lt;</span><span class="n">DT</span><span class="p">,</span> <span class="n">DOM</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="o">???</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="o">???</span><span class="p">,</span> <span class="n">f</span><span class="o">:</span> <span class="n">F</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">???</span> <span class="p">{</span>
</span><span class='line'>    <span class="cm">/* ... */</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Java:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">F</span> <span class="kd">extends</span> <span class="n">Transformation</span><span class="o">&lt;</span><span class="n">DT</span><span class="o">,</span> <span class="n">DOM</span><span class="o">&gt;</span> <span class="o">???</span> <span class="n">distance</span><span class="o">(???</span> <span class="n">x</span><span class="o">,</span> <span class="o">???</span> <span class="n">y</span><span class="o">,</span> <span class="n">F</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="cm">/* ... */</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>What do we put in for the <code>???</code> portions?  We already established that
we do not have general <code>type -&gt; type</code> operators, so we cannot just
derive it form <code>F</code>.  And for that matter, where did <code>DT</code> and <code>DOM</code>
come from?  In Rust and Java, we cannot just make up fresh type
variables and then add constraints upon them after the fact.  The only
option is to make any type we wish to use an additional type parameter
to the generic method.</p>

<p>Rust:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">distance</span><span class="o">&lt;</span><span class="n">DT</span><span class="p">,</span> <span class="n">DOM</span><span class="p">,</span> <span class="n">F</span><span class="o">:</span> <span class="n">Transformation</span><span class="o">&lt;</span><span class="n">DT</span><span class="p">,</span> <span class="n">DOM</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">DOM</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="n">DOM</span><span class="p">,</span> <span class="n">f</span><span class="o">:</span> <span class="n">F</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DT</span> <span class="p">{</span>
</span><span class='line'>    <span class="cm">/* ... */</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Java:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">DT</span><span class="o">,</span> <span class="n">DOM</span><span class="o">,</span> <span class="n">F</span> <span class="kd">extends</span> <span class="n">Transformation</span><span class="o">&lt;</span><span class="n">DT</span><span class="o">,</span> <span class="n">DOM</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span><span class='line'>    <span class="n">DT</span> <span class="nf">distance</span><span class="o">(</span><span class="n">DOM</span> <span class="n">x</span><span class="o">,</span> <span class="n">DOM</span> <span class="n">y</span><span class="o">,</span> <span class="n">F</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="cm">/* ... */</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<a name="L.a.id..encodingunpalatable..Encoding.via.parameters.is.unpalatable..a."></a>
<h3><a id="encodingunpalatable">Encoding via parameters is unpalatable</a></h3>

<p>The Rust and Java results above are made barely readable by using
short (obscure) parameter names.  More troubling is the fact that this
pollution of the parameter list will bubble transitively backwards
through the callers of <code>distance</code> until we reach the point where <code>F</code>
is instantiated.  Any use of <code>Transformation</code> needs to be
parameterized in the same manner.</p>

<p>It also makes explicit instantiation of a parameterized method or
class quite painful.  (This pain is somewhat alleviated in the
presence of type-inference, at least in terms of what text ends up in
the final code, but I argue that that in this case the pain has in
fact been <em>shifted</em>: instead of having pain while reading the code,
one instead suffers when trying to wade through type-errors that
inevitably arise during the compile-edit cycle.)</p>

<p>If anything, the above presentation <em>understates</em> the problem, since:</p>

<ol>
<li><code>Transformation</code> has only one argument in its domain, and its codomain
 is the same as its domain; many real traits with associated types
 are each likely to require multiple parameters.</li>
<li>The above example has direct uses of <code>DOM</code> and <code>DT</code> in the domain
 and codomain, respectively, of <code>distance</code>.  However, <em>every</em> client
 of <code>Transformation</code> will be forced to be parameterized over <code>DOM</code>
 and <code>DT</code>; while it is likely that any client of <code>Transformation</code> is likely
 to need to refer to the type <code>DOM</code>, many are likely to not require
 use of the distance type <code>DT</code> in their public interface or even in
 the internals of their code.  Thus, our abstraction is not very abstract
 at all.</li>
<li>As a follow-on to the previous point: We are only illustrating
 <em>one</em> added concept: <code>DistanceType</code>; each additional concept
 would require a new type parameter to be threaded through the
 parameter lists of all methods and classes.  This blows up to an
 unmaintainable mess fairly quickly, discouraging use of generics
 to define these abstractions (and instead relying on
 e.g. separate class-hierarchies).</li>
</ol>


<hr />

<a name="L.a.id..rustspec..Rust-specific.issues..a."></a>
<h2><a id="rustspec">Rust-specific issues</a></h2>

<p>I encountered this problem while porting EOP code to Rust.  After
wrestling with the type parameter lists for a while, I eventually
wised up and asked on the #rust IRC channel if there was a better
option.  Tim Chevalier informed me of the relevant terminology:
the feature I want is called &ldquo;associated types access&rdquo; (or often just
&ldquo;associated types&rdquo;).
An associated type specifies a mapping from some type to another type.</p>

<p>&ldquo;Associated type access&rdquo; is listed as one of eight properties considered important in
&ldquo;<a href="http://osl.iu.edu/publications/prints/2003/comparing_generic_programming03.pdf">A comparative study of language support for generic programming</a>&rdquo;
(Garcia et al., 2003 <a href="http://dl.acm.org/citation.cfm?id=949317">ACM</a>).
If you found <a href="#encodingunpalatable">the argument above</a> unconvincing,
you should read the Garcia paper for a completely different example motivated by
a Graph abstraction.</p>

<p>After I read the Garcia paper, I promptly filed <a href="https://github.com/mozilla/rust/issues/5033">an RFC</a> on the
Rust github repository requesting support for Associated Type
Synonyms.  After this, I had several discussions with Niko Matsakis,
both over IRC and in person, on the problems that associated types
present for Rust.</p>

<a name="L.a.id..nikoposts..Niko.s.blog.posts..a."></a>
<h3><a id="nikoposts">Niko&rsquo;s blog posts</a></h3>

<p>You can see Niko&rsquo;s thorough overview of the matter,
including his natural generalization of the topic from &ldquo;associated
types&rdquo; to &ldquo;associated <em>items</em>&rdquo;, on his pair of blog posts (<a href="http://www.smallcultfollowing.com/babysteps/blog/2013/04/02/associated-items/">part
I</a>, <a href="http://www.smallcultfollowing.com/babysteps/blog/2013/04/03/associated-items-continued/">part II</a>).  The generalization to &ldquo;associated items&rdquo;
enables one to define, in addition to <code>type -&gt; type</code> mappings as
illustrated <a href="#background">above</a>, also <code>type -&gt; function</code>
mappings (called in some languages &ldquo;static&rdquo; functions) and <code>type -&gt;
(constant) value</code> mappings, which may enable certain interesting
coding patterns, such as allowing a type representing a vector in a
multi-dimensional space to state, statically, how many dimensions
it carries.</p>

<p>The following are the specific points that Niko makes in his posts (some of
are just pointing out artifacts of current Rust language syntax).</p>

<a name="Current.Rust.syntax.focuses.on.deriving.associated.functions.from.traits"></a>
<h3>Current Rust syntax focuses on deriving associated functions from traits</h3>

<p>Rust does not currently offer general associated items, but it does
offer a kind of associated function access.</p>

<p>If a trait <code>T</code> defines a function <code>f</code> that returns <code>Self</code> (which means
that implementations of <code>T</code> are obligated to provide an implementation
of <code>f</code>), and one has a type <code>X</code> implementing that trait, then one can
derive <code>f</code>.</p>

<p>But in current Rust syntax, one does not write this derivation of <code>f</code>
as something attached to the type <code>X</code>; instead, one writes <code>T::f(..)</code>,
and the compiler is responsible for inferring which implementation of
the function <code>f</code> one is referring to, by using type-inference on the
context of the invocation <code>T::f(..)</code> to determine that the return type
of <code>f</code> must be <code>X</code> (and thus the <code>f</code> in question must be the one that
the type <code>X</code> implements to satisfy the obligation established by the
trait <code>T</code>).</p>

<a name="L.a.id..nikoenctt1..Resolving.ambiguities.in.general.implies.you.need.both.the.trait.and.type..a."></a>
<h4><a id="nikoenctt1">Resolving ambiguities in general implies you need both the trait and type</a></h4>

<p>The choice of deriving a function&rsquo;s implementation from the trait
rather than the type is understandable when one considers that a
software system may have multiple traits <code>T</code>, <code>U</code>, <code>V</code>, &hellip; that all
define a function of the same name (say <code>f</code>), and a type may be
specified as implementing more than one of these traits in a single
piece of code.  (It would be anti-modular to require every trait to
choose globally unique names for its set of associated functions).  So
to handle this case, one must provide some way to disambiguate which
<code>f</code> is being referenced.  Rust did so by making the trait expression
part of the invocation syntax.  Niko points out that if one switches
to a syntax where one derives <code>f</code> from the type
<code>X</code> (e.g. <nobr>&ldquo;<code>X::f</code>&rdquo;</nobr>) then one must tackle this problem in
some manner; in his first blog post, he suggests doing so by allowing
one to encode both the type and the trait in the referencing syntax
(e.g. <nobr>&ldquo;<code>X::(T::f)</code>&rdquo;</nobr> or <nobr>&ldquo;<code>X::(U::f)</code>&rdquo;</nobr>.</p>

<p>I dislike this syntax because I think it
would be confusing for a reader to comprehend the distinct roles of
the <nobr>&ldquo;<code>::</code>&rdquo;</nobr> path operator, both when learning the language
and when casually skimming Rust code in general.</p>

<a name="Rust.type.expressions.do.not.naturally.fit.into.Rust.path.expressions"></a>
<h4>Rust type expressions do not naturally fit into Rust path expressions</h4>

<p>Niko also points out that when one wants to write <code>X::f</code> where <code>X</code> is
a type, it is not always the case that <code>X</code> is a type parameter; it
could be a concrete type known to the programmer, such as the type of
owned vecs of ints, denoted by the type expression</p>

<nobr>`~[int]`.</nobr>


<p> So it seems natural to want to substitute such
a type expression for (the meta-variable) <code>X</code>.</p>

<p>But the syntax <code>~[int]::f</code> is not legal, because <code>~[int]</code> is
not a legitimate path component.  Niko describes a couple of
work-arounds, e.g. allowing one to wrap a type expression that appears
in a path expression with brackets, yielding: <code>&lt;~[int]&gt;::f</code>.</p>

<p>All of the work-arounds presented by Niko do require allowing
arbitrary type-expressions in some form to appear as a sub-expression,
which would complicate the parser in the Rust compiler (there has been
a slight push to try to <em>simplify</em> the path expression syntax, which
this would conflict with).</p>

<a name="Further.syntactic.exploration.of.encoding.trait.and.type"></a>
<h4>Further syntactic exploration of encoding trait and type</h4>

<p>In his second blog post, Niko provides some alternative syntactic forms
for resolution:</p>

<ul>
<li><p><code>X::(T::f)</code>, as described <a href="#nikoenctt1">above</a>.</p></li>
<li><p><code>T::f::&lt;X&gt;</code> (from &ldquo;Functional-style name resolution (take 1)&rdquo;); here
<code>X</code> is a synthetic type parameter added to the type parameter list
(if any) of <code>f</code>; so now we get to retain syntactic backwards
compatibility.  Since Rust allows one to omit the explicit type
instantiation <code>::&lt;X, ...&gt;</code> when the compiler is able to infer
the instantiation, this would be a natural way to continue
doing return-type based inference of the desired type, the way
it does already.</p></li>
<li><p><code>T::f::&lt;for X&gt;</code> as a way of distinguishing the synthetic parameter
from other entries on the parameter list.</p></li>
</ul>


<p>I have already stated my problems with the first option.</p>

<p>For the second option, I anticipate being personally confused by the
synthetic type parameter being injected into the type parameter list.
I understand the appeal of enabling the compiler to continue doing
heavy lifting and lighten the programmers syntactic load.  <a href="http://www.smallcultfollowing.com/babysteps/blog/2013/04/03/associated-items-continued/">Niko&rsquo;s
post</a> does a good job of laying out some of the unexpected
interactions of the synthetic type parameter with the other forms of
generic type parameterization.</p>

<p>The third option would reduce confusion somewhat, since the
synthetic parameter would receive special attention at points of type
instantiation, but I still think it is an abuse of the parameter list.</p>

<a name="L.a.id..thinkbinding..Simpler.syntax:.What.about.binding...a."></a>
<h3><a id="thinkbinding">Simpler syntax: What about binding?</a></h3>

<p>So I set about trying to come up with another syntactic form
for associated item access.  My primary focus initially was:
all of these examples would be so much simpler, to my mind,
if we were able to go back to using a single identifier
for the relevant path component in the referencing form,
the way that C++ uses <nobr><code>C::f</code>.</nobr>
How can Rust make its own analogous <nobr><code>R::f</code></nobr> (the &ldquo;R&rdquo; is for Rust).</p>

<p>Of course, we have already covered that this will be ambiguous if
<code>R</code> is a mere type (and it is of course ambiguous if <code>R</code> is just a trait).</p>

<p>But what if <code>R</code> is a way of referring to the type <code>X</code> and the trait <code>T</code>
together: the (type, trait) pairing (X,T)?  Clearly once one specifies the
pair, then it is easy to tell what items are associated with the pair.
Even a human without a sophisticated IDE would know in that case to try
invoking <code>grep</code>, searching for <code>impl T.* for X.*</code>; a compiler can do even better.</p>

<p>Another way of looking at this: What if we could introduce local names
for the impl that corresponds to the (type, trait) pairing.</p>

<p>So I started working on ideas all centering around a declaration
form like <code>let R = trait T for type X;</code> or <code>use impl R = T for X</code>
and other variations (I think Patrick Walton actually deserves credit
for that last one; we will revisit it later).  But Niko quickly pointed
the huge failing of all of these declaration forms: a very common
use case for associated <em>types</em> (remember, that was our original goal)
is for function signatures, like:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">distance</span><span class="o">&lt;</span><span class="n">F</span><span class="o">:</span> <span class="n">Transformation</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">Domain</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">y</span><span class="o">:</span> <span class="n">Domain</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">f</span><span class="o">:</span> <span class="n">F</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DistanceType</span><span class="p">(</span><span class="n">F</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">remove_edge</span><span class="o">&lt;</span><span class="n">G</span><span class="o">:</span> <span class="n">IncidenceGraph</span> <span class="o">+</span> <span class="n">EdgeCollection</span><span class="o">&gt;</span><span class="p">(</span><span class="n">g</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">G</span><span class="p">,</span> <span class="n">e</span><span class="o">:</span> <span class="n">Edge</span><span class="p">(</span><span class="n">G</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>where <code>Domain(F)</code>, <code>DistanceType(F)</code>, and <code>Edge(G)</code> are replaced
with appropriately Rust-friendly syntactic forms.  There is no <em>place</em>
there to put a declaration form <code>let ...</code> or <code>use ...</code> that refers to
<code>F</code>.  The same applies for other parameterized forms, such as structs,
enums, and traits.</p>

<p>So, back to the drawing board.</p>

<hr />

<a name="L.a.id..insight..An.Insight..a."></a>
<h2><a id="insight">An Insight</a></h2>

<p>Even though my attempt to solve this problem via a declaration form had
failed, I continued to focus on the fact that associated item access
is all about the (type, trait) pairing.  So how could I surmount the
parameterized signature wall?</p>

<p>After reflecting on the parameterized signature itself, I said, &ldquo;where
is a natural place to put a binding from an identifier to a (type,
trait) pair?&rdquo;  And this reduced to &ldquo;where does the (type, trait) pair
come from?&rdquo;  This was my insight: The parameterized signature</p>

<nobr>`<X: T>`</nobr>


<p> <em>itself</em> is where the pairing is defined;
(or in the case of <nobr><code>&lt;X: T + U&gt;</code></nobr>: <em>pairings</em>).</p>

<p>My only problem was to put the identifier binding in there.  Once I
saw the pairing waiting right in the parameter list, the place for the
identifier became clear: in-between the type and the trait:</p>

<nobr>`<X: R=T>`</nobr>


<p> binds <code>R</code> to the <code>impl T for X</code>;
for multiple traits, we have <nobr><code>&lt;X: R=T + R2=U&gt;</code></nobr>,
where <code>R</code> is bound as above, and <code>R2</code> is bound to the <code>impl U for X</code>.</p>

<p>And now we can consider writing our examples like so:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">distance</span><span class="o">&lt;</span><span class="n">F</span><span class="o">:</span> <span class="n">T</span><span class="o">=</span><span class="n">Transformation</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">T</span><span class="o">::</span><span class="n">Domain</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="n">T</span><span class="o">::</span><span class="n">Domain</span><span class="p">,</span> <span class="n">f</span><span class="o">:</span> <span class="n">F</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="o">::</span><span class="n">DistanceType</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">remove_edge</span><span class="o">&lt;</span><span class="n">G</span><span class="o">:</span> <span class="n">IncidenceGraph</span> <span class="o">+</span> <span class="n">EC</span><span class="o">=</span><span class="n">EdgeCollection</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">g</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">G</span><span class="p">,</span> <span class="n">e</span><span class="o">:</span> <span class="n">EC</span><span class="o">::</span><span class="n">Edge</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>The other cute insight is this: the only time we need to add these
identifiers explicitly is when there are multiple trait bounds.
When there is a single trait bound <nobr><code>&lt;X:R=T&gt;</code></nobr>, the
identifier <code>X</code> is just as reasonable (or at least unambiguous) as <code>R</code>
is as a way to reference the impl.  So why not treat</p>

<nobr>`<X:T>`</nobr>


<p> as an abbreviation for <nobr><code>&lt;X:X=T&gt;</code></nobr>:
boom!  The biggest potential complaint with this extension (namely,
the notational complexity of making people pepper their code with
explicit bindings of the impls) goes away!  And our first example becomes:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">distance</span><span class="o">&lt;</span><span class="n">F</span><span class="o">:</span> <span class="n">Transformation</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">F</span><span class="o">::</span><span class="n">Domain</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="n">F</span><span class="o">::</span><span class="n">Domain</span><span class="p">,</span> <span class="n">f</span><span class="o">:</span> <span class="n">F</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">F</span><span class="o">::</span><span class="n">DistanceType</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>(our second example remains unchanged, since <code>G</code> has two trait bounds there, and
so <code>G</code> alone cannot unambiguously denote a (type, trait) pair.</p>

<p>Note also that this binding form does not suffice on its own; in
particular, if one wants to introduce a binding for a (type,trait)
pairing that does not appear in the generic parameter bounds of the
signature.  But the latter is exactly the case that <em>is</em> handled by a
declaration form such as those <a href="#thinkbinding">proposed earlier</a>!</p>

<p>So neither solution suffices on its own, but the two together cover
many use cases of interest.</p>

<hr />

<a name="L.a.id..proposal..The.proposed.syntax.for.associated.items.in.Rust..a."></a>
<h2><a id="proposal">The proposed syntax for associated items in Rust</a></h2>

<p>So, with that insight explained, here is my proposal for associated items:</p>

<ol>
<li><p>A trait can now declare names for things besides methods.
 In terms of the grammar that John has been working on:</p>

<pre><code class="`"> trait_decl: TRAIT ident
                (generic_decls)? (COLON trait_list)?
                LBRACE trait_method* RBRACE ;
</code></pre>

<p> is replaced with</p>

<pre><code class="`"> trait_decl: TRAIT ident
                (generic_decls)? (COLON trait_list)?
                LBRACE trait_item* RBRACE ;
 trait_item: trait_method | trait_constant | trait_type
 trait_type: TYPE ident (generic_decls)? SEMI
           | TYPE ident (generic_decls)? COLON boundseq SEMI ;
 trait_const: STATIC ident COLON ty SEMI ;
</code></pre></li>
<li><p>The identifier bound by a trait types is in scope of its enclosing
 trait; trait method declarations and trait const declarations
 can reference it.</p></li>
<li><p>Extend the Rust grammar to allow an optional binding of
 an identifier to a (type, trait) pair in a type parameter bound.
 In terms of the grammar:</p>

<pre><code class="`"> bound : STATIC_LIFETIME | trait | obsoletekind ;
</code></pre>

<p> is replaced with:</p>

<pre><code class="`"> bound : STATIC_LIFETIME | trait | ident = trait | obsoletekind ;
</code></pre></li>
<li><p>Extend the Rust grammar to allow a declaration binding
 an identifier to a (type, trait) pair.
 In terms of the grammar, I <em>think</em> this is close to what I want:</p>

<pre><code class="`"> view_item : attrs_vis use ;
</code></pre>

<p> is replaced with:</p>

<pre><code class="`"> view_item : attrs_vis use | USE impl ident = trait for ty ;
</code></pre>

<p> Of potential interest, we do not allow visibility attributes
 on <code>use impl R = T for X;</code>, because these definitions are always
 local shorthands and thus private to the module.  (Maybe in
 the future we will see motivation to allow the bindings to
 be exposed, but I have not yet seen a motivation for this.)</p>

<p> I am not attached to the particulars of the syntax above;
 in particular, if someone wants to throw in the <code>trait</code>
 and/or <code>type</code> keywords into the above to make the purpose
 all the more clear, I will not object.  More so if it is
 somehow <em>necessary</em> for disambiguation, but I do not
 anticipate that being the case.</p></li>
<li><p>A bound of the form <code>R=T</code> (<code>ident = ty</code>) in the context of a <code>ty_param</code>
 production <code>X : ... [] ...</code> (<code>ident COLON bound + ... + [] + ... + bound</code>)
 (where <code>[]</code> denotes the contextual hole that the <code>R=T</code> is plugged into)
 is treated as binding <code>R</code> to the code defined by the <code>impl T for X</code>.
 The scope of the binding for <code>R</code> encompasses: the rest of the boundseq
 (to the right of the <nobr><code>"R=T"</code></nobr>) and the remainder of this decl
 that follows the generic_decls within which the <nobr><code>R=T</code></nobr> bound appears.</p></li>
<li><p>This binding of <code>R</code> can shadow earlier bindings of the same identifier
 (either other impl-bindings, or module names).  It seems like this
 should be a reasonable thing to signal via a lint-warning.</p></li>
<li><p>A path identifier component can now be an <code>R</code>, binding an <code>impl T for X</code>.</p>

<p>So one can access trait items (see trait_item above) as R::item.
 Associated items can be type-parametric whenever the corresponding
 item could be type-parameteric when exported from a module.</p></li>
<li><p>A boundseq with a single bound of variant <code>ty</code> above, where ty is
 itself of the form <code>ident</code> (i.e. the <code>&lt;X:T&gt;</code> case) is implicitly
 expanded into <code>&lt;X:X=T&gt;</code>.</p></li>
</ol>


<hr />

<a name="L.a.id..futurework..What.the.proposal.does.not.cover..a."></a>
<h2><a id="futurework">What the proposal does not cover</a></h2>

<p>There are cases of interest that are not covered by the above proposal.</p>

<p>Most obvious to me are situations where one wants to describe mutual
constraints <em>between</em> the items associated with type parameters.
(An example of this is provided by the <code>gen_orbit</code> example with
the constraint <code>DistanceType(I) = N</code>, and more generally much of the
content of the <code>requires(..)</code> clauses from EOP that I deliberately
ignored).  For the examples from EOP, C++ handles this by doing the
template instantiation blindly and applying the type checker to
code after concrete types have been substituted for the parameters;
this approach is not compatible with Rust&rsquo;s design where we want to
type-check a generic body of code in terms of the guarantees provided
by the trait-bounds, <em>not</em> delaying those checks until after
the concrete types have been plugged in.</p>

<p>Also, in the changes I proposed above to the Rust grammar (and
somewhat implicitly to its semantics), I deliberately constrained my
focus to the cases Niko described in his blog posts: types, functions,
and constants.  But one might consider further extensions, such as
allowing traits to define <em>other</em> traits.  (I found that subject hard
to wrap one&rsquo;s mind around, and I wanted to keep the focus limited for
Rust 1.0; we can leave generalizations of this approach for after Rust
1.0.)</p>

<p>Also, I&rsquo;m not sure whether there is need and/or utility in further
generalizing this topic to <a href="http://www.haskell.org/haskellwiki/GHC/Type_families#An_associated_data_type_example">associated data families</a>.  Again,
I want to limit the scope of the work to something we believe we can
accomplish for Rust 1.0.</p>

<p>What else have I missed?  Let me know, leave a comment.  (Or look
for me in the #rust irc channel.)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Better command completion in bash on OS X]]></title>
    <link href="http://blog.pnkfx.org/blog/2013/04/12/better-command-completion-in-bash-aka-resolving-zsh-envy/"/>
    <updated>2013-04-12T07:57:00+02:00</updated>
    <id>http://blog.pnkfx.org/blog/2013/04/12/better-command-completion-in-bash-aka-resolving-zsh-envy</id>
    <content type="html"><![CDATA[<p>(This post started as a personal e-mail to Niko, and then I figured it
was blog worthy.)</p>

<p>There&rsquo;s plenty of problems when working atop &ldquo;OS X&rdquo;;
but no need to be jealous of Shu&rsquo;s zsh setup
(at least not for its tab-completion on git stuff),
at least not if you are already using Homebrew.
Just install
<a href="http://blog.jeffterrace.com/2012/09/bash-completion-for-mac-os-x.html">brew&rsquo;s bash completion package</a>!</p>

<!-- more -->


<p>Executive summary:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>% brew install bash-completion
</span><span class='line'>
</span><span class='line'>% <span class="nb">echo</span> &gt;&gt; ~/.bash_profile <span class="s">&lt;&lt;END</span>
</span><span class='line'><span class="s">  if [ -f $(brew --prefix)/etc/bash_completion ]; then</span>
</span><span class='line'><span class="s">    . $(brew --prefix)/etc/bash_completion</span>
</span><span class='line'><span class="s">  fi</span>
</span><span class='line'><span class="s">END</span>
</span></code></pre></td></tr></table></div></figure>


<p>And voilà!</p>

<p>See also potentially related topics from <a href="http://superuser.com/questions/288438/bash-completion-for-commands-in-mac-os">super user</a>, <a href="http://stackoverflow.com/questions/14970728/homebrews-git-not-using-completion">stack overflow</a>, <a href="http://milkbox.net/note/brace-completion-in-snow-leopard-upgrading-bash/">milkbox blog</a>.</p>

<hr />

<p>Note also that I did burn myself by trying to get too smart: In
particular, after reading <a href="http://stackoverflow.com/questions/14970728/homebrews-git-not-using-completion">stack overflow</a>, I over-eagerly
attempted to address a purported problem by installing the homebrew
newer git instead of the default (older) built-in git installed by
Apple.</p>

<p>This was a little more painful than I expected, because there were a
bunch of git-related commands already in my <code>/usr/local/bin</code>, probably
I had likely already copied git to there once before by hand, and so
brew kept aborting the installation because it did not want to
overwrite the binaries that it was not already managing.  I think brew
was aborting the install in a sound transactional manner, but I am not
100% sure of that, because at least one point the command completion
stopped working and at that point I just</p>

<ol>
<li>gave up on understanding where everything came from,</li>
<li>moved the non-brew git-related material
in <code>/usr/local/bin/</code> out of the way, and</li>
<li>redid the <code>brew install git</code></li>
</ol>


<hr />

<p>Anyway, I should also give a shout-out to Axel Hecht; his post
on Mozilla&rsquo;s Yammer instance is what got me to the point of even
attempting to install this piece of marvelousness.</p>

<p>(Also, further posts on yammer are lightly pushing for readers to consider
zsh as an alternative to bash.  I do not think I am ready to switch to zsh,
but I can at least link to the <a href="http://friedcpu.wordpress.com/2007/07/24/zsh-the-last-shell-youll-ever-need/">blog post arguing for zsh</a>.)</p>

<hr />

<p>Update (written 2013 april 16): Now that I have decent command/context
sensitive completion in bash in my terminal, of <em>course</em> I
want to have it in my Emacs <code>M-x shell</code> as well.  At first I
was dismayed that I did not just get that &ldquo;out of the box&rdquo;;
then I was happy after some googling to discover:
<a href="https://github.com/szermatt/emacs-bash-completion">bash-completion.el</a>, which forwards the completion
requests onto a separate bash process, so that one inherits
the same completions that bash provides in the terminal,
with no Emacs hacking.</p>

<p>Well, at least, not very much Emacs hacking.</p>

<p>It turns out that I had to do a little bit of Emacs hacking
in order to get the setup working, at least for my idiosyncratic
bash setup.  In particular, it seems like the Elisp code
for bash-complete.el assumes that one is setting one&rsquo;s
prompt via the <code>PS1</code> environment variable, while mine is often
set via the <code>PROMPT_COMMAND</code> environment variable.
After determining what is going on, it is easy enough to fix this (and
the corresponding solution has even been filed as a <a href="https://github.com/szermatt/emacs-bash-completion/pull/2">pull request in
the github repo</a>).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rusty Chain Puzzle 1.]]></title>
    <link href="http://blog.pnkfx.org/blog/2013/03/26/rusty-chain-puzzle-1/"/>
    <updated>2013-03-26T10:28:00+01:00</updated>
    <id>http://blog.pnkfx.org/blog/2013/03/26/rusty-chain-puzzle-1</id>
    <content type="html"><![CDATA[<p>I have been trying to get my feet wet programming in
<a href="http://www.rust-lang.org/">Rust</a>.</p>

<p>A month and a half ago, I thought &ldquo;Maybe I will hack up an Earley
parser in a variety of languages, including Rust.&rdquo;  That sent me down
a long path of learning about how Earley parsing works; I have not yet
written up my results from that investigation, and I still have not
written the Rust version of the code.</p>

<p>Last weekend, I sat down and said, &ldquo;Let&rsquo;s try a simpler goal: A couple
simple exercies, maybe taken from Knuth&rsquo;s
<a href="http://www-cs-faculty.stanford.edu/~uno/taocp.html">TAOCP</a>&rdquo;
This was indeed a much simpler goal, but it was more difficult than
I had expected.</p>

<!-- more -->


<p>So, here is a Rust hacking puzzle that I struggled with.</p>

<p>I am representing piles of playing cards via linked structures.
Here are the data structure declarations:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">enum</span> <span class="n">card_suit</span> <span class="p">{</span> <span class="n">clubs</span><span class="p">,</span> <span class="n">diamonds</span><span class="p">,</span> <span class="n">hearts</span><span class="p">,</span> <span class="n">spades</span> <span class="p">}</span>
</span><span class='line'><span class="k">struct</span> <span class="n">card</span> <span class="p">{</span> <span class="n">suit</span><span class="o">:</span> <span class="n">card_suit</span><span class="p">,</span>
</span><span class='line'>              <span class="n">rank</span><span class="o">:</span> <span class="kt">u8</span><span class="p">,</span> <span class="c1">// 1..13</span>
</span><span class='line'>              <span class="n">next</span><span class="o">:</span> <span class="nb">Option</span><span class="o">&lt;~</span><span class="n">card</span><span class="o">&gt;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note that the <code>next</code> field is an (optional) <em>owned</em> pointer to the
next card in the pile.  <code>Option&lt;~card&gt;</code> will be generally used to
represent a potentially empty pile (or &ldquo;stack&rdquo;, &ldquo;deck&rdquo; or &ldquo;hand&rdquo;, as
the context dictates), while <code>~card</code> is a non-empty pile (or, when its
<code>next</code> is <code>None</code>, a single card, again as context dictates)</p>

<a name="The.goal"></a>
<h2>The goal</h2>

<p>I want to write four functions: <code>place_top</code>, <code>place_bot</code>, <code>pop_top</code>,
and <code>pop_bot</code>, which respectively:</p>

<ul>
<li><p><code>place_top(stack, c)</code> pushes a card <code>c</code> onto the top of the stack,
represented by return the new top of the stack.</p></li>
<li><p><code>place_bot(stack, c)</code> places a card beneath the stack.  For an empty
stack, the placed card is returned as the top of the newly formed
stack; otherwise, the old stack top is returned (since the stack is
imperatively modified).</p></li>
<li><p><code>pop_top(stack)</code> pops the top of the stack, returning a tuple of the
popped card and the remaining, potentially empty stack.</p></li>
<li><p><code>pop_bot(stack)</code> removes the bottom of the stack (i.e. &ldquo;deals from
the bottom of the deck&rdquo;), returning a tuple of the removed card and
the new, potentially empty stack.</p></li>
</ul>


<p>In code, here are the signatures for the desired functions,
as well as one-line reminders of the behavior for each.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="c1">// [c1, ..., cN], cX -&gt; [cX, c1, ..., cN]</span>
</span><span class='line'><span class="k">fn</span> <span class="n">place_top</span><span class="p">(</span><span class="n">pile</span><span class="o">:</span> <span class="nb">Option</span><span class="o">&lt;~</span><span class="n">card</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">newcard</span><span class="o">:</span> <span class="o">~</span><span class="n">card</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">card</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// [c1, ..., cN], cX -&gt; [c1, ..., cN, cX]</span>
</span><span class='line'><span class="k">fn</span> <span class="n">place_bot</span><span class="p">(</span><span class="n">pile</span><span class="o">:</span> <span class="nb">Option</span><span class="o">&lt;~</span><span class="n">card</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">newcard</span><span class="o">:</span> <span class="o">~</span><span class="n">card</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">card</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// [c1, c2, ..., cN] -&gt; (c1, [c2, ..., cN])</span>
</span><span class='line'><span class="k">fn</span> <span class="n">pop_top</span><span class="p">(</span><span class="n">pile</span><span class="o">:</span> <span class="o">~</span><span class="n">card</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="o">~</span><span class="n">card</span><span class="p">,</span> <span class="nb">Option</span><span class="o">&lt;~</span><span class="n">card</span><span class="o">&gt;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// [c1, ..., cN-1, cN] -&gt; (Some(cN), [c1, ..., cN-1])</span>
</span><span class='line'><span class="k">fn</span> <span class="n">pop_bot</span><span class="p">(</span><span class="n">pile</span><span class="o">:</span> <span class="o">~</span><span class="n">card</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="o">~</span><span class="n">card</span><span class="p">,</span> <span class="nb">Option</span><span class="o">&lt;~</span><span class="n">card</span><span class="o">&gt;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<a name="L.Some.non-critical.helper.infrastructure.follows..showing.off.Rust.as.language."></a>
<h2>(Some non-critical helper infrastructure follows, showing off Rust as language)</h2>

<p>Here is some example code that puts together a hand and does
a few manipulations using the above operations (as well as
some printing routines to make looking at these cards nicer
in the terminal output)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">make_hand</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">card</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">hand</span> <span class="o">=</span> <span class="o">~</span><span class="n">card</span> <span class="p">{</span> <span class="n">suit</span><span class="o">:</span> <span class="n">clubs</span><span class="p">,</span> <span class="n">rank</span><span class="o">:</span> <span class="mi">10</span><span class="p">,</span> <span class="n">next</span><span class="o">:</span> <span class="nb">None</span> <span class="p">};</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">hand</span> <span class="o">=</span> <span class="o">~</span><span class="n">card</span> <span class="p">{</span> <span class="n">suit</span><span class="o">:</span> <span class="n">spades</span><span class="p">,</span> <span class="n">rank</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">next</span><span class="o">:</span> <span class="nb">Some</span><span class="p">(</span><span class="n">hand</span><span class="p">)</span> <span class="p">};</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">hand</span> <span class="o">=</span> <span class="o">~</span><span class="n">card</span> <span class="p">{</span> <span class="n">suit</span><span class="o">:</span> <span class="n">diamonds</span><span class="p">,</span> <span class="n">rank</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">next</span><span class="o">:</span> <span class="nb">Some</span><span class="p">(</span><span class="n">hand</span><span class="p">)</span> <span class="p">};</span>
</span><span class='line'>    <span class="n">hand</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">hand</span> <span class="o">:</span> <span class="o">~</span><span class="n">card</span> <span class="o">=</span> <span class="n">make_hand</span><span class="p">();</span>
</span><span class='line'>    <span class="n">hand</span><span class="p">.</span><span class="n">report</span><span class="p">(</span><span class="o">~</span><span class="s">&quot;initial hand: &quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">AceD</span> <span class="o">=</span> <span class="o">~</span><span class="n">card</span><span class="p">{</span> <span class="n">suit</span><span class="o">:</span> <span class="n">diamonds</span><span class="p">,</span> <span class="n">rank</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">next</span><span class="o">:</span> <span class="nb">None</span> <span class="p">};</span>
</span><span class='line'>    <span class="n">AceD</span><span class="p">.</span><span class="n">report</span><span class="p">(</span><span class="o">~</span><span class="s">&quot;place top: &quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">hand</span> <span class="o">=</span> <span class="n">place_top</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">hand</span><span class="p">),</span> <span class="n">AceD</span><span class="p">);</span>
</span><span class='line'>    <span class="n">hand</span><span class="p">.</span><span class="n">report</span><span class="p">(</span><span class="o">~</span><span class="s">&quot;new hand: &quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">SixD</span> <span class="o">=</span> <span class="o">~</span><span class="n">card</span><span class="p">{</span> <span class="n">suit</span><span class="o">:</span> <span class="n">diamonds</span><span class="p">,</span> <span class="n">rank</span><span class="o">:</span> <span class="mi">6</span><span class="p">,</span> <span class="n">next</span><span class="o">:</span> <span class="nb">None</span> <span class="p">};</span>
</span><span class='line'>    <span class="n">SixD</span><span class="p">.</span><span class="n">report</span><span class="p">(</span><span class="o">~</span><span class="s">&quot;place bot: &quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">hand</span> <span class="o">=</span> <span class="n">place_bot</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">hand</span><span class="p">),</span> <span class="n">SixD</span><span class="p">);</span>
</span><span class='line'>    <span class="n">hand</span><span class="p">.</span><span class="n">report</span><span class="p">(</span><span class="o">~</span><span class="s">&quot;new hand: &quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">let</span> <span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="o">=</span> <span class="n">pop_top</span><span class="p">(</span><span class="n">hand</span><span class="p">);</span>
</span><span class='line'>    <span class="n">top</span><span class="p">.</span><span class="n">report</span><span class="p">(</span><span class="o">~</span><span class="s">&quot;popped top: &quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">hand</span> <span class="o">=</span> <span class="n">rest</span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span>
</span><span class='line'>    <span class="n">hand</span><span class="p">.</span><span class="n">report</span><span class="p">(</span><span class="o">~</span><span class="s">&quot;new hand: &quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">let</span> <span class="p">(</span><span class="n">bot</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="o">=</span> <span class="n">pop_bot</span><span class="p">(</span><span class="n">hand</span><span class="p">);</span>
</span><span class='line'>    <span class="n">bot</span><span class="p">.</span><span class="n">report</span><span class="p">(</span><span class="o">~</span><span class="s">&quot;popped bot: &quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">hand</span> <span class="o">=</span> <span class="n">rest</span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span>
</span><span class='line'>    <span class="n">hand</span><span class="p">.</span><span class="n">report</span><span class="p">(</span><span class="o">~</span><span class="s">&quot;new hand: &quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Below are &quot;just&quot; some notation niceties that should not effect</span>
</span><span class='line'><span class="c1">// the semantics of the code + algorithms above.</span>
</span><span class='line'>
</span><span class='line'><span class="k">impl</span> <span class="nb">ToStr</span> <span class="k">for</span> <span class="n">card_suit</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fn</span> <span class="n">to_str</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="kt">str</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">match</span> <span class="bp">self</span> <span class="p">{</span> <span class="o">&amp;</span><span class="n">spades</span>   <span class="o">=&gt;</span> <span class="o">~</span><span class="s">&quot;</span><span class="se">\u2664</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hearts</span>   <span class="o">=&gt;</span> <span class="o">~</span><span class="s">&quot;</span><span class="se">\u2665</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class='line'>                     <span class="o">&amp;</span><span class="n">diamonds</span> <span class="o">=&gt;</span> <span class="o">~</span><span class="s">&quot;</span><span class="se">\u2666</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clubs</span>    <span class="o">=&gt;</span> <span class="o">~</span><span class="s">&quot;</span><span class="se">\u2667</span><span class="s">&quot;</span> <span class="p">}</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">rank_to_str</span><span class="p">(</span><span class="n">r</span><span class="o">:</span><span class="kt">u8</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="kt">str</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">match</span> <span class="n">r</span> <span class="p">{</span>
</span><span class='line'>        <span class="mi">1</span>     <span class="o">=&gt;</span> <span class="o">~</span><span class="s">&quot;A&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="mf">2.</span><span class="p">.</span><span class="mi">10</span> <span class="o">=&gt;</span> <span class="n">r</span><span class="p">.</span><span class="n">to_str</span><span class="p">(),</span>
</span><span class='line'>        <span class="mi">11</span>    <span class="o">=&gt;</span> <span class="o">~</span><span class="s">&quot;J&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="mi">12</span>    <span class="o">=&gt;</span> <span class="o">~</span><span class="s">&quot;Q&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="mi">13</span>    <span class="o">=&gt;</span> <span class="o">~</span><span class="s">&quot;K&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="n">_</span>     <span class="o">=&gt;</span> <span class="n">fail</span><span class="o">!</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">impl</span> <span class="n">card</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fn</span> <span class="n">rank_to_str</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="kt">str</span> <span class="p">{</span> <span class="n">rank_to_str</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">rank</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">fn</span> <span class="n">report</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="o">:</span> <span class="o">~</span><span class="kt">str</span><span class="p">)</span> <span class="p">{</span> <span class="n">io</span><span class="o">::</span><span class="nb">println</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="bp">self</span><span class="p">.</span><span class="n">to_str</span><span class="p">());</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">impl</span> <span class="nb">ToStr</span> <span class="k">for</span> <span class="n">card</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fn</span> <span class="n">to_str</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="kt">str</span> <span class="p">{</span>
</span><span class='line'>        <span class="kd">let</span> <span class="k">mut</span> <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">rank_to_str</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="p">.</span><span class="n">suit</span><span class="p">.</span><span class="n">to_str</span><span class="p">();</span>
</span><span class='line'>        <span class="k">match</span> <span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">next</span> <span class="p">{</span>
</span><span class='line'>            <span class="o">&amp;</span><span class="nb">None</span> <span class="o">=&gt;</span> <span class="p">(),</span>
</span><span class='line'>            <span class="o">&amp;</span><span class="nb">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">n</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">+</span> <span class="s">&quot;,&quot;</span> <span class="o">+</span> <span class="n">n</span><span class="p">.</span><span class="n">to_str</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">ret</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>In my terminal, I get the following output from the above <code>main</code>
function:</p>

<p>initial hand: 2&diams;,3&spades;,10&clubs;<br/>
place top: A&diams;<br/>
new hand: A&diams;,2&diams;,3&spades;,10&clubs;<br/>
place bot: 6&diams;<br/>
new hand: A&diams;,2&diams;,3&spades;,10&clubs;,6&diams;<br/>
popped top: A&diams;<br/>
new hand: 2&diams;,3&spades;,10&clubs;,6&diams;<br/>
popped bot: 6&diams;<br/>
new hand: 2&diams;,3&spades;,10&clubs;</p>

<p>(I will post my initial &ldquo;solution&rdquo; to the puzzle in a follow-up post;
 I wanted to share this first because I know my current solution
 is non-optimal and wanted to see what others had to offer for how
 to solve this first.)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implicit versus Explicit Finalization]]></title>
    <link href="http://blog.pnkfx.org/blog/2013/01/29/implicit-versus-explicit-finalization/"/>
    <updated>2013-01-29T22:47:00+01:00</updated>
    <id>http://blog.pnkfx.org/blog/2013/01/29/implicit-versus-explicit-finalization</id>
    <content type="html"><![CDATA[<p>(This post is largely a response to Niko Matsakis&rsquo;s blog post
<a href="http://smallcultfollowing.com/babysteps/blog/2013/01/17/destructors-and-finalizers-in-rust/">Destructors and Finalizers in Rust</a>.  I started composing it as a comment there,
but eventually realized I needed more breathing room.)</p>

<p>I agree wholeheartedly with Niko&rsquo;s statement that the Boehm paper
<a href="http://www.hpl.hp.com/techreports/2002/HPL-2002-335.html">&ldquo;Destructors, Finalizers, and Synchronization&rdquo;</a> is a really nice
discussion of this topic.
However, a significant portion of the destructor/finalizer design space is
only briefly discussed in that paper, and I worry that Niko&rsquo;s post overlooks
it.</p>

<!-- more -->


<p>There are designs that do not run finalizers directly from the garbage
collection process (whether that collector be a coroutine with the mutator, or
a concurrently running thread), and instead run finalization code
at explicit points in the code of the mutator (or mutator threads).</p>

<p>To me, such an approach seems appropriate for systems-level programming;
it seems to align with the spirit of giving the programmer access to the set of
knobs they need for explicit sequencing and resource management (or rope
to hang themselves with).</p>

<a name="Explicit.Cleanup"></a>
<h2>Explicit Cleanup</h2>

<p>In the <a href="http://www.cs.indiana.edu/~dyb/pubs/guardians-pldi93.pdf">guardian</a> and <a href="http://www.oracle.com/technetwork/articles/javase/finalization-137655.html">reference-queue</a> family of systems (see
also <a href="http://docs.racket-lang.org/reference/willexecutor.html">wills and executors</a>), resource cleanup code is no longer asynchronously
run by the GC.  Instead, cleanup is the obligation of the
mutator.  The only asynchronous cleanup action of the garbage collector
is to add entries to the appropriate guardians/reference queues (that is, the
queues associated with an object that has been appropriately registered and
subsequently discovered to be unreachable).</p>

<p>I have included a more explicit description of what a Guardian API is like in
the appendix at the end of this blog post, in case the previous paragraph was
too terse.</p>

<p>With such an API in hand, developers can build <a href="http://repository.readscheme.org/ftp/papers/sw2010/02-hsu.pdf">libraries</a> that one can
plausibly reason about, in a single- or multi-threaded context.</p>

<p>To be fair: Boehm <em>does</em> address these approaches briefly; see the beginning
of section 3.5.1 of his paper, &ldquo;Explicit Finalizer Invocation&rdquo;.  However,
he also mixes them in with Java&rsquo;s <code>System.runFinalization()</code> and the motivation
for that method.  Thus one must take care to distinguish which of Boehm&rsquo;s complaints
apply to all explicit finalization systems, and which apply solely to systems
such as Java with <code>runFinalization</code> that provide a mix of explicit and implicit finalization.</p>

<a name="Passing.the.Buck"></a>
<h2>Passing the Buck</h2>

<p>One important characteristic (some might say &ldquo;drawback&rdquo;) of explicit
finalization approaches is that the mutator does need to periodically process
its associated guardians/reference queues.  After all, with the transfer of
responsibility for cleanup from the collector to the mutator, the mutator must
meet this obligation eventually.</p>

<p>One standard way to do this is to sprinkle cleanup code (i.e. &ldquo;check if
guardian has entries; if so, process some of them&rdquo;) at points in the control
flow of library routines using that guardian.  (In other words, in languages
with guardians, library designers can hopefully isolate the cleanup code behind the interface of the library that
requires such cleanup.)</p>

<p>In fact, since there are distinct guardians/reference-queues, one can
prioritize the scheduling (i.e. frequency and incremental-cost) of the
cleanups according to the characteristics of individual libraries, within the
mutator.  Contrast this against relying on the scheduling of the garbage collector with its
single finalization queue for the whole heap.</p>

<p>The two main problems with explicit cleanup from my point of view are:</p>

<ol>
<li><p>ensuring that the necessary processing does <em>eventually</em> happen
(i.e. prevent resource leaks when control does not often (or ever) flow back into the
developer&rsquo;s library utilizing the guardian), and</p></li>
<li><p>inserting finalizer invocations across the code of a library detracts
from its readability; they are a clear example of a cross-cutting concern that
should be factored into its own &ldquo;aspect.&rdquo;</p></li>
</ol>


<p>Boehm essentially covers both of the points above (though on first reading I
only interpreted him as describing the second point):</p>

<blockquote><p>This appears to be the safest way to handle finalization in single-threaded
code, although it has some clear disadvantages in certain contexts:
Potentially large amounts of code, especially long running routines, must be
explicitly sprinkled with finalizer invocations.</p></blockquote>

<p>In the very worst case, in a &ldquo;normal&rdquo; imperative language with concurrent
threads, these last two drawbacks could be addressed by the client-developer:
the client-developer can set their associated cleanup code to run on a
distinct thread (that the <em>mutator</em> manages, not the garbage collector).  This
avoids the ugly sprinkling/cross-cutting of concerns, and should ensure that
cleanup does eventually occur (assuming correctly-written multi-threaded code,
&ldquo;ha ha&rdquo;).</p>

<p>Of course, that last suggestion is essentially reimplementing the GC&rsquo;s
finalizer thread as a mutator process.  But nonetheless, in principle this
could be implemented as a library, as long as the appropriate primitives are
available underneath.</p>

<p>By making explicit finalization expressible as a library,
the developer community would be free to propose competing API&rsquo;s
and implementations.  That seems like a good thing for a young
experimental language.</p>

<p>(One <em>might</em> even be able to develop finalization
libraries that are &ldquo;composable&rdquo;, in the sense that different finalization
libraries could be used by distinct libraries in the same overall program.
One could coin the term
<a href="http://en.wikipedia.org/wiki/Decomposing_Composers">&ldquo;composing decomposers&rdquo;</a>
for such things.)</p>

<a name="Wait..what.was.that.about..normal..languages."></a>
<h2>Wait, what was that about &ldquo;normal&rdquo; languages?</h2>

<p>I wrote the end of the previous section intending for it to apply to Rust.
Then I realized that I do not have enough experience writing Rust programs to
be certain it is reasonable to develop a mutator-based cleanup process
that runs on its own thread.</p>

<p>I am only discussing cleanup for structures held in managed-boxes (not in
owned-boxes or stack-allocated).  It might be feasible to express cleanup
routines for managed boxes with relatively trivial types in Rust, at least for
some libraries.</p>

<p>But it might be that in practice, managed boxes would generally have
types that would make it impossible for a separate thread to extract them from
a guardian and be able to access their contents.</p>

<p>There is also the serious problem that such a cleanup thread seems likely to require
the use of mutex locks in order to coordinate with the &ldquo;real&rdquo; mutator; this in
particular seems antithetical to the ideals of Rust.</p>

<p>(Hopefully I will soon acquire sufficient experience with Rust itself to be
able to address this issue more coherently.)</p>

<!---

----

Another idiosyncrasy with a lot of the guardian-like systems is that they
enqueue the original object for processing, which is quite counter-intuitive
when one considers the effort that the GC went through to determine that the
object was otherwise unreachable.

This perhaps could be addressed by using something like the model described at
the start of section 3.1 of Boehm's paper, "Alternatives"; namely, instead of
enqueuing the unreachable object on a reference queue, the GC could instead
enqueue an associated distinct cleanup object. Boehm states that such a
cleanup object falls victim to all the same problems, but as I understand it,
that is only true if it is invoked by the GC in the same way that Java-style
finalizers are invoked, as described in his paper.

It would be interesting to know whether any managed runtimes offer only
guardians/reference-queues with this style of distinct associated cleanup
objects; I am not aware of any myself.  I might attempt to hack one up in the
future.

--->


<a name="Conclusion"></a>
<h2>Conclusion</h2>

<p>I am not saying this is easy, and I am not saying that the systems I am
referencing get everything right either.  But implicit finalizers, even those invoked
from a system-managed asynchronous thread, are not the only answer.</p>

<p>Perhaps my pithy summary is that: Implicit finalizers are indeed inherently
asynchronous routines; but with explicit finalization, one has more options
(yet still may be able to fall back on asynchrony if necessary).</p>

<p>So, what does all of this mean for Rust?  Well, Niko already suggested
limiting destructors solely to types that contain only &ldquo;owned data.&rdquo;</p>

<p>I have no problem with that, since it clearly deals with all of the issues
that Boehm described.</p>

<p>But my suspicion is that Rust developers will soon discover that one really
does need the GC to feed information forward about the managed boxes that it
is collecting.  And so we will then be at a crossroads: Put in Java-style
finalizers, or adopt another approach?</p>

<p>My goal is to make sure we remember to consider those other approaches when we
hit that crossroads.</p>

<a name="References"></a>
<h2>References</h2>

<ol>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2013/01/17/destructors-and-finalizers-in-rust/">&ldquo;Destructors and Finalizers in Rust&rdquo;</a>
<br/>Niko Matsakis
<br/>Blog post, 2013</li>
<li><a href="http://www.hpl.hp.com/techreports/2002/HPL-2002-335.html">&ldquo;Destructors, Finalizers, and Synchronization&rdquo;</a>
<br/>Hans Boehm
<br/>HP Tech Report; POPL 2003</li>
<li><a href="http://www.cs.indiana.edu/~dyb/pubs/guardians-pldi93.pdf">&ldquo;Guardians in a Generation-Based Garbage Collector&rdquo;</a>
<br/>Dybvig, Bruggeman, and Eby
<br/>PLDI, 1993</li>
<li><a href="http://www.oracle.com/technetwork/articles/javase/finalization-137655.html">&ldquo;How to Handle Java Finalization&rsquo;s Memory-Retention Issues&rdquo;</a>
<br/>Tony Printezis
<br/>Tech Report, 2007</li>
<li><a href="http://docs.racket-lang.org/reference/willexecutor.html">&ldquo;Wills and Executors&rdquo;</a>
<br/>PLT Racket Reference Documentation</li>
<li><a href="http://repository.readscheme.org/ftp/papers/sw2010/02-hsu.pdf">&ldquo;Implementing User-level Value-weak Hashtables&rdquo;</a>
<br/>Aaron Hsu
<br/>Scheme Workshop 2010
<br/>(I only properly appreciated the value (and difficulties) of using guardians for such purposes after I read this paper)</li>
</ol>


<a name="Appendix.A..What.are.Guardians."></a>
<h2>Appendix A. What are Guardians?</h2>

<p>I here outline a concrete example of how this works in the case of Guardians
(adapted from <a href="http://repository.readscheme.org/ftp/papers/sw2010/02-hsu.pdf">Hsu</a>).  (To aid readability, I have replaced the use of
procedure-arity-based-dispatch, as written by Hsu to match the Chez Scheme
API, and I am rewriting his example with a new distinct named procedures .)</p>

<p>One can construct as many guardian instances (or simply &ldquo;guardians&rdquo;) as one wants.
Each guardian is associated with two things:</p>

<ol>
<li><code>reclaimable</code> : a set of objects previously determined to be reclaimable by the garbage collector, and</li>
<li><code>registry</code> : a set of objects scheduled to be eventually enqueued in the first set.</li>
</ol>


<p>Both of these sets are initially empty when the guardian is constructed.</p>

<pre><code>&gt; (define g (make-guardian))
&gt; (define v "VAL")
&gt; (define p (weak-cons v '())
&gt; (guardian-register! g v)

&gt; (set! v #f)                    ;; Now `"VAL"` is unreachable via strong-refs ...
&gt; (guardian-fetch! g)            ;; ... but GC has not discovered that yet.
#f

&gt; (collect-garbage)              ;; `"VAL"` is still unreachable ...
&gt; p                              ;; ... though one can access via weak paths ...
("VAL")
&gt; (define x (guardian-fetch! g)) ;; ... and the guardian held it in `reclaimable`
&gt; x
"VAL"

                                 ;; At this point, "VAL" is again strongly reachable
                                 ;; (via `x`).  However, it is *not* in either of the
                                 ;; sets for the guardian `g`, and thus is not scheduled
                                 ;; to be enqueued in the `reclaimable` set.

&gt; (set! x #f)                    ;; Now "VAL" is no longer strongly reachable...
&gt; (collect-garbage)
&gt; p                              ;; ... and thus can be reclaimed.
(#!blank-weak-pointer)
</code></pre>

<p>So, what does this have to do with finalization?</p>

<p>With the guardian API in hand, one could take care of closing individual
file descriptors associated with heap-allocated file objects, by
a protocol such as:</p>

<ol>
<li><p>Create one guardian G for the file library, whose sole purpose is closing
file descriptors.</p></li>
<li><p>In the constructor for file objects, register each constructed file object
with G.</p></li>
<li><p>In a periodic process, dequeue objects from G and close their associated
file descriptors.</p></li>
</ol>


<a name="Appendix.B..Another.peeve.about.guardians"></a>
<h2>Appendix B. Another peeve about guardians</h2>

<p>One idiosyncrasy about a lot of the guardian-like systems is that they enqueue
the original object for processing, which is quite counter-intuitive to me
given the effort that the GC went through to determine that the object was
otherwise unreachable.</p>

<p>Perhaps this could be addressed by using something like the model described at
the start of section 3.1 of Boehm&rsquo;s paper, &ldquo;Alternatives&rdquo;; namely, instead of
enqueuing the unreachable object on a reference queue, the GC could instead
enqueue an associated distinct cleanup object, and reclaim the originally
registered object itself. (Boehm states that such a cleanup object falls
victim to all the same problems, but as I understand it, that is only true if
it is invoked by the GC in the same way that Java-style finalizers are
invoked, as described in his paper.)</p>

<p>The associated cleanup object would need to carry any state necessary for the
cleanup action (e.g., the file descriptor itself).  So that seems like a
potential for ugly redundancy and wastage (in either time or space, depending
on whether uses a level of indirection or simply redundantly stores all the
necessary state in the object and in its associated cleanup object.).</p>

<p>But nonetheless, a decoupled system like this may be easier to reason about,
especially when one has scenarios where an object is registered with multiple
guardians/reference-queues.</p>

<p>As far as I understand, the reference queue system in Java, as described by
<a href="http://www.oracle.com/technetwork/articles/javase/finalization-137655.html">Printezis</a>, is sufficient to express a structure like this.  Still, it
would be interesting to know whether any managed runtimes offer <em>only</em>
guardians/reference-queues with this style of distinct associated cleanup
objects; I am not aware of any that are so conservative.  I might attempt to
hack one up in the future.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Resurrected (Hello Again World)]]></title>
    <link href="http://blog.pnkfx.org/blog/2013/01/08/resurrected-hello-again-world/"/>
    <updated>2013-01-08T00:55:00+01:00</updated>
    <id>http://blog.pnkfx.org/blog/2013/01/08/resurrected-hello-again-world</id>
    <content type="html"><![CDATA[<a name="It.s.Clobbering.Time"></a>
<h2>It&rsquo;s Clobbering Time</h2>

<p>Remember that thing I said back <a href="http://blog.pnkfx.org/blog/2012/12/31/hello-world">at the end of 2012</a>?
That thing?
That thing about the important detail that:</p>

<blockquote><p>the <code>_deploy/</code> subdirectory is itself a clone of the targeted
github repository, with the <code>gh-pages</code> branch checked out.</p></blockquote>

<p>It turns out this is really important detail.</p>

<p>Here&rsquo;s why: For my first blogging act of the new year, I inadvertently destroyed
my own blog.</p>

<!-- more -->


<p>I attempted to write a post from a computer other than the one out of
which I had already worked all the octopress-compatibility kinks.
In the hustle of dealing with <code>rbenv</code> and various other ruby-oriented
dependencies, I forgot about the detail above.</p>

<p>And then when I ran <code>rake deploy</code>, I clobbered the live blog.</p>

<p>I may have been recovering from, or incapacitated by, New Years
revelry at the time, it is not clear to me at the current moment.  I
believe I identified the disaster right after it happened, but immediately
decided I did not have the time then to diagnose it, fix it,
or even to attempt to rollback the
state and repush to github.  I vaguely remember considering that last option
and deciding that even that was out of the question.  (I think a pending
trip to a Karaoke bar may have been involved in the decision-making
process here.)</p>

<p>So, tonight I diagnosed and fixed the problem.</p>

<p>At first I was just going to let the matter lie undocumented, and
pretend like it never happened.</p>

<p>But I realized that I may well again make the same mistake in the future,
and that it behooved me to at least document the issue in my commit
log for <a href="https://github.com/pnkfelix/pnkfx-blog/commits/blog.pnkfx.org">the blog source</a>.</p>

<p>And after writing that commit log entry and pushing it, I decided that
this story was in fact blog worthy; after all, what is the point of
a blog if not to freely broadcast your mistakes?  :)</p>

<p>So, directly from <a href="https://github.com/pnkfelix/pnkfx-blog/commit/f277b041de33a8e0eac02c6aecb3909231725db7">my commit message</a>, here is the description of how
I clobbered my own blog:</p>

<blockquote><p>The easy way to sum it up is: The model
employed by octopress when deploying to github is this: Your <em>deploy/
subdirectory must contain a checkout of the target repo, the one with
the gh-pages branch, and you must have that </em>deploy/ subdirectory
checked out and ready to go before running &lsquo;rake deploy&rsquo;.</p>

<p>If you do not have a _deploy/ subdirectory at all and you let &lsquo;rake
deploy&rsquo; create it for you but you also let &lsquo;rake deploy&rsquo; attempt to
push to github, and you are also managing the source itself on github,
you will enter a world of pain where the rake invocation will push
<em>this</em> root directory, presumably in the master branch (or in my case,
blog.pnkfx.org branch) to the target repo in the gh-pages/ branch.
Which will bust things terribly, especially if that causes the CNAME
file to get deleted from the gh-pages/ branch of the target repo.</p></blockquote>

<a name="A.note.on.self-reference"></a>
<h2>A note on self-reference</h2>

<p>Also, a quick half shout-out, or maybe corrective note, to
<a href="http://www.seamusbradley.net/blog/blog/2012/04/24/how-to-link-to-your-own-blog-posts-in-octopress/">seamusbradley</a> for pointing out some details about linking back to
one&rsquo;s own blog posts.</p>

<p>It is only a half shout-out because Seamus&rsquo;s note is only useful, I
think, if you have, like him, a customized setting for the <code>root:</code> in
your <code>_config.yml</code>.  That, or Seamus has confused himself and changed
his <code>root</code> setting in order to accommodate other url&rsquo;s that he
observed, but those urls are in fact actually generated by settings
for properties other than <code>root</code>.</p>

<p>Here&rsquo;s the concrete details: I read (misread?) Seamus&rsquo;s post at first
as saying that a customized setting of <code>root</code> to <code>/blog</code> is a
prerequisite for linking to your own posts.  It seems to me that the
relevant detail is what the <em>permalink</em> setting is, not the root.
(But then again, I have not played with changing my root setting,
apart from finding that when I did try changing it to <code>/blog</code> as
Seamus suggested, it seems like doing so broke <code>rake preview</code>.)</p>

<p>In my case, the <code>root</code> and <code>permalink</code> for my <code>_config.yml</code>
are set as follows:</p>

<pre><code>root: /
permalink: /blog/:year/:month/:day/:title/
</code></pre>

<p>and I format links to my own posts, such as the one you are reading,
like so:
<a href="http://blog.pnkfx.org/blog/2013/01/08/resurrected-hello-again-world"><code>/blog/2013/01/08/resurrected-hello-again-world</code></a>
as you can see from looking at the source for the line above,</p>

<pre><code>[`/blog/2013/01/08/resurrected-hello-again-world`](/blog/2013/01/08/resurrected-hello-again-world)
</code></pre>

<p>A bit of quoted self-reference is a good place to stop for the night.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OS X tiled window management with Slate]]></title>
    <link href="http://blog.pnkfx.org/blog/2013/01/02/osx-tiled-window-management/"/>
    <updated>2013-01-02T22:34:00+01:00</updated>
    <id>http://blog.pnkfx.org/blog/2013/01/02/osx-tiled-window-management</id>
    <content type="html"><![CDATA[<p>I recently discovered <a href="https://github.com/jigish/slate" title="Slate: github repository">Slate</a>, an
open-source window-management tool for Mac OS X.</p>

<p>It is very cool, mainly in that it is very configurable (but with a
reasonably readable syntax for its configuration file).</p>

<!-- more -->


<p>Perhaps the most important thing to say is: Do not judge it solely
based upon its default configuration file, which is very bare bones
and does not illustrate anything near the full feature set that it
offers.</p>

<p>Instead, I recommend one at least read over Tristan Hume'e <a href="http://thume.ca/howto/2012/11/19/using-slate/" title="Tristan Hume: Using Slate">blog post</a>,
which advertises Slate much more effectively than the project&rsquo;s
github page.  The blog post describes some of the crucial features that are not
exposed in the default configuration.  In particular, the
window-switcher shortcut, which overlays each window with a
letter to give that window focus, is much more tile-friendly
if you also turn on</p>

<pre><code>config windowHintsIgnoreHiddenWindows false
config windowHintsShowIcons true
</code></pre>

<p>You can see this and other custimzations I have made for myself
in my own <code>.slate</code> file, which I keep with my other dotfiles in
<a href="https://github.com/pnkfelix/DotFiles/blob/master/slate" title="Felix's DotFiles github repo">my public repository</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello World]]></title>
    <link href="http://blog.pnkfx.org/blog/2012/12/31/hello-world/"/>
    <updated>2012-12-31T14:34:00+01:00</updated>
    <id>http://blog.pnkfx.org/blog/2012/12/31/hello-world</id>
    <content type="html"><![CDATA[<!---
Apparently Markdown syntax does not have any shorthand for comments
-->




<!---
First 7 lines of this file were generated by command invocation:
  % rake new_post["Hello World"]
-->


<p>First post!
I am attempting to move my blog to GitHub Pages.</p>

<p>After seeing the results of others, I figure I will start with Octopress
and see how that goes.</p>

<!-- more -->


<p>Just so I can remind myself of the Octopress basics in the immediate future:</p>

<ul>
<li><p>Much of the page generation is controlled by configuration file <code>_config.yml</code></p></li>
<li><p>The content is all stored in <code>source/_posts/</code></p></li>
<li><p>This particular entry corresponds to the file <code>2012-12-31-hello-world.markdown</code></p></li>
<li><p>The first 7 lines of that file were originally generated via the
<code>rake</code> command invocation:</p>

<pre><code>% rake new_post["Hello World"]
</code></pre></li>
<li><p>The command <code>rake generate</code> will convert the source into static html pages.</p></li>
<li><p>After generating the file (and during subsequent editting), one can preview
the state locally in a local Ruby webserver via:</p>

<pre><code>% rake preview
</code></pre>

<p>and then <a href="http://localhost:4000/">browsing localhost port 4000</a>.
The <code>rake preview</code> invocation will continuously monitor your post
source files so that you can keep working on your post and then
reload in your web browser without rerunning <code>rake</code> itself.</p></li>
<li><p>The command <code>rake deploy</code> is supposed to deploy the content into its intended
live location.  I have been having difficulty using this command,
in part because I think it is written assuming you have your ssh-key
already set up and integrated with github (or something similar) so that
there would be no password prompts.</p>

<ul>
<li><p>But of course I have not done this yet.</p></li>
<li><p>One important detail about <code>rake deploy</code> with github pages is that
the <code>_deploy/</code> subdirectory is itself a clone of the targetted
github repository, with the <code>gh-pages</code> branch checked out.
This can be confusing if your main source tree (the parent
directory of <code>_deploy/</code>) is itself the same repository as the
targetted github repository.</p></li>
</ul>
</li>
<li><p>Update: <code>rake deploy</code> just worked fine for me, password prompts and all.
I think my earlier difficulty was an artifact of some previous bad
state, one of either:</p>

<ul>
<li><p>I had put in a malformatted url for the target repository</p></li>
<li><p>My target repository already had a <code>gh-pages</code> branch (from earlier
testing) that needed to be pulled-and-merged (or discarded in some
fashion, which was what my merge amounted to).</p></li>
</ul>
</li>
<li><p>Update (26 march 2012): there are still some hiccups with <code>rake deploy</code>;
you need to be careful about what you store in the <code>source/</code> directory.
In particular, I was working on a draft post and threw various
source files that I was hacking on in the same directory, along with
some <code>.gitignore</code> files so that <code>git</code> would ignore build products
generated when I compiled the source (to binaries or jars or fasls&hellip;).</p>

<p>The headache came when I did <code>rake deploy</code>, and hit this error:</p>

<pre><code class="bash">% rake deploy
cp -r source/_posts/.gitignore public/_posts/.gitignore
rake aborted!
No such file or directory - public/_posts/.gitignore
/Users/pnkfelix/Dev/Sites/pnkfx-blog/Rakefile:230:in `block (2 levels) in &lt;top (required)&gt;'
/Users/pnkfelix/Dev/Sites/pnkfx-blog/Rakefile:229:in `block in &lt;top (required)&gt;'
/Users/pnkfelix/Dev/Sites/pnkfx-blog/Rakefile:219:in `block in &lt;top (required)&gt;'
Tasks: TOP =&gt; copydot
(See full trace by running task with --trace)
%
</code></pre>

<p>The problem here, as far as I can tell, is that octopress
is aggressively trying to copy over all dotfiles it can find
(<a href="https://github.com/imathis/octopress/issues/104">Octopress Issue 104</a>)
and that code was not written to create any subdirectories as
necessary.</p>

<p>My Ruby development knowledge is sufficiently under-developed that I
am not going to try to fix this myself.  Instead I have simply
moved all of the source code I was hacking <em>out</em> of the <code>source/</code>
directory and into a separate <code>hacks/</code> directory.
This seems to have addressed the problem; I have also filed
<a href="https://github.com/imathis/octopress/issues/1151">an issue</a>
for this with Octopress.</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
