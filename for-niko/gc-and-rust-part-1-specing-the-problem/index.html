
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>GC and Rust Part 1: Specifying the Problem (... now you have two problems) - The {pnk}f(eli)x Blog</title>
  <meta name="author" content="Felix S. Klock II">

  
  <meta name="description" content="This is the first in a series of posts will discuss why garbage
collection is hard, especially for Rust, and brainstorm about
solutions to the &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://blog.pnkfx.org/blog/2015/10/28/gc-and-rust-part-1-specing-the-problem/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="The {pnk}f(eli)x Blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">The {pnk}f(eli)x Blog</a></h1>
  
    <h2>The informal ramblings of an ex-pat PL enthusiast</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:blog.pnkfx.org" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">GC and Rust Part 1: Specifying the Problem (... Now You Have Two Problems)</h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-28T15:24:00+01:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>This is the first in a series of posts will discuss why garbage
collection is hard, especially for Rust, and brainstorm about
solutions to the problems we face.</p>

<p>The relationship between garbage collection (GC) and the Rust
programming language has been an interesting one.</p>

<p>GC was originally deeply integrated into the language, complete with
dedicated syntax (good old <code>@T</code> &hellip;). Over time the team found ways to
lessen the dependency on GC, and then finally remove it from the
language entirely.</p>

<p>However, we still want to provide support for garbage collection.</p>

<p>To explain why, I need to define the actual problems we seek to solve.</p>

<!-- more -->


<p>(The body of this post makes heavy use of client-side rendering,
because of author idiosyncrasies.  You may need to wait a moment while
the supporting Javascript loads.)</p>

<script src="https://cdn.rawgit.com/pnkfelix/pnkfx-blog/for-niko/source/javascripts/viz.js" charset="utf-8"></script>


<script src="https://rawgit.com/pnkfelix/pnkfx-blog/for-niko/source/javascripts/js_to_dot.js" charset="utf-8"></script>


<script src="https://rawgit.com/pnkfelix/pnkfx-blog/for-niko/source/javascripts/gc_rendering.js" charset="utf-8"></script>


<h2>The Problem Space</h2>

<p>Now that we have <a href="/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work/">reviewed</a> what GC is and how it works, let us
discuss what GC could mean to Rust.</p>

<p>I have identified two distinct kinds of support that we could provide:
a feature for pure Rust programs, versus an 3rd-party runtime
interoperation feature.</p>

<h3>GC for pure Rust programs</h3>

<p>We could add a smart-pointer interface, e.g. a <code>Gc&lt;T&gt;</code> type, that
arbitrary library crates could use as they create or receive instances
of <code>T</code>. The intention here would be similar to how <code>Rc&lt;T&gt;</code> is used:
One does not want to track ownership precisely, but rather treat
ownership as shared amongst all users of a value, and let the runtime
system handle reclaiming the value.</p>

<p>This kind of feature could be useful in any Rust library.</p>

<p>There are two easy-to-identify drawbacks with this kind of collector
support.</p>

<p>First, adding it would require that the standard library either
provide a garbage collector (that all clients of <code>Gc&lt;T&gt;</code> would have to
link in), or at least standardize a fixed API that third-party
collector implementations would have to satisfy to support <code>Gc&lt;T&gt;</code>.</p>

<p>Second, it is difficult to provide the ergonomics (such as
<a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a> support) that one expects from a smart-pointer
type analogous to <code>Rc&lt;T&gt;</code>.</p>

<p>Since <code>Rc&lt;T&gt;</code> is already a workable solution for many (though not all)
use cases of <code>Gc&lt;T&gt;</code>, it is not a main priority right now.</p>

<h3>GC as Interoperation Feature</h3>

<p>GC as an interoperation feature means that Rust would provide
introspective hooks to improve integration with application frameworks
that are using their own garbage collector. An obvious example of this
is Servo&rsquo;s use of the SpiderMonkey Virtual Machine for its Javascript
support.</p>

<p>Servo is relying on SpiderMonkey&rsquo;s garbage collection for memory
management, not only for Javascript values, but even for
<a href="https://blog.mozilla.org/research/2014/08/26/javascript-servos-only-garbage-collector/">native-code DOM objects</a>.</p>

<p>That post describes (unchecked) scenarios where one can end up with
dangling pointers &ndash; that is, they invite unsoundness.  Proper support
for GC-interoperation in Rust could address this; I will discuss this
further down in this post.</p>

<p>Critically, GC-interoperation does not require the same level of
programmer ergonomics that <code>Rc&lt;T&gt;</code> provides. For example, it is
acceptable in that context to not support <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a>.</p>

<p>Without a <code>Deref</code> trait, such interoperation might end up looking
something like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">double_last</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">Gc</span><span class="o">&lt;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">unsafe</span> <span class="p">{</span>
</span><span class='line'>        <span class="kd">let</span> <span class="n">ptr</span><span class="o">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">get_ptr</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// during the extent of this block, it is my responsibility to</span>
</span><span class='line'>        <span class="c1">// ensure the GC never gets invoked (i.e., do not do any</span>
</span><span class='line'>        <span class="c1">// allocations to GC heap during this unsafe-block).</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="nb">Some</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">).</span><span class="n">last_mut</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>            <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Interoperation still requires defining a standard interface that the
third-party collector implementation has to conform with.</p>

<p>In a simple world (e.g., a conservative collector designed to
interoperate with C/C++, such as <a href="http://www.hboehm.info/gc/">boehm-demers-weiser</a>), this
standard interface could be nothing more than just &ldquo;swap in a
different <a href="https://doc.rust-lang.org/nightly/book/custom-allocators.html"><code>#[allocator]</code> crate</a> that your GC provides.&rdquo;</p>

<p>(The actual interface is unlikely to be so simple, but the point is,
there is a wide design space to be explored here.)</p>

<h3>Objectives and Requirements</h3>

<p>The two kinds of support described above are two distinct features;
there is overlap between them, but trying to find a single solution
that solves both problems completely may not be possible, and in any
case we do not want to wait for it to be discovered.</p>

<p>There are a number of other objectives for Rust/GC integration that
are worth noting, which I will list here and then define and discuss
below.</p>

<ol>
<li><a href="#modularity">Modularity</a></li>
<li><a href="#safety">Safety</a></li>
<li><a href="#zero-cost">Zero-Cost</a></li>
<li><a href="#compositionality">Compositionality</a></li>
<li><a href="#precision">Precision</a></li>
</ol>


<h3><span id="modularity">Modularity with respect to GC</span></h3>

<p>A Rust program that uses GC should be able to link with a crate whose
source code was authored without knowledge of GC.</p>

<p>For example, if I make a parsing library today that works on string
slices, you should be able to link that parsing library into a program
that uses GC, without having to worry about whether the parsing
library carries hidden requirements that invalidate linking its crate
together with yours.</p>

<p>Note: A crate being &ldquo;authored without knowledge of GC&rdquo; is a
property of the source code, not the generated object code. Given
such a crate, the Rust compiler may itself inject metadata
related to GC, such as descriptiohs of object layout, or
automatically-generated code that dictate how objects should
traced by the collector.</p>

<p>Note: A crate being &ldquo;authored without knowledge of GC&rdquo; is not
quite the same as that crate not supporting GC. That is, we may
add well a way for a crate to declare that it is not compatible
with GC. (This would count as having knowledge of GC; in fact,
enough knowledge to know, or at least guess, that the presence of
a GC would cause the crate to break.)</p>

<p>If we cannot satisfy this requirement, then the addition of GC
will, at best, split the growing space of library crates (such as
those available on <a href="https://crates.io/">crates.io</a>) into two disjoint
sub-communities: crates that support GC, and those that do not
(since the latter were written without accounting for the
potential presence of a GC).</p>

<p>A final note: There are some features available to crates, such as
requiring a specific low-level allocator, that are likely to be
incompatible with a program that uses GC. I need to find a way to
incorporate these caveats into the above definition of &ldquo;modularity&rdquo;,
without weakening it to the point of uselessness.</p>

<h3><span id="safety">Safety with respect to GC</span></h3>

<p>If a Rust crate does not use <code>unsafe</code> constructs
(<code>unsafe</code> blocks, attributes or types with &ldquo;unsafe&rdquo; in their
name, etc.), then linking it with another crate that uses GC
should be guaranteed to maintain soundness.</p>

<p>In other words, linking in a crate C that uses no <code>unsafe</code>
construct should not inject any dereferences of dangling
pointers, nor any data races.</p>

<p>This objective arguably could be lumped in with modularity.</p>

<p>I list it as a separate item, because (I claim) it is a non-goal for
the Rust compiler itself to ensure safety if I start with a sound
program, and then I swap one of its sub-crates with some arbitrary
other crate, <code>C</code>, that uses <code>unsafe { ... }</code>. But it should still be
feasible to compile and run the new version linked with <code>C</code>, even if
it is no longer guaranteed to be safe.</p>

<p>By the way, we absolutely do need to provide criteria that says what
<code>unsafe</code> code <em>is</em> allowed to do when linked with a crate that uses
GC. I am going to assume for these initial posts that we will solve
that problem eventually, but not attempt to address it at the outset.</p>

<h3><span id="zero-cost">Zero-Cost GC</span></h3>

<p>If you don&rsquo;t use the GC feature (in whatever form it takes), your code
should not pay for it.</p>

<p>This applies to the quality of the generated code (in execution
time and code size), and also to the source code, with respect to
difficulty in writing a program or library.</p>

<h3><span id="compositionality">Compositional GC</span></h3>

<p>One can use a reference to a gc-allocated object, call it a <code>GcRef</code>,
as the field type in a <code>struct</code>, store it into a <code>Vec&lt;GcRef&gt;</code>, and
generally anything else one can do with a Rust value.</p>

<p>Furthermore, one should be able to describe, via a Rust type
definition, the layout of a value allocated on the GC heap, allocate
such values there, and acquire a suitable <code>GcRef</code> to the allocated
object.</p>

<p>To be concrete about this, consider the following program,
which uses a hypothetical <code>make_gc_ref</code> function to move
values into a newly-allocated spot on the GC heap, and returns
a reference to that spot. (In the future one will probably use
the <code>box</code> syntax for this, and rely on type-context to inform
box that this is a GC-allocation.)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">demo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">gc_v</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>        <span class="kd">let</span> <span class="n">ref_x1</span> <span class="o">=</span> <span class="n">make_gc_ref</span><span class="p">(</span><span class="s">&quot;data_one&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="kd">let</span> <span class="n">ref_x2</span> <span class="o">=</span> <span class="n">make_gc_ref</span><span class="p">(</span><span class="s">&quot;data_two&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="kd">let</span> <span class="n">v</span> <span class="o">=</span> <span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">];</span>
</span><span class='line'>        <span class="n">make_gc_ref</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This results in the following diagram:</p>

<p id="target_anchor_demo_composition_1"></p>


<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var rust_heap = { rankdir:"LR", id: "cluster_rust_heap", label: "Rust Heap", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };

var x1 = object_record("X1", "<f0> 'data_one'");
var x2 = object_record("X2", "<f0> 'data_two'");

x1.style = "rounded";
x2.style = "rounded";

var gc_v = { id: "gc_v", label: "Gc(V)", shape: "record" };

var v = object_record("V", "<f0> len: 3 | cap: 4 | <f2> ptr: Arr");
v.style = "rounded";
var arr = object_record("Arr", "<f0> Gc(X1) | <f1> Gc(X1) | <f2> Gc(X2)");
arr.color = "blue";

v.f2 = edge_from_to_ports(":f2", ":id", arr);
gc_v.f0 = edge_to_port(":id", v);

arr.f0 = edge_from_to_ports(":f0", ":id", x1);
arr.f1 = edge_from_to_ports(":f1", ":id", x1);
arr.f2 = edge_from_to_ports(":f2", ":id", x2);

stack[0] = gc_v;
rust_heap[0] = arr;
gc_heap[0] = v;
gc_heap[1] = x1;
gc_heap[2] = x2;

var objects = [stack, gc_heap, rust_heap];
post_objects("target_anchor_demo_composition_1", objects, { rankdir:"LR", nodesep:0.2 });
</script>


<p>Here, I have made explicit the heap-allocated backing store <code>Arr</code> (in
blue) for the vector that holds the references to <code>x1</code> and <code>x2</code>.</p>

<p>This shows that if we want GC to reasonably usable (i.e., allow GC
references to be used like other Rust values), we need to support
references out of the GC heap and into the Rust heap, and likewise
references out of the Rust heap and into the GC heap.</p>

<p>It can sometimes be simpler (without necessarily eliminating the
fundamental problem) to just a <code>Box</code> rather than a <code>Vec</code>:</p>

<p id="target_anchor_demo_composition_2"></p>


<script>
var stack = { id: "cluster_stack", label: "Stack", is_subgraph: true };
var rust_heap = { rankdir:"LR", id: "cluster_rust_heap", label: "Rust Heap", is_subgraph: true };
var gc_heap = { id: "cluster_gc_heap", label: "GC Heap", is_subgraph: true, style: "rounded" };
var c = object_record("C", "<f0> Gc(X) | <f1> Box(O)");
c.style = "rounded";
var o = object_record("O", "<f0> Gc(X)");
var x = object_record("X", "<f0> 'data'");
x.style = "rounded";
var gc_a = { id: "gc_c", label: "Gc(C)", shape: "record" };

gc_a.f0 = edge_to_port(":id", c);

o.f0 = edge_from_to_ports(":f0", ":id", x);

c.f0 = edge_from_to_ports(":f0", ":id", x);
c.f1 = edge_from_to_ports(":f1", ":id", o);

stack[0] = gc_a;
rust_heap[0] = o;
gc_heap[0] = c;
gc_heap[1] = x;

var objects = [stack, gc_heap, rust_heap];
post_objects("target_anchor_demo_composition_2", objects, { rankdir:"LR", nodesep:0.2 });
</script>


<p>The program to construct the above picture might look like
this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">demo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">C</span><span class="p">(</span><span class="n">Gc</span><span class="o">&lt;</span><span class="kt">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Box</span><span class="o">&lt;</span><span class="n">Gc</span><span class="o">&lt;</span><span class="kt">str</span><span class="o">&gt;&gt;</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">gc_c</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>        <span class="kd">let</span> <span class="n">ref_x</span> <span class="o">=</span> <span class="n">make_gc_ref</span><span class="p">(</span><span class="s">&quot;data&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="kd">let</span> <span class="n">box_o</span> <span class="o">=</span> <span class="n">Box</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">ref_x</span><span class="p">);</span>
</span><span class='line'>        <span class="n">make_gc_ref</span><span class="p">(</span><span class="n">C</span><span class="p">(</span><span class="n">ref_x</span><span class="p">,</span> <span class="n">box_o</span><span class="p">))</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>(The types in the demo program above assume certain features like
allowing <code>Gc&lt;T&gt;</code> for <code>T: ?Sized</code>, which may or may not be reasonable.)</p>

<p>The compositionality constraint may seem obvious (especially if one starts by
assuming that references to gc-allocated objects will be values
of type <code>Gc&lt;T&gt;</code> for arbtrary <code>T</code>).</p>

<p>But a hypothetical library for implementing a particular language
could completely insulate the representations of garbage-collected
values, offering only accessor methods for manipulating their
internals. Such a constrained setting makes the GC implementors job
much easier, but at the cost of more difficult interoperation (since,
for example, in such a setting one cannot extract a reference to the
internal structure of a garbage-collected value as a <code>&amp;T</code>).</p>

<h3><a id="precision">Precision</a></h3>

<p>A precise GC is one that is eventually able to reclaim all garbage,
without being subverted by particular details of the host program or
the system state.</p>

<p>Obviously a <a href="/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work/#conservative-gc">conservative GC</a> lacks precision.</p>

<p>We would like to be able to interoperate with 100% precise collectors.</p>

<p>Ideally, we would also like to be able to interoperate with collectors
that do not support <a href="/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work/#pinning-support">pinning</a>.</p>

<h2>Conclusion</h2>

<p>This post was dedicated to identifying criteria that we would
like GC-integration with Rust to satisfy.</p>

<p>Next up: Why is it hard to satisfy the above criteria?</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Felix S. Klock II</span></span>

      








  


<time datetime="2015-10-28T15:24:00+01:00" pubdate data-updated="true"></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/gc/'>gc</a>, <a class='category' href='/blog/categories/rust/'>rust</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://blog.pnkfx.org/blog/2015/10/28/gc-and-rust-part-1-specing-the-problem/" data-via="pnkfelix" data-counturl="http://blog.pnkfx.org/blog/2015/10/28/gc-and-rust-part-1-specing-the-problem/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work/" title="Previous Post: GC and Rust Part 0: Garbage Collection Background">&laquo; GC and Rust Part 0: Garbage Collection Background</a>
      
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/10/28/gc-and-rust-part-1-specing-the-problem/">GC and Rust Part 1: Specifying the Problem (... now you have two problems)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/27/gc-and-rust-part-0-how-does-gc-work/">GC and Rust Part 0: Garbage Collection Background</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/12/viz-a-viz-js/">Vis-a-vis, part 1: Visualizing Graphs via viz.js</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/03/13/an-insight-regarding-dst-grammar-for-rust/">An insight regarding DST grammar for Rust</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/03/13/meta-updating-octopress-post-mavericks-upgrade/">Updating Octopress post-Mavericks upgrade.</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/pnkfelix">@pnkfelix</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'pnkfelix',
            count: 4,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


<section>
  <h1>On Delicious</h1>
  <div id="delicious"></div>
  <script type="text/javascript" src="http://feeds.delicious.com/v2/json/pnkfelix?count=3&amp;sort=date&amp;callback=renderDeliciousLinks"></script>
  <p><a href="http://delicious.com/pnkfelix">My Delicious Bookmarks &raquo;</a></p>
</section>


<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/pnkfelix?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Felix S. Klock II -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'pnkfx-blog';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://blog.pnkfx.org/blog/2015/10/28/gc-and-rust-part-1-specing-the-problem/';
        var disqus_url = 'http://blog.pnkfx.org/blog/2015/10/28/gc-and-rust-part-1-specing-the-problem/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
